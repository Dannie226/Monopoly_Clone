"use strict";

function _typeof( obj ) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function( obj ) {
        return typeof obj;
    } : function( obj ) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof( obj );
}

function _toConsumableArray( arr ) {
    return _arrayWithoutHoles( arr ) || _iterableToArray( arr ) || _unsupportedIterableToArray( arr ) || _nonIterableSpread( );
}

function _nonIterableSpread( ) {
    throw new TypeError( "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method." );
}

function _iterableToArray( iter ) {
    if ( typeof Symbol !== "undefined" && iter[ Symbol.iterator ] != null || iter[ "@@iterator" ] != null ) return Array.from( iter );
}

function _arrayWithoutHoles( arr ) {
    if ( Array.isArray( arr ) ) return _arrayLikeToArray( arr );
}

function asyncGeneratorStep( gen, resolve, reject, _next, _throw, key, arg ) {
    try {
        var info = gen[ key ]( arg );
        var value = info.value;
    } catch ( error ) {
        reject( error );
        return;
    }
    if ( info.done ) {
        resolve( value );
    } else {
        Promise.resolve( value ).then( _next, _throw );
    }
}

function _asyncToGenerator( fn ) {
    return function( ) {
        var self = this,
            args = arguments;
        return new Promise( function( resolve, reject ) {
            var gen = fn.apply( self, args );

            function _next( value ) {
                asyncGeneratorStep( gen, resolve, reject, _next, _throw, "next", value );
            }

            function _throw( err ) {
                asyncGeneratorStep( gen, resolve, reject, _next, _throw, "throw", err );
            }
            _next( undefined );
        } );
    };
}

function _createForOfIteratorHelper( o, allowArrayLike ) {
    var it = typeof Symbol !== "undefined" && o[ Symbol.iterator ] || o[ "@@iterator" ];
    if ( !it ) {
        if ( Array.isArray( o ) || ( it = _unsupportedIterableToArray( o ) ) || allowArrayLike && o && typeof o.length === "number" ) {
            if ( it ) o = it;
            var i = 0;
            var F = function F( ) {};
            return {
                s: F,
                n: function n( ) {
                    if ( i >= o.length ) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[ i++ ]
                    };
                },
                e: function e( _e3 ) {
                    throw _e3;
                },
                f: F
            };
        }
        throw new TypeError( "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method." );
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s( ) {
            it = it.call( o );
        },
        n: function n( ) {
            var step = it.next( );
            normalCompletion = step.done;
            return step;
        },
        e: function e( _e4 ) {
            didErr = true;
            err = _e4;
        },
        f: function f( ) {
            try {
                if ( !normalCompletion && it[ "return" ] != null ) it[ "return" ]( );
            } finally {
                if ( didErr ) throw err;
            }
        }
    };
}

function _slicedToArray( arr, i ) {
    return _arrayWithHoles( arr ) || _iterableToArrayLimit( arr, i ) || _unsupportedIterableToArray( arr, i ) || _nonIterableRest( );
}

function _nonIterableRest( ) {
    throw new TypeError( "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method." );
}

function _unsupportedIterableToArray( o, minLen ) {
    if ( !o ) return;
    if ( typeof o === "string" ) return _arrayLikeToArray( o, minLen );
    var n = Object.prototype.toString.call( o ).slice( 8, -1 );
    if ( n === "Object" && o.constructor ) n = o.constructor.name;
    if ( n === "Map" || n === "Set" ) return Array.from( o );
    if ( n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test( n ) ) return _arrayLikeToArray( o, minLen );
}

function _arrayLikeToArray( arr, len ) {
    if ( len == null || len > arr.length ) len = arr.length;
    for ( var i = 0, arr2 = new Array( len ); i < len; i++ ) {
        arr2[ i ] = arr[ i ];
    }
    return arr2;
}

function _iterableToArrayLimit( arr, i ) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[ Symbol.iterator ] || arr[ "@@iterator" ];
    if ( _i == null ) return;
    var _arr = [ ];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for ( _i = _i.call( arr ); !( _n = ( _s = _i.next( ) ).done ); _n = true ) {
            _arr.push( _s.value );
            if ( i && _arr.length === i ) break;
        }
    } catch ( err ) {
        _d = true;
        _e = err;
    } finally {
        try {
            if ( !_n && _i[ "return" ] != null ) _i[ "return" ]( );
        } finally {
            if ( _d ) throw _e;
        }
    }
    return _arr;
}

function _arrayWithHoles( arr ) {
    if ( Array.isArray( arr ) ) return arr;
}

function _get( ) {
    if ( typeof Reflect !== "undefined" && Reflect.get ) {
        _get = Reflect.get.bind( );
    } else {
        _get = function _get( target, property, receiver ) {
            var base = _superPropBase( target, property );
            if ( !base ) return;
            var desc = Object.getOwnPropertyDescriptor( base, property );
            if ( desc.get ) {
                return desc.get.call( arguments.length < 3 ? target : receiver );
            }
            return desc.value;
        };
    }
    return _get.apply( this, arguments );
}

function _superPropBase( object, property ) {
    while ( !Object.prototype.hasOwnProperty.call( object, property ) ) {
        object = _getPrototypeOf( object );
        if ( object === null ) break;
    }
    return object;
}

function _inherits( subClass, superClass ) {
    if ( typeof superClass !== "function" && superClass !== null ) {
        throw new TypeError( "Super expression must either be null or a function" );
    }
    subClass.prototype = Object.create( superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    } );
    Object.defineProperty( subClass, "prototype", {
        writable: false
    } );
    if ( superClass ) _setPrototypeOf( subClass, superClass );
}

function _setPrototypeOf( o, p ) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind( ) : function _setPrototypeOf( o, p ) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf( o, p );
}

function _createSuper( Derived ) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct( );
    return function _createSuperInternal( ) {
        var Super = _getPrototypeOf( Derived ),
            result;
        if ( hasNativeReflectConstruct ) {
            var NewTarget = _getPrototypeOf( this ).constructor;
            result = Reflect.construct( Super, arguments, NewTarget );
        } else {
            result = Super.apply( this, arguments );
        }
        return _possibleConstructorReturn( this, result );
    };
}

function _possibleConstructorReturn( self, call ) {
    if ( call && ( _typeof( call ) === "object" || typeof call === "function" ) ) {
        return call;
    } else if ( call !== void 0 ) {
        throw new TypeError( "Derived constructors may only return object or undefined" );
    }
    return _assertThisInitialized( self );
}

function _assertThisInitialized( self ) {
    if ( self === void 0 ) {
        throw new ReferenceError( "this hasn't been initialised - super() hasn't been called" );
    }
    return self;
}

function _isNativeReflectConstruct( ) {
    if ( typeof Reflect === "undefined" || !Reflect.construct ) return false;
    if ( Reflect.construct.sham ) return false;
    if ( typeof Proxy === "function" ) return true;
    try {
        Boolean.prototype.valueOf.call( Reflect.construct( Boolean, [ ], function( ) {} ) );
        return true;
    } catch ( e ) {
        return false;
    }
}

function _getPrototypeOf( o ) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind( ) : function _getPrototypeOf( o ) {
        return o.__proto__ || Object.getPrototypeOf( o );
    };
    return _getPrototypeOf( o );
}

function _defineProperty( obj, key, value ) {
    if ( key in obj ) {
        Object.defineProperty( obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        } );
    } else {
        obj[ key ] = value;
    }
    return obj;
}

function _regeneratorRuntime( ) {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime( ) {
        return exports;
    };
    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define( obj, key, value ) {
        return Object.defineProperty( obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        } ), obj[ key ];
    }
    try {
        define( {}, "" );
    } catch ( err ) {
        define = function define( obj, key, value ) {
            return obj[ key ] = value;
        };
    }

    function wrap( innerFn, outerFn, self, tryLocsList ) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create( protoGenerator.prototype ),
            context = new Context( tryLocsList || [ ] );
        return generator._invoke = function( innerFn, self, context ) {
            var state = "suspendedStart";
            return function( method, arg ) {
                if ( "executing" === state ) throw new Error( "Generator is already running" );
                if ( "completed" === state ) {
                    if ( "throw" === method ) throw arg;
                    return doneResult( );
                }
                for ( context.method = method, context.arg = arg;; ) {
                    var delegate = context.delegate;
                    if ( delegate ) {
                        var delegateResult = maybeInvokeDelegate( delegate, context );
                        if ( delegateResult ) {
                            if ( delegateResult === ContinueSentinel ) continue;
                            return delegateResult;
                        }
                    }
                    if ( "next" === context.method ) context.sent = context._sent = context.arg;
                    else if ( "throw" === context.method ) {
                        if ( "suspendedStart" === state ) throw state = "completed", context.arg;
                        context.dispatchException( context.arg );
                    } else "return" === context.method && context.abrupt( "return", context.arg );
                    state = "executing";
                    var record = tryCatch( innerFn, self, context );
                    if ( "normal" === record.type ) {
                        if ( state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel ) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    }
                    "throw" === record.type && ( state = "completed", context.method = "throw", context.arg = record.arg );
                }
            };
        }( innerFn, self, context ), generator;
    }

    function tryCatch( fn, obj, arg ) {
        try {
            return {
                type: "normal",
                arg: fn.call( obj, arg )
            };
        } catch ( err ) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator( ) {}

    function GeneratorFunction( ) {}

    function GeneratorFunctionPrototype( ) {}
    var IteratorPrototype = {};
    define( IteratorPrototype, iteratorSymbol, function( ) {
        return this;
    } );
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto( getProto( values( [ ] ) ) );
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call( NativeIteratorPrototype, iteratorSymbol ) && ( IteratorPrototype = NativeIteratorPrototype );
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create( IteratorPrototype );

    function defineIteratorMethods( prototype ) {
        [ "next", "throw", "return" ].forEach( function( method ) {
            define( prototype, method, function( arg ) {
                return this._invoke( method, arg );
            } );
        } );
    }

    function AsyncIterator( generator, PromiseImpl ) {
        function invoke( method, arg, resolve, reject ) {
            var record = tryCatch( generator[ method ], generator, arg );
            if ( "throw" !== record.type ) {
                var result = record.arg,
                    value = result.value;
                return value && "object" == _typeof( value ) && hasOwn.call( value, "__await" ) ? PromiseImpl.resolve( value.__await ).then( function( value ) {
                    invoke( "next", value, resolve, reject );
                }, function( err ) {
                    invoke( "throw", err, resolve, reject );
                } ) : PromiseImpl.resolve( value ).then( function( unwrapped ) {
                    result.value = unwrapped, resolve( result );
                }, function( error ) {
                    return invoke( "throw", error, resolve, reject );
                } );
            }
            reject( record.arg );
        }
        var previousPromise;
        this._invoke = function( method, arg ) {
            function callInvokeWithMethodAndArg( ) {
                return new PromiseImpl( function( resolve, reject ) {
                    invoke( method, arg, resolve, reject );
                } );
            }
            return previousPromise = previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg( );
        };
    }

    function maybeInvokeDelegate( delegate, context ) {
        var method = delegate.iterator[ context.method ];
        if ( undefined === method ) {
            if ( context.delegate = null, "throw" === context.method ) {
                if ( delegate.iterator[ "return" ] && ( context.method = "return", context.arg = undefined, maybeInvokeDelegate( delegate, context ), "throw" === context.method ) ) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError( "The iterator does not provide a 'throw' method" );
            }
            return ContinueSentinel;
        }
        var record = tryCatch( method, delegate.iterator, context.arg );
        if ( "throw" === record.type ) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? ( context[ delegate.resultName ] = info.value, context.next = delegate.nextLoc, "return" !== context.method && ( context.method = "next", context.arg = undefined ), context.delegate = null, ContinueSentinel ) : info : ( context.method = "throw", context.arg = new TypeError( "iterator result is not an object" ), context.delegate = null, ContinueSentinel );
    }

    function pushTryEntry( locs ) {
        var entry = {
            tryLoc: locs[ 0 ]
        };
        1 in locs && ( entry.catchLoc = locs[ 1 ] ), 2 in locs && ( entry.finallyLoc = locs[ 2 ], entry.afterLoc = locs[ 3 ] ), this.tryEntries.push( entry );
    }

    function resetTryEntry( entry ) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context( tryLocsList ) {
        this.tryEntries = [ {
            tryLoc: "root"
        } ], tryLocsList.forEach( pushTryEntry, this ), this.reset( !0 );
    }

    function values( iterable ) {
        if ( iterable ) {
            var iteratorMethod = iterable[ iteratorSymbol ];
            if ( iteratorMethod ) return iteratorMethod.call( iterable );
            if ( "function" == typeof iterable.next ) return iterable;
            if ( !isNaN( iterable.length ) ) {
                var i = -1,
                    next = function next( ) {
                        for ( ; ++i < iterable.length; ) {
                            if ( hasOwn.call( iterable, i ) ) return next.value = iterable[ i ], next.done = !1, next;
                        }
                        return next.value = undefined, next.done = !0, next;
                    };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }

    function doneResult( ) {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define( Gp, "constructor", GeneratorFunctionPrototype ), define( GeneratorFunctionPrototype, "constructor", GeneratorFunction ), GeneratorFunction.displayName = define( GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction" ), exports.isGeneratorFunction = function( genFun ) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && ( ctor === GeneratorFunction || "GeneratorFunction" === ( ctor.displayName || ctor.name ) );
    }, exports.mark = function( genFun ) {
        return Object.setPrototypeOf ? Object.setPrototypeOf( genFun, GeneratorFunctionPrototype ) : ( genFun.__proto__ = GeneratorFunctionPrototype, define( genFun, toStringTagSymbol, "GeneratorFunction" ) ), genFun.prototype = Object.create( Gp ), genFun;
    }, exports.awrap = function( arg ) {
        return {
            __await: arg
        };
    }, defineIteratorMethods( AsyncIterator.prototype ), define( AsyncIterator.prototype, asyncIteratorSymbol, function( ) {
        return this;
    } ), exports.AsyncIterator = AsyncIterator, exports.async = function( innerFn, outerFn, self, tryLocsList, PromiseImpl ) {
        void 0 === PromiseImpl && ( PromiseImpl = Promise );
        var iter = new AsyncIterator( wrap( innerFn, outerFn, self, tryLocsList ), PromiseImpl );
        return exports.isGeneratorFunction( outerFn ) ? iter : iter.next( ).then( function( result ) {
            return result.done ? result.value : iter.next( );
        } );
    }, defineIteratorMethods( Gp ), define( Gp, toStringTagSymbol, "Generator" ), define( Gp, iteratorSymbol, function( ) {
        return this;
    } ), define( Gp, "toString", function( ) {
        return "[object Generator]";
    } ), exports.keys = function( object ) {
        var keys = [ ];
        for ( var key in object ) {
            keys.push( key );
        }
        return keys.reverse( ),
            function next( ) {
                for ( ; keys.length; ) {
                    var key = keys.pop( );
                    if ( key in object ) return next.value = key, next.done = !1, next;
                }
                return next.done = !0, next;
            };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset( skipTempReset ) {
            if ( this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach( resetTryEntry ), !skipTempReset )
                for ( var name in this ) {
                    "t" === name.charAt( 0 ) && hasOwn.call( this, name ) && !isNaN( +name.slice( 1 ) ) && ( this[ name ] = undefined );
                }
        },
        stop: function stop( ) {
            this.done = !0;
            var rootRecord = this.tryEntries[ 0 ].completion;
            if ( "throw" === rootRecord.type ) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException( exception ) {
            if ( this.done ) throw exception;
            var context = this;

            function handle( loc, caught ) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && ( context.method = "next", context.arg = undefined ), !!caught;
            }
            for ( var i = this.tryEntries.length - 1; i >= 0; --i ) {
                var entry = this.tryEntries[ i ],
                    record = entry.completion;
                if ( "root" === entry.tryLoc ) return handle( "end" );
                if ( entry.tryLoc <= this.prev ) {
                    var hasCatch = hasOwn.call( entry, "catchLoc" ),
                        hasFinally = hasOwn.call( entry, "finallyLoc" );
                    if ( hasCatch && hasFinally ) {
                        if ( this.prev < entry.catchLoc ) return handle( entry.catchLoc, !0 );
                        if ( this.prev < entry.finallyLoc ) return handle( entry.finallyLoc );
                    } else if ( hasCatch ) {
                        if ( this.prev < entry.catchLoc ) return handle( entry.catchLoc, !0 );
                    } else {
                        if ( !hasFinally ) throw new Error( "try statement without catch or finally" );
                        if ( this.prev < entry.finallyLoc ) return handle( entry.finallyLoc );
                    }
                }
            }
        },
        abrupt: function abrupt( type, arg ) {
            for ( var i = this.tryEntries.length - 1; i >= 0; --i ) {
                var entry = this.tryEntries[ i ];
                if ( entry.tryLoc <= this.prev && hasOwn.call( entry, "finallyLoc" ) && this.prev < entry.finallyLoc ) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ( "break" === type || "continue" === type ) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && ( finallyEntry = null );
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? ( this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel ) : this.complete( record );
        },
        complete: function complete( record, afterLoc ) {
            if ( "throw" === record.type ) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? ( this.rval = this.arg = record.arg, this.method = "return", this.next = "end" ) : "normal" === record.type && afterLoc && ( this.next = afterLoc ), ContinueSentinel;
        },
        finish: function finish( finallyLoc ) {
            for ( var i = this.tryEntries.length - 1; i >= 0; --i ) {
                var entry = this.tryEntries[ i ];
                if ( entry.finallyLoc === finallyLoc ) return this.complete( entry.completion, entry.afterLoc ), resetTryEntry( entry ), ContinueSentinel;
            }
        },
        "catch": function _catch( tryLoc ) {
            for ( var i = this.tryEntries.length - 1; i >= 0; --i ) {
                var entry = this.tryEntries[ i ];
                if ( entry.tryLoc === tryLoc ) {
                    var record = entry.completion;
                    if ( "throw" === record.type ) {
                        var thrown = record.arg;
                        resetTryEntry( entry );
                    }
                    return thrown;
                }
            }
            throw new Error( "illegal catch attempt" );
        },
        delegateYield: function delegateYield( iterable, resultName, nextLoc ) {
            return this.delegate = {
                iterator: values( iterable ),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && ( this.arg = undefined ), ContinueSentinel;
        }
    }, exports;
}

function _classCallCheck( instance, Constructor ) {
    if ( !( instance instanceof Constructor ) ) {
        throw new TypeError( "Cannot call a class as a function" );
    }
}

function _defineProperties( target, props ) {
    for ( var i = 0; i < props.length; i++ ) {
        var descriptor = props[ i ];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ( "value" in descriptor ) descriptor.writable = true;
        Object.defineProperty( target, descriptor.key, descriptor );
    }
}

function _createClass( Constructor, protoProps, staticProps ) {
    if ( protoProps ) _defineProperties( Constructor.prototype, protoProps );
    if ( staticProps ) _defineProperties( Constructor, staticProps );
    Object.defineProperty( Constructor, "prototype", {
        writable: false
    } );
    return Constructor;
}( function( ) {
    'use strict';
    /**
     * @license
     * Copyright 2010-2022 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    var _FN;
    var REVISION = '142';
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var VSMShadowMap = 3;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var CineonToneMapping = 3;
    var ACESFilmicToneMapping = 4;
    var CustomToneMapping = 5;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var CubeUVReflectionMapping = 306;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipmapNearestFilter = 1004;
    var NearestMipmapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipmapNearestFilter = 1007;
    var LinearMipmapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RedFormat = 1028;
    var RedIntegerFormat = 1029;
    var RGFormat = 1030;
    var RGIntegerFormat = 1031;
    var RGBAIntegerFormat = 1033;
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGB_ETC2_Format = 37492;
    var RGBA_ETC2_EAC_Format = 37496;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var RGBA_BPTC_Format = 36492;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var NormalAnimationBlendMode = 2500;
    var AdditiveAnimationBlendMode = 2501;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var TangentSpaceNormalMap = 0;
    var ObjectSpaceNormalMap = 1;
    var SRGBColorSpace = 'srgb';
    var LinearSRGBColorSpace = 'srgb-linear';
    var KeepStencilOp = 7680;
    var AlwaysStencilFunc = 519;
    var StaticDrawUsage = 35044;
    var DynamicDrawUsage = 35048;
    var GLSL3 = '300 es';
    var _SRGBAFormat = 1035; // fallback for WebGL 1
    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */
    var EventDispatcher = /*#__PURE__*/ function( ) {
        function EventDispatcher( ) {
            _classCallCheck( this, EventDispatcher );
        }
        _createClass( EventDispatcher, [ {
            key: "addEventListener",
            value: function addEventListener( type, listener ) {
                if ( this._listeners === undefined ) this._listeners = {};
                var listeners = this._listeners;
                if ( listeners[ type ] === undefined ) {
                    listeners[ type ] = [ ];
                }
                if ( listeners[ type ].indexOf( listener ) === -1 ) {
                    listeners[ type ].push( listener );
                }
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener( type, listener ) {
                if ( this._listeners === undefined ) return false;
                var listeners = this._listeners;
                return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;
            }
        }, {
            key: "removeEventListener",
            value: function removeEventListener( type, listener ) {
                if ( this._listeners === undefined ) return;
                var listeners = this._listeners;
                var listenerArray = listeners[ type ];
                if ( listenerArray !== undefined ) {
                    var index = listenerArray.indexOf( listener );
                    if ( index !== -1 ) {
                        listenerArray.splice( index, 1 );
                    }
                }
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent( event ) {
                if ( this._listeners === undefined ) return;
                var listeners = this._listeners;
                var listenerArray = listeners[ event.type ];
                if ( listenerArray !== undefined ) {
                    event.target = this; // Make a copy, in case listeners are removed while iterating.
                    var array = listenerArray.slice( 0 );
                    for ( var _i2 = 0, l = array.length; _i2 < l; _i2++ ) {
                        array[ _i2 ].call( this, event );
                    }
                    event.target = null;
                }
            }
        } ] );
        return EventDispatcher;
    }( );
    var _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];
    var _seed = 1234567;
    var DEG2RAD = Math.PI / 180;
    var RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    function generateUUID( ) {
        var d0 = Math.random( ) * 0xffffffff | 0;
        var d1 = Math.random( ) * 0xffffffff | 0;
        var d2 = Math.random( ) * 0xffffffff | 0;
        var d3 = Math.random( ) * 0xffffffff | 0;
        var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' + _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' + _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] + _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ]; // .toLowerCase() here flattens concatenated strings to save heap memory space.
        return uuid.toLowerCase( );
    }

    function clamp( value, min, max ) {
        return Math.max( min, Math.min( max, value ) );
    } // compute euclidean modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    function euclideanModulo( n, m ) {
        return ( n % m + m ) % m;
    } // Linear mapping from range <a1, a2> to range <b1, b2>
    function mapLinear( x, a1, a2, b1, b2 ) {
        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
    } // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
    function inverseLerp( x, y, value ) {
        if ( x !== y ) {
            return ( value - x ) / ( y - x );
        } else {
            return 0;
        }
    } // https://en.wikipedia.org/wiki/Linear_interpolation
    function lerp( x, y, t ) {
        return ( 1 - t ) * x + t * y;
    } // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
    function damp( x, y, lambda, dt ) {
        return lerp( x, y, 1 - Math.exp( -lambda * dt ) );
    } // https://www.desmos.com/calculator/vcsjnyz7x4
    function pingpong( x ) {
        var length = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
        return length - Math.abs( euclideanModulo( x, length * 2 ) - length );
    } // http://en.wikipedia.org/wiki/Smoothstep
    function smoothstep( x, min, max ) {
        if ( x <= min ) return 0;
        if ( x >= max ) return 1;
        x = ( x - min ) / ( max - min );
        return x * x * ( 3 - 2 * x );
    }

    function smootherstep( x, min, max ) {
        if ( x <= min ) return 0;
        if ( x >= max ) return 1;
        x = ( x - min ) / ( max - min );
        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
    } // Random integer from <low, high> interval
    function randInt( low, high ) {
        return low + Math.floor( Math.random( ) * ( high - low + 1 ) );
    } // Random float from <low, high> interval
    function randFloat( low, high ) {
        return low + Math.random( ) * ( high - low );
    } // Random float from <-range/2, range/2> interval
    function randFloatSpread( range ) {
        return range * ( 0.5 - Math.random( ) );
    } // Deterministic pseudo-random float in the interval [ 0, 1 ]
    function seededRandom( s ) {
        if ( s !== undefined ) _seed = s; // Mulberry32 generator
        var t = _seed += 0x6D2B79F5;
        t = Math.imul( t ^ t >>> 15, t | 1 );
        t ^= t + Math.imul( t ^ t >>> 7, t | 61 );
        return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;
    }

    function degToRad( degrees ) {
        return degrees * DEG2RAD;
    }

    function radToDeg( radians ) {
        return radians * RAD2DEG;
    }

    function isPowerOfTwo( value ) {
        return ( value & value - 1 ) === 0 && value !== 0;
    }

    function ceilPowerOfTwo( value ) {
        return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );
    }

    function floorPowerOfTwo( value ) {
        return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );
    }

    function setQuaternionFromProperEuler( q, a, b, c, order ) { // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
        // rotations are applied to the axes in the order specified by 'order'
        // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
        // angles are in radians
        var cos = Math.cos;
        var sin = Math.sin;
        var c2 = cos( b / 2 );
        var s2 = sin( b / 2 );
        var c13 = cos( ( a + c ) / 2 );
        var s13 = sin( ( a + c ) / 2 );
        var c1_3 = cos( ( a - c ) / 2 );
        var s1_3 = sin( ( a - c ) / 2 );
        var c3_1 = cos( ( c - a ) / 2 );
        var s3_1 = sin( ( c - a ) / 2 );
        switch ( order ) {
            case 'XYX':
                q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
                break;
            case 'YZY':
                q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
                break;
            case 'ZXZ':
                q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
                break;
            case 'XZX':
                q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
                break;
            case 'YXY':
                q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
                break;
            case 'ZYZ':
                q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
                break;
            default:
                console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );
        }
    }

    function denormalize$1( value, array ) {
        switch ( array.constructor ) {
            case Float32Array:
                return value;
            case Uint16Array:
                return value / 65535.0;
            case Uint8Array:
                return value / 255.0;
            case Int16Array:
                return Math.max( value / 32767.0, -1.0 );
            case Int8Array:
                return Math.max( value / 127.0, -1.0 );
            default:
                throw new Error( 'Invalid component type.' );
        }
    }

    function normalize( value, array ) {
        switch ( array.constructor ) {
            case Float32Array:
                return value;
            case Uint16Array:
                return Math.round( value * 65535.0 );
            case Uint8Array:
                return Math.round( value * 255.0 );
            case Int16Array:
                return Math.round( value * 32767.0 );
            case Int8Array:
                return Math.round( value * 127.0 );
            default:
                throw new Error( 'Invalid component type.' );
        }
    }
    var MathUtils = /*#__PURE__*/ Object.freeze( {
        __proto__: null,
        DEG2RAD: DEG2RAD,
        RAD2DEG: RAD2DEG,
        generateUUID: generateUUID,
        clamp: clamp,
        euclideanModulo: euclideanModulo,
        mapLinear: mapLinear,
        inverseLerp: inverseLerp,
        lerp: lerp,
        damp: damp,
        pingpong: pingpong,
        smoothstep: smoothstep,
        smootherstep: smootherstep,
        randInt: randInt,
        randFloat: randFloat,
        randFloatSpread: randFloatSpread,
        seededRandom: seededRandom,
        degToRad: degToRad,
        radToDeg: radToDeg,
        isPowerOfTwo: isPowerOfTwo,
        ceilPowerOfTwo: ceilPowerOfTwo,
        floorPowerOfTwo: floorPowerOfTwo,
        setQuaternionFromProperEuler: setQuaternionFromProperEuler,
        normalize: normalize,
        denormalize: denormalize$1
    } );
    var Vector2 = /*#__PURE__*/ function( _Symbol$iterator ) {
        function Vector2( ) {
            var x = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0;
            var y = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            _classCallCheck( this, Vector2 );
            Vector2.prototype.isVector2 = true;
            this.x = x;
            this.y = y;
        }
        _createClass( Vector2, [ {
            key: "width",
            get: function get( ) {
                return this.x;
            },
            set: function set( value ) {
                this.x = value;
            }
        }, {
            key: "height",
            get: function get( ) {
                return this.y;
            },
            set: function set( value ) {
                this.y = value;
            }
        }, {
            key: "set",
            value: function set( x, y ) {
                this.x = x;
                this.y = y;
                return this;
            }
        }, {
            key: "setScalar",
            value: function setScalar( scalar ) {
                this.x = scalar;
                this.y = scalar;
                return this;
            }
        }, {
            key: "setX",
            value: function setX( x ) {
                this.x = x;
                return this;
            }
        }, {
            key: "setY",
            value: function setY( y ) {
                this.y = y;
                return this;
            }
        }, {
            key: "setComponent",
            value: function setComponent( index, value ) {
                switch ( index ) {
                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
                return this;
            }
        }, {
            key: "getComponent",
            value: function getComponent( index ) {
                switch ( index ) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this.x, this.y );
            }
        }, {
            key: "copy",
            value: function copy( v ) {
                this.x = v.x;
                this.y = v.y;
                return this;
            }
        }, {
            key: "add",
            value: function add( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                    return this.addVectors( v, w );
                }
                this.x += v.x;
                this.y += v.y;
                return this;
            }
        }, {
            key: "addScalar",
            value: function addScalar( s ) {
                this.x += s;
                this.y += s;
                return this;
            }
        }, {
            key: "addVectors",
            value: function addVectors( a, b ) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                return this;
            }
        }, {
            key: "addScaledVector",
            value: function addScaledVector( v, s ) {
                this.x += v.x * s;
                this.y += v.y * s;
                return this;
            }
        }, {
            key: "sub",
            value: function sub( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                    return this.subVectors( v, w );
                }
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }
        }, {
            key: "subScalar",
            value: function subScalar( s ) {
                this.x -= s;
                this.y -= s;
                return this;
            }
        }, {
            key: "subVectors",
            value: function subVectors( a, b ) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( v ) {
                this.x *= v.x;
                this.y *= v.y;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( scalar ) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }
        }, {
            key: "divide",
            value: function divide( v ) {
                this.x /= v.x;
                this.y /= v.y;
                return this;
            }
        }, {
            key: "divideScalar",
            value: function divideScalar( scalar ) {
                return this.multiplyScalar( 1 / scalar );
            }
        }, {
            key: "applyMatrix3",
            value: function applyMatrix3( m ) {
                var x = this.x,
                    y = this.y;
                var e = m.elements;
                this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
                this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];
                return this;
            }
        }, {
            key: "min",
            value: function min( v ) {
                this.x = Math.min( this.x, v.x );
                this.y = Math.min( this.y, v.y );
                return this;
            }
        }, {
            key: "max",
            value: function max( v ) {
                this.x = Math.max( this.x, v.x );
                this.y = Math.max( this.y, v.y );
                return this;
            }
        }, {
            key: "clamp",
            value: function clamp( min, max ) { // assumes min < max, componentwise
                this.x = Math.max( min.x, Math.min( max.x, this.x ) );
                this.y = Math.max( min.y, Math.min( max.y, this.y ) );
                return this;
            }
        }, {
            key: "clampScalar",
            value: function clampScalar( minVal, maxVal ) {
                this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
                this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
                return this;
            }
        }, {
            key: "clampLength",
            value: function clampLength( min, max ) {
                var length = this.length( );
                return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
            }
        }, {
            key: "floor",
            value: function floor( ) {
                this.x = Math.floor( this.x );
                this.y = Math.floor( this.y );
                return this;
            }
        }, {
            key: "ceil",
            value: function ceil( ) {
                this.x = Math.ceil( this.x );
                this.y = Math.ceil( this.y );
                return this;
            }
        }, {
            key: "round",
            value: function round( ) {
                this.x = Math.round( this.x );
                this.y = Math.round( this.y );
                return this;
            }
        }, {
            key: "roundToZero",
            value: function roundToZero( ) {
                this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x );
                this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y );
                return this;
            }
        }, {
            key: "negate",
            value: function negate( ) {
                this.x = -this.x;
                this.y = -this.y;
                return this;
            }
        }, {
            key: "dot",
            value: function dot( v ) {
                return this.x * v.x + this.y * v.y;
            }
        }, {
            key: "cross",
            value: function cross( v ) {
                return this.x * v.y - this.y * v.x;
            }
        }, {
            key: "lengthSq",
            value: function lengthSq( ) {
                return this.x * this.x + this.y * this.y;
            }
        }, {
            key: "length",
            value: function length( ) {
                return Math.sqrt( this.x * this.x + this.y * this.y );
            }
        }, {
            key: "manhattanLength",
            value: function manhattanLength( ) {
                return Math.abs( this.x ) + Math.abs( this.y );
            }
        }, {
            key: "normalize",
            value: function normalize( ) {
                return this.divideScalar( this.length( ) || 1 );
            }
        }, {
            key: "angle",
            value: function angle( ) { // computes the angle in radians with respect to the positive x-axis
                var angle = Math.atan2( -this.y, -this.x ) + Math.PI;
                return angle;
            }
        }, {
            key: "distanceTo",
            value: function distanceTo( v ) {
                return Math.sqrt( this.distanceToSquared( v ) );
            }
        }, {
            key: "distanceToSquared",
            value: function distanceToSquared( v ) {
                var dx = this.x - v.x,
                    dy = this.y - v.y;
                return dx * dx + dy * dy;
            }
        }, {
            key: "manhattanDistanceTo",
            value: function manhattanDistanceTo( v ) {
                return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
            }
        }, {
            key: "setLength",
            value: function setLength( length ) {
                return this.normalize( ).multiplyScalar( length );
            }
        }, {
            key: "lerp",
            value: function lerp( v, alpha ) {
                this.x += ( v.x - this.x ) * alpha;
                this.y += ( v.y - this.y ) * alpha;
                return this;
            }
        }, {
            key: "lerpVectors",
            value: function lerpVectors( v1, v2, alpha ) {
                this.x = v1.x + ( v2.x - v1.x ) * alpha;
                this.y = v1.y + ( v2.y - v1.y ) * alpha;
                return this;
            }
        }, {
            key: "equals",
            value: function equals( v ) {
                return v.x === this.x && v.y === this.y;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.x = array[ offset ];
                this.y = array[ offset + 1 ];
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this.x;
                array[ offset + 1 ] = this.y;
                return array;
            }
        }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute( attribute, index, offset ) {
                if ( offset !== undefined ) {
                    console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
                }
                this.x = attribute.getX( index );
                this.y = attribute.getY( index );
                return this;
            }
        }, {
            key: "rotateAround",
            value: function rotateAround( center, angle ) {
                var c = Math.cos( angle ),
                    s = Math.sin( angle );
                var x = this.x - center.x;
                var y = this.y - center.y;
                this.x = x * c - y * s + center.x;
                this.y = x * s + y * c + center.y;
                return this;
            }
        }, {
            key: "random",
            value: function random( ) {
                this.x = Math.random( );
                this.y = Math.random( );
                return this;
            }
        }, {
            key: _Symbol$iterator,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context2 ) {
                    while ( 1 ) {
                        switch ( _context2.prev = _context2.next ) {
                            case 0:
                                _context2.next = 2;
                                return this.x;
                            case 2:
                                _context2.next = 4;
                                return this.y;
                            case 4:
                            case "end":
                                return _context2.stop( );
                        }
                    }
                }, value, this );
            } )
        } ] );
        return Vector2;
    }( Symbol.iterator );
    var Matrix3 = /*#__PURE__*/ function( ) {
        function Matrix3( ) {
            _classCallCheck( this, Matrix3 );
            Matrix3.prototype.isMatrix3 = true;
            this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
            if ( arguments.length > 0 ) {
                console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
            }
        }
        _createClass( Matrix3, [ {
            key: "set",
            value: function set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
                var te = this.elements;
                te[ 0 ] = n11;
                te[ 1 ] = n21;
                te[ 2 ] = n31;
                te[ 3 ] = n12;
                te[ 4 ] = n22;
                te[ 5 ] = n32;
                te[ 6 ] = n13;
                te[ 7 ] = n23;
                te[ 8 ] = n33;
                return this;
            }
        }, {
            key: "identity",
            value: function identity( ) {
                this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "copy",
            value: function copy( m ) {
                var te = this.elements;
                var me = m.elements;
                te[ 0 ] = me[ 0 ];
                te[ 1 ] = me[ 1 ];
                te[ 2 ] = me[ 2 ];
                te[ 3 ] = me[ 3 ];
                te[ 4 ] = me[ 4 ];
                te[ 5 ] = me[ 5 ];
                te[ 6 ] = me[ 6 ];
                te[ 7 ] = me[ 7 ];
                te[ 8 ] = me[ 8 ];
                return this;
            }
        }, {
            key: "extractBasis",
            value: function extractBasis( xAxis, yAxis, zAxis ) {
                xAxis.setFromMatrix3Column( this, 0 );
                yAxis.setFromMatrix3Column( this, 1 );
                zAxis.setFromMatrix3Column( this, 2 );
                return this;
            }
        }, {
            key: "setFromMatrix4",
            value: function setFromMatrix4( m ) {
                var me = m.elements;
                this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] );
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( m ) {
                return this.multiplyMatrices( this, m );
            }
        }, {
            key: "premultiply",
            value: function premultiply( m ) {
                return this.multiplyMatrices( m, this );
            }
        }, {
            key: "multiplyMatrices",
            value: function multiplyMatrices( a, b ) {
                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;
                var a11 = ae[ 0 ],
                    a12 = ae[ 3 ],
                    a13 = ae[ 6 ];
                var a21 = ae[ 1 ],
                    a22 = ae[ 4 ],
                    a23 = ae[ 7 ];
                var a31 = ae[ 2 ],
                    a32 = ae[ 5 ],
                    a33 = ae[ 8 ];
                var b11 = be[ 0 ],
                    b12 = be[ 3 ],
                    b13 = be[ 6 ];
                var b21 = be[ 1 ],
                    b22 = be[ 4 ],
                    b23 = be[ 7 ];
                var b31 = be[ 2 ],
                    b32 = be[ 5 ],
                    b33 = be[ 8 ];
                te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
                te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
                te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
                te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
                te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
                te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
                te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
                te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
                te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( s ) {
                var te = this.elements;
                te[ 0 ] *= s;
                te[ 3 ] *= s;
                te[ 6 ] *= s;
                te[ 1 ] *= s;
                te[ 4 ] *= s;
                te[ 7 ] *= s;
                te[ 2 ] *= s;
                te[ 5 ] *= s;
                te[ 8 ] *= s;
                return this;
            }
        }, {
            key: "determinant",
            value: function determinant( ) {
                var te = this.elements;
                var a = te[ 0 ],
                    b = te[ 1 ],
                    c = te[ 2 ],
                    d = te[ 3 ],
                    e = te[ 4 ],
                    f = te[ 5 ],
                    g = te[ 6 ],
                    h = te[ 7 ],
                    i = te[ 8 ];
                return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            }
        }, {
            key: "invert",
            value: function invert( ) {
                var te = this.elements,
                    n11 = te[ 0 ],
                    n21 = te[ 1 ],
                    n31 = te[ 2 ],
                    n12 = te[ 3 ],
                    n22 = te[ 4 ],
                    n32 = te[ 5 ],
                    n13 = te[ 6 ],
                    n23 = te[ 7 ],
                    n33 = te[ 8 ],
                    t11 = n33 * n22 - n32 * n23,
                    t12 = n32 * n13 - n33 * n12,
                    t13 = n23 * n12 - n22 * n13,
                    det = n11 * t11 + n21 * t12 + n31 * t13;
                if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );
                var detInv = 1 / det;
                te[ 0 ] = t11 * detInv;
                te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
                te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
                te[ 3 ] = t12 * detInv;
                te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
                te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
                te[ 6 ] = t13 * detInv;
                te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
                te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
                return this;
            }
        }, {
            key: "transpose",
            value: function transpose( ) {
                var tmp;
                var m = this.elements;
                tmp = m[ 1 ];
                m[ 1 ] = m[ 3 ];
                m[ 3 ] = tmp;
                tmp = m[ 2 ];
                m[ 2 ] = m[ 6 ];
                m[ 6 ] = tmp;
                tmp = m[ 5 ];
                m[ 5 ] = m[ 7 ];
                m[ 7 ] = tmp;
                return this;
            }
        }, {
            key: "getNormalMatrix",
            value: function getNormalMatrix( matrix4 ) {
                return this.setFromMatrix4( matrix4 ).invert( ).transpose( );
            }
        }, {
            key: "transposeIntoArray",
            value: function transposeIntoArray( r ) {
                var m = this.elements;
                r[ 0 ] = m[ 0 ];
                r[ 1 ] = m[ 3 ];
                r[ 2 ] = m[ 6 ];
                r[ 3 ] = m[ 1 ];
                r[ 4 ] = m[ 4 ];
                r[ 5 ] = m[ 7 ];
                r[ 6 ] = m[ 2 ];
                r[ 7 ] = m[ 5 ];
                r[ 8 ] = m[ 8 ];
                return this;
            }
        }, {
            key: "setUvTransform",
            value: function setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {
                var c = Math.cos( rotation );
                var s = Math.sin( rotation );
                this.set( sx * c, sx * s, -sx * ( c * cx + s * cy ) + cx + tx, -sy * s, sy * c, -sy * ( -s * cx + c * cy ) + cy + ty, 0, 0, 1 );
                return this;
            }
        }, {
            key: "scale",
            value: function scale( sx, sy ) {
                var te = this.elements;
                te[ 0 ] *= sx;
                te[ 3 ] *= sx;
                te[ 6 ] *= sx;
                te[ 1 ] *= sy;
                te[ 4 ] *= sy;
                te[ 7 ] *= sy;
                return this;
            }
        }, {
            key: "rotate",
            value: function rotate( theta ) {
                var c = Math.cos( theta );
                var s = Math.sin( theta );
                var te = this.elements;
                var a11 = te[ 0 ],
                    a12 = te[ 3 ],
                    a13 = te[ 6 ];
                var a21 = te[ 1 ],
                    a22 = te[ 4 ],
                    a23 = te[ 7 ];
                te[ 0 ] = c * a11 + s * a21;
                te[ 3 ] = c * a12 + s * a22;
                te[ 6 ] = c * a13 + s * a23;
                te[ 1 ] = -s * a11 + c * a21;
                te[ 4 ] = -s * a12 + c * a22;
                te[ 7 ] = -s * a13 + c * a23;
                return this;
            }
        }, {
            key: "translate",
            value: function translate( tx, ty ) {
                var te = this.elements;
                te[ 0 ] += tx * te[ 2 ];
                te[ 3 ] += tx * te[ 5 ];
                te[ 6 ] += tx * te[ 8 ];
                te[ 1 ] += ty * te[ 2 ];
                te[ 4 ] += ty * te[ 5 ];
                te[ 7 ] += ty * te[ 8 ];
                return this;
            }
        }, {
            key: "equals",
            value: function equals( matrix ) {
                var te = this.elements;
                var me = matrix.elements;
                for ( var _i3 = 0; _i3 < 9; _i3++ ) {
                    if ( te[ _i3 ] !== me[ _i3 ] ) return false;
                }
                return true;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                for ( var _i4 = 0; _i4 < 9; _i4++ ) {
                    this.elements[ _i4 ] = array[ _i4 + offset ];
                }
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                var te = this.elements;
                array[ offset ] = te[ 0 ];
                array[ offset + 1 ] = te[ 1 ];
                array[ offset + 2 ] = te[ 2 ];
                array[ offset + 3 ] = te[ 3 ];
                array[ offset + 4 ] = te[ 4 ];
                array[ offset + 5 ] = te[ 5 ];
                array[ offset + 6 ] = te[ 6 ];
                array[ offset + 7 ] = te[ 7 ];
                array[ offset + 8 ] = te[ 8 ];
                return array;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).fromArray( this.elements );
            }
        } ] );
        return Matrix3;
    }( );

    function arrayNeedsUint32( array ) { // assumes larger values usually on last
        for ( var _i5 = array.length - 1; _i5 >= 0; --_i5 ) {
            if ( array[ _i5 ] > 65535 ) return true;
        }
        return false;
    }

    function createElementNS( name ) {
        return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );
    }

    function SRGBToLinear( c ) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );
    }

    function LinearToSRGB( c ) {
        return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow( c, 0.41666 ) - 0.055;
    } // JavaScript RGB-to-RGB transforms, defined as
    // FN[InputColorSpace][OutputColorSpace] callback functions.
    var FN = ( _FN = {}, _defineProperty( _FN, SRGBColorSpace, _defineProperty( {}, LinearSRGBColorSpace, SRGBToLinear ) ), _defineProperty( _FN, LinearSRGBColorSpace, _defineProperty( {}, SRGBColorSpace, LinearToSRGB ) ), _FN );
    var ColorManagement = {
        legacyMode: true,
        get workingColorSpace( ) {
            return LinearSRGBColorSpace;
        },
        set workingColorSpace( colorSpace ) {
            console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );
        },
        convert: function convert( color, sourceColorSpace, targetColorSpace ) {
            if ( this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace ) {
                return color;
            }
            if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {
                var fn = FN[ sourceColorSpace ][ targetColorSpace ];
                color.r = fn( color.r );
                color.g = fn( color.g );
                color.b = fn( color.b );
                return color;
            }
            throw new Error( 'Unsupported color space conversion.' );
        },
        fromWorkingColorSpace: function fromWorkingColorSpace( color, targetColorSpace ) {
            return this.convert( color, this.workingColorSpace, targetColorSpace );
        },
        toWorkingColorSpace: function toWorkingColorSpace( color, sourceColorSpace ) {
            return this.convert( color, sourceColorSpace, this.workingColorSpace );
        }
    };
    var _colorKeywords = {
        'aliceblue': 0xF0F8FF,
        'antiquewhite': 0xFAEBD7,
        'aqua': 0x00FFFF,
        'aquamarine': 0x7FFFD4,
        'azure': 0xF0FFFF,
        'beige': 0xF5F5DC,
        'bisque': 0xFFE4C4,
        'black': 0x000000,
        'blanchedalmond': 0xFFEBCD,
        'blue': 0x0000FF,
        'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A,
        'burlywood': 0xDEB887,
        'cadetblue': 0x5F9EA0,
        'chartreuse': 0x7FFF00,
        'chocolate': 0xD2691E,
        'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED,
        'cornsilk': 0xFFF8DC,
        'crimson': 0xDC143C,
        'cyan': 0x00FFFF,
        'darkblue': 0x00008B,
        'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B,
        'darkgray': 0xA9A9A9,
        'darkgreen': 0x006400,
        'darkgrey': 0xA9A9A9,
        'darkkhaki': 0xBDB76B,
        'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F,
        'darkorange': 0xFF8C00,
        'darkorchid': 0x9932CC,
        'darkred': 0x8B0000,
        'darksalmon': 0xE9967A,
        'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B,
        'darkslategray': 0x2F4F4F,
        'darkslategrey': 0x2F4F4F,
        'darkturquoise': 0x00CED1,
        'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493,
        'deepskyblue': 0x00BFFF,
        'dimgray': 0x696969,
        'dimgrey': 0x696969,
        'dodgerblue': 0x1E90FF,
        'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0,
        'forestgreen': 0x228B22,
        'fuchsia': 0xFF00FF,
        'gainsboro': 0xDCDCDC,
        'ghostwhite': 0xF8F8FF,
        'gold': 0xFFD700,
        'goldenrod': 0xDAA520,
        'gray': 0x808080,
        'green': 0x008000,
        'greenyellow': 0xADFF2F,
        'grey': 0x808080,
        'honeydew': 0xF0FFF0,
        'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C,
        'indigo': 0x4B0082,
        'ivory': 0xFFFFF0,
        'khaki': 0xF0E68C,
        'lavender': 0xE6E6FA,
        'lavenderblush': 0xFFF0F5,
        'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD,
        'lightblue': 0xADD8E6,
        'lightcoral': 0xF08080,
        'lightcyan': 0xE0FFFF,
        'lightgoldenrodyellow': 0xFAFAD2,
        'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90,
        'lightgrey': 0xD3D3D3,
        'lightpink': 0xFFB6C1,
        'lightsalmon': 0xFFA07A,
        'lightseagreen': 0x20B2AA,
        'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899,
        'lightslategrey': 0x778899,
        'lightsteelblue': 0xB0C4DE,
        'lightyellow': 0xFFFFE0,
        'lime': 0x00FF00,
        'limegreen': 0x32CD32,
        'linen': 0xFAF0E6,
        'magenta': 0xFF00FF,
        'maroon': 0x800000,
        'mediumaquamarine': 0x66CDAA,
        'mediumblue': 0x0000CD,
        'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB,
        'mediumseagreen': 0x3CB371,
        'mediumslateblue': 0x7B68EE,
        'mediumspringgreen': 0x00FA9A,
        'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585,
        'midnightblue': 0x191970,
        'mintcream': 0xF5FFFA,
        'mistyrose': 0xFFE4E1,
        'moccasin': 0xFFE4B5,
        'navajowhite': 0xFFDEAD,
        'navy': 0x000080,
        'oldlace': 0xFDF5E6,
        'olive': 0x808000,
        'olivedrab': 0x6B8E23,
        'orange': 0xFFA500,
        'orangered': 0xFF4500,
        'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA,
        'palegreen': 0x98FB98,
        'paleturquoise': 0xAFEEEE,
        'palevioletred': 0xDB7093,
        'papayawhip': 0xFFEFD5,
        'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F,
        'pink': 0xFFC0CB,
        'plum': 0xDDA0DD,
        'powderblue': 0xB0E0E6,
        'purple': 0x800080,
        'rebeccapurple': 0x663399,
        'red': 0xFF0000,
        'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1,
        'saddlebrown': 0x8B4513,
        'salmon': 0xFA8072,
        'sandybrown': 0xF4A460,
        'seagreen': 0x2E8B57,
        'seashell': 0xFFF5EE,
        'sienna': 0xA0522D,
        'silver': 0xC0C0C0,
        'skyblue': 0x87CEEB,
        'slateblue': 0x6A5ACD,
        'slategray': 0x708090,
        'slategrey': 0x708090,
        'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F,
        'steelblue': 0x4682B4,
        'tan': 0xD2B48C,
        'teal': 0x008080,
        'thistle': 0xD8BFD8,
        'tomato': 0xFF6347,
        'turquoise': 0x40E0D0,
        'violet': 0xEE82EE,
        'wheat': 0xF5DEB3,
        'white': 0xFFFFFF,
        'whitesmoke': 0xF5F5F5,
        'yellow': 0xFFFF00,
        'yellowgreen': 0x9ACD32
    };
    var _rgb = {
        r: 0,
        g: 0,
        b: 0
    };
    var _hslA = {
        h: 0,
        s: 0,
        l: 0
    };
    var _hslB = {
        h: 0,
        s: 0,
        l: 0
    };

    function hue2rgb( p, q, t ) {
        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;
    }

    function toComponents( source, target ) {
        target.r = source.r;
        target.g = source.g;
        target.b = source.b;
        return target;
    }
    var Color = /*#__PURE__*/ function( _Symbol$iterator2 ) {
        function Color( r, g, b ) {
            _classCallCheck( this, Color );
            this.isColor = true;
            this.r = 1;
            this.g = 1;
            this.b = 1;
            if ( g === undefined && b === undefined ) { // r is THREE.Color, hex or string
                return this.set( r );
            }
            return this.setRGB( r, g, b );
        }
        _createClass( Color, [ {
            key: "set",
            value: function set( value ) {
                if ( value && value.isColor ) {
                    this.copy( value );
                } else if ( typeof value === 'number' ) {
                    this.setHex( value );
                } else if ( typeof value === 'string' ) {
                    this.setStyle( value );
                }
                return this;
            }
        }, {
            key: "setScalar",
            value: function setScalar( scalar ) {
                this.r = scalar;
                this.g = scalar;
                this.b = scalar;
                return this;
            }
        }, {
            key: "setHex",
            value: function setHex( hex ) {
                var colorSpace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : SRGBColorSpace;
                hex = Math.floor( hex );
                this.r = ( hex >> 16 & 255 ) / 255;
                this.g = ( hex >> 8 & 255 ) / 255;
                this.b = ( hex & 255 ) / 255;
                ColorManagement.toWorkingColorSpace( this, colorSpace );
                return this;
            }
        }, {
            key: "setRGB",
            value: function setRGB( r, g, b ) {
                var colorSpace = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : LinearSRGBColorSpace;
                this.r = r;
                this.g = g;
                this.b = b;
                ColorManagement.toWorkingColorSpace( this, colorSpace );
                return this;
            }
        }, {
            key: "setHSL",
            value: function setHSL( h, s, l ) {
                var colorSpace = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : LinearSRGBColorSpace; // h,s,l ranges are in 0.0 - 1.0
                h = euclideanModulo( h, 1 );
                s = clamp( s, 0, 1 );
                l = clamp( l, 0, 1 );
                if ( s === 0 ) {
                    this.r = this.g = this.b = l;
                } else {
                    var p = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s;
                    var q = 2 * l - p;
                    this.r = hue2rgb( q, p, h + 1 / 3 );
                    this.g = hue2rgb( q, p, h );
                    this.b = hue2rgb( q, p, h - 1 / 3 );
                }
                ColorManagement.toWorkingColorSpace( this, colorSpace );
                return this;
            }
        }, {
            key: "setStyle",
            value: function setStyle( style ) {
                var colorSpace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : SRGBColorSpace;

                function handleAlpha( string ) {
                    if ( string === undefined ) return;
                    if ( parseFloat( string ) < 1 ) {
                        console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
                    }
                }
                var m;
                if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) { // rgb / hsl
                    var color;
                    var name = m[ 1 ];
                    var components = m[ 2 ];
                    switch ( name ) {
                        case 'rgb':
                        case 'rgba':
                            if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) { // rgb(255,0,0) rgba(255,0,0,0.5)
                                this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                                this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                                this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
                                ColorManagement.toWorkingColorSpace( this, colorSpace );
                                handleAlpha( color[ 4 ] );
                                return this;
                            }
                            if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) { // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                                this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                                this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                                this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
                                ColorManagement.toWorkingColorSpace( this, colorSpace );
                                handleAlpha( color[ 4 ] );
                                return this;
                            }
                            break;
                        case 'hsl':
                        case 'hsla':
                            if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) { // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                                var h = parseFloat( color[ 1 ] ) / 360;
                                var s = parseInt( color[ 2 ], 10 ) / 100;
                                var l = parseInt( color[ 3 ], 10 ) / 100;
                                handleAlpha( color[ 4 ] );
                                return this.setHSL( h, s, l, colorSpace );
                            }
                            break;
                    }
                } else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) { // hex color
                    var hex = m[ 1 ];
                    var size = hex.length;
                    if ( size === 3 ) { // #ff0
                        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                        this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                        this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
                        ColorManagement.toWorkingColorSpace( this, colorSpace );
                        return this;
                    } else if ( size === 6 ) { // #ff0000
                        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                        this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                        this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
                        ColorManagement.toWorkingColorSpace( this, colorSpace );
                        return this;
                    }
                }
                if ( style && style.length > 0 ) {
                    return this.setColorName( style, colorSpace );
                }
                return this;
            }
        }, {
            key: "setColorName",
            value: function setColorName( style ) {
                var colorSpace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : SRGBColorSpace; // color keywords
                var hex = _colorKeywords[ style.toLowerCase( ) ];
                if ( hex !== undefined ) { // red
                    this.setHex( hex, colorSpace );
                } else { // unknown color
                    console.warn( 'THREE.Color: Unknown color ' + style );
                }
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this.r, this.g, this.b );
            }
        }, {
            key: "copy",
            value: function copy( color ) {
                this.r = color.r;
                this.g = color.g;
                this.b = color.b;
                return this;
            }
        }, {
            key: "copySRGBToLinear",
            value: function copySRGBToLinear( color ) {
                this.r = SRGBToLinear( color.r );
                this.g = SRGBToLinear( color.g );
                this.b = SRGBToLinear( color.b );
                return this;
            }
        }, {
            key: "copyLinearToSRGB",
            value: function copyLinearToSRGB( color ) {
                this.r = LinearToSRGB( color.r );
                this.g = LinearToSRGB( color.g );
                this.b = LinearToSRGB( color.b );
                return this;
            }
        }, {
            key: "convertSRGBToLinear",
            value: function convertSRGBToLinear( ) {
                this.copySRGBToLinear( this );
                return this;
            }
        }, {
            key: "convertLinearToSRGB",
            value: function convertLinearToSRGB( ) {
                this.copyLinearToSRGB( this );
                return this;
            }
        }, {
            key: "getHex",
            value: function getHex( ) {
                var colorSpace = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : SRGBColorSpace;
                ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );
                return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;
            }
        }, {
            key: "getHexString",
            value: function getHexString( ) {
                var colorSpace = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : SRGBColorSpace;
                return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );
            }
        }, {
            key: "getHSL",
            value: function getHSL( target ) {
                var colorSpace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : LinearSRGBColorSpace; // h,s,l ranges are in 0.0 - 1.0
                ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );
                var r = _rgb.r,
                    g = _rgb.g,
                    b = _rgb.b;
                var max = Math.max( r, g, b );
                var min = Math.min( r, g, b );
                var hue, saturation;
                var lightness = ( min + max ) / 2.0;
                if ( min === max ) {
                    hue = 0;
                    saturation = 0;
                } else {
                    var delta = max - min;
                    saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
                    switch ( max ) {
                        case r:
                            hue = ( g - b ) / delta + ( g < b ? 6 : 0 );
                            break;
                        case g:
                            hue = ( b - r ) / delta + 2;
                            break;
                        case b:
                            hue = ( r - g ) / delta + 4;
                            break;
                    }
                    hue /= 6;
                }
                target.h = hue;
                target.s = saturation;
                target.l = lightness;
                return target;
            }
        }, {
            key: "getRGB",
            value: function getRGB( target ) {
                var colorSpace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : LinearSRGBColorSpace;
                ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );
                target.r = _rgb.r;
                target.g = _rgb.g;
                target.b = _rgb.b;
                return target;
            }
        }, {
            key: "getStyle",
            value: function getStyle( ) {
                var colorSpace = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : SRGBColorSpace;
                ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );
                if ( colorSpace !== SRGBColorSpace ) { // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
                    return "color(".concat( colorSpace, " " ).concat( _rgb.r, " " ).concat( _rgb.g, " " ).concat( _rgb.b, ")" );
                }
                return "rgb(".concat( _rgb.r * 255 | 0, "," ).concat( _rgb.g * 255 | 0, "," ).concat( _rgb.b * 255 | 0, ")" );
            }
        }, {
            key: "offsetHSL",
            value: function offsetHSL( h, s, l ) {
                this.getHSL( _hslA );
                _hslA.h += h;
                _hslA.s += s;
                _hslA.l += l;
                this.setHSL( _hslA.h, _hslA.s, _hslA.l );
                return this;
            }
        }, {
            key: "add",
            value: function add( color ) {
                this.r += color.r;
                this.g += color.g;
                this.b += color.b;
                return this;
            }
        }, {
            key: "addColors",
            value: function addColors( color1, color2 ) {
                this.r = color1.r + color2.r;
                this.g = color1.g + color2.g;
                this.b = color1.b + color2.b;
                return this;
            }
        }, {
            key: "addScalar",
            value: function addScalar( s ) {
                this.r += s;
                this.g += s;
                this.b += s;
                return this;
            }
        }, {
            key: "sub",
            value: function sub( color ) {
                this.r = Math.max( 0, this.r - color.r );
                this.g = Math.max( 0, this.g - color.g );
                this.b = Math.max( 0, this.b - color.b );
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( color ) {
                this.r *= color.r;
                this.g *= color.g;
                this.b *= color.b;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( s ) {
                this.r *= s;
                this.g *= s;
                this.b *= s;
                return this;
            }
        }, {
            key: "lerp",
            value: function lerp( color, alpha ) {
                this.r += ( color.r - this.r ) * alpha;
                this.g += ( color.g - this.g ) * alpha;
                this.b += ( color.b - this.b ) * alpha;
                return this;
            }
        }, {
            key: "lerpColors",
            value: function lerpColors( color1, color2, alpha ) {
                this.r = color1.r + ( color2.r - color1.r ) * alpha;
                this.g = color1.g + ( color2.g - color1.g ) * alpha;
                this.b = color1.b + ( color2.b - color1.b ) * alpha;
                return this;
            }
        }, {
            key: "lerpHSL",
            value: function lerpHSL( color, alpha ) {
                this.getHSL( _hslA );
                color.getHSL( _hslB );
                var h = lerp( _hslA.h, _hslB.h, alpha );
                var s = lerp( _hslA.s, _hslB.s, alpha );
                var l = lerp( _hslA.l, _hslB.l, alpha );
                this.setHSL( h, s, l );
                return this;
            }
        }, {
            key: "equals",
            value: function equals( c ) {
                return c.r === this.r && c.g === this.g && c.b === this.b;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.r = array[ offset ];
                this.g = array[ offset + 1 ];
                this.b = array[ offset + 2 ];
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this.r;
                array[ offset + 1 ] = this.g;
                array[ offset + 2 ] = this.b;
                return array;
            }
        }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute( attribute, index ) {
                this.r = attribute.getX( index );
                this.g = attribute.getY( index );
                this.b = attribute.getZ( index );
                if ( attribute.normalized === true ) { // assuming Uint8Array
                    this.r /= 255;
                    this.g /= 255;
                    this.b /= 255;
                }
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                return this.getHex( );
            }
        }, {
            key: _Symbol$iterator2,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context3 ) {
                    while ( 1 ) {
                        switch ( _context3.prev = _context3.next ) {
                            case 0:
                                _context3.next = 2;
                                return this.r;
                            case 2:
                                _context3.next = 4;
                                return this.g;
                            case 4:
                                _context3.next = 6;
                                return this.b;
                            case 6:
                            case "end":
                                return _context3.stop( );
                        }
                    }
                }, value, this );
            } )
        } ] );
        return Color;
    }( Symbol.iterator );
    Color.NAMES = _colorKeywords;
    var _canvas;
    var ImageUtils = /*#__PURE__*/ function( ) {
        function ImageUtils( ) {
            _classCallCheck( this, ImageUtils );
        }
        _createClass( ImageUtils, null, [ {
            key: "getDataURL",
            value: function getDataURL( image ) {
                if ( /^data:/i.test( image.src ) ) {
                    return image.src;
                }
                if ( typeof HTMLCanvasElement == 'undefined' ) {
                    return image.src;
                }
                var canvas;
                if ( image instanceof HTMLCanvasElement ) {
                    canvas = image;
                } else {
                    if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );
                    _canvas.width = image.width;
                    _canvas.height = image.height;
                    var context = _canvas.getContext( '2d' );
                    if ( image instanceof ImageData ) {
                        context.putImageData( image, 0, 0 );
                    } else {
                        context.drawImage( image, 0, 0, image.width, image.height );
                    }
                    canvas = _canvas;
                }
                if ( canvas.width > 2048 || canvas.height > 2048 ) {
                    console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );
                    return canvas.toDataURL( 'image/jpeg', 0.6 );
                } else {
                    return canvas.toDataURL( 'image/png' );
                }
            }
        }, {
            key: "sRGBToLinear",
            value: function sRGBToLinear( image ) {
                if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) {
                    var canvas = createElementNS( 'canvas' );
                    canvas.width = image.width;
                    canvas.height = image.height;
                    var context = canvas.getContext( '2d' );
                    context.drawImage( image, 0, 0, image.width, image.height );
                    var imageData = context.getImageData( 0, 0, image.width, image.height );
                    var data = imageData.data;
                    for ( var _i6 = 0; _i6 < data.length; _i6++ ) {
                        data[ _i6 ] = SRGBToLinear( data[ _i6 ] / 255 ) * 255;
                    }
                    context.putImageData( imageData, 0, 0 );
                    return canvas;
                } else if ( image.data ) {
                    var _data = image.data.slice( 0 );
                    for ( var _i7 = 0; _i7 < _data.length; _i7++ ) {
                        if ( _data instanceof Uint8Array || _data instanceof Uint8ClampedArray ) {
                            _data[ _i7 ] = Math.floor( SRGBToLinear( _data[ _i7 ] / 255 ) * 255 );
                        } else { // assuming float
                            _data[ _i7 ] = SRGBToLinear( _data[ _i7 ] );
                        }
                    }
                    return {
                        data: _data,
                        width: image.width,
                        height: image.height
                    };
                } else {
                    console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
                    return image;
                }
            }
        } ] );
        return ImageUtils;
    }( );
    var Source = /*#__PURE__*/ function( ) {
        function Source( ) {
            var data = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : null;
            _classCallCheck( this, Source );
            this.isSource = true;
            this.uuid = generateUUID( );
            this.data = data;
            this.version = 0;
        }
        _createClass( Source, [ {
            key: "needsUpdate",
            set: function set( value ) {
                if ( value === true ) this.version++;
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var isRootObject = meta === undefined || typeof meta === 'string';
                if ( !isRootObject && meta.images[ this.uuid ] !== undefined ) {
                    return meta.images[ this.uuid ];
                }
                var output = {
                    uuid: this.uuid,
                    url: ''
                };
                var data = this.data;
                if ( data !== null ) {
                    var url;
                    if ( Array.isArray( data ) ) { // cube texture
                        url = [ ];
                        for ( var _i8 = 0, l = data.length; _i8 < l; _i8++ ) {
                            if ( data[ _i8 ].isDataTexture ) {
                                url.push( serializeImage( data[ _i8 ].image ) );
                            } else {
                                url.push( serializeImage( data[ _i8 ] ) );
                            }
                        }
                    } else { // texture
                        url = serializeImage( data );
                    }
                    output.url = url;
                }
                if ( !isRootObject ) {
                    meta.images[ this.uuid ] = output;
                }
                return output;
            }
        } ] );
        return Source;
    }( );

    function serializeImage( image ) {
        if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) { // default images
            return ImageUtils.getDataURL( image );
        } else {
            if ( image.data ) { // images of DataTexture
                return {
                    data: Array.from( image.data ),
                    width: image.width,
                    height: image.height,
                    type: image.data.constructor.name
                };
            } else {
                console.warn( 'THREE.Texture: Unable to serialize Texture.' );
                return {};
            }
        }
    }
    var textureId = 0;
    var Texture = /*#__PURE__*/ function( _EventDispatcher ) {
        _inherits( Texture, _EventDispatcher );
        var _super = _createSuper( Texture );

        function Texture( ) {
            var _this2;
            var image = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : Texture.DEFAULT_IMAGE;
            var mapping = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : Texture.DEFAULT_MAPPING;
            var wrapS = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : ClampToEdgeWrapping;
            var wrapT = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : ClampToEdgeWrapping;
            var magFilter = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : LinearFilter;
            var minFilter = arguments.length > 5 && arguments[ 5 ] !== undefined ? arguments[ 5 ] : LinearMipmapLinearFilter;
            var format = arguments.length > 6 && arguments[ 6 ] !== undefined ? arguments[ 6 ] : RGBAFormat;
            var type = arguments.length > 7 && arguments[ 7 ] !== undefined ? arguments[ 7 ] : UnsignedByteType;
            var anisotropy = arguments.length > 8 && arguments[ 8 ] !== undefined ? arguments[ 8 ] : 1;
            var encoding = arguments.length > 9 && arguments[ 9 ] !== undefined ? arguments[ 9 ] : LinearEncoding;
            _classCallCheck( this, Texture );
            _this2 = _super.call( this );
            _this2.isTexture = true;
            Object.defineProperty( _assertThisInitialized( _this2 ), 'id', {
                value: textureId++
            } );
            _this2.uuid = generateUUID( );
            _this2.name = '';
            _this2.source = new Source( image );
            _this2.mipmaps = [ ];
            _this2.mapping = mapping;
            _this2.wrapS = wrapS;
            _this2.wrapT = wrapT;
            _this2.magFilter = magFilter;
            _this2.minFilter = minFilter;
            _this2.anisotropy = anisotropy;
            _this2.format = format;
            _this2.internalFormat = null;
            _this2.type = type;
            _this2.offset = new Vector2( 0, 0 );
            _this2.repeat = new Vector2( 1, 1 );
            _this2.center = new Vector2( 0, 0 );
            _this2.rotation = 0;
            _this2.matrixAutoUpdate = true;
            _this2.matrix = new Matrix3( );
            _this2.generateMipmaps = true;
            _this2.premultiplyAlpha = false;
            _this2.flipY = true;
            _this2.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
            //
            // Also changing the encoding after already used by a Material will not automatically make the Material
            // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
            _this2.encoding = encoding;
            _this2.userData = {};
            _this2.version = 0;
            _this2.onUpdate = null;
            _this2.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
            _this2.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
            return _this2;
        }
        _createClass( Texture, [ {
            key: "image",
            get: function get( ) {
                return this.source.data;
            },
            set: function set( value ) {
                this.source.data = value;
            }
        }, {
            key: "updateMatrix",
            value: function updateMatrix( ) {
                this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.name = source.name;
                this.source = source.source;
                this.mipmaps = source.mipmaps.slice( 0 );
                this.mapping = source.mapping;
                this.wrapS = source.wrapS;
                this.wrapT = source.wrapT;
                this.magFilter = source.magFilter;
                this.minFilter = source.minFilter;
                this.anisotropy = source.anisotropy;
                this.format = source.format;
                this.internalFormat = source.internalFormat;
                this.type = source.type;
                this.offset.copy( source.offset );
                this.repeat.copy( source.repeat );
                this.center.copy( source.center );
                this.rotation = source.rotation;
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrix.copy( source.matrix );
                this.generateMipmaps = source.generateMipmaps;
                this.premultiplyAlpha = source.premultiplyAlpha;
                this.flipY = source.flipY;
                this.unpackAlignment = source.unpackAlignment;
                this.encoding = source.encoding;
                this.userData = JSON.parse( JSON.stringify( source.userData ) );
                this.needsUpdate = true;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var isRootObject = meta === undefined || typeof meta === 'string';
                if ( !isRootObject && meta.textures[ this.uuid ] !== undefined ) {
                    return meta.textures[ this.uuid ];
                }
                var output = {
                    metadata: {
                        version: 4.5,
                        type: 'Texture',
                        generator: 'Texture.toJSON'
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON( meta ).uuid,
                    mapping: this.mapping,
                    repeat: [ this.repeat.x, this.repeat.y ],
                    offset: [ this.offset.x, this.offset.y ],
                    center: [ this.center.x, this.center.y ],
                    rotation: this.rotation,
                    wrap: [ this.wrapS, this.wrapT ],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;
                if ( !isRootObject ) {
                    meta.textures[ this.uuid ] = output;
                }
                return output;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.dispatchEvent( {
                    type: 'dispose'
                } );
            }
        }, {
            key: "transformUv",
            value: function transformUv( uv ) {
                if ( this.mapping !== UVMapping ) return uv;
                uv.applyMatrix3( this.matrix );
                if ( uv.x < 0 || uv.x > 1 ) {
                    switch ( this.wrapS ) {
                        case RepeatWrapping:
                            uv.x = uv.x - Math.floor( uv.x );
                            break;
                        case ClampToEdgeWrapping:
                            uv.x = uv.x < 0 ? 0 : 1;
                            break;
                        case MirroredRepeatWrapping:
                            if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
                                uv.x = Math.ceil( uv.x ) - uv.x;
                            } else {
                                uv.x = uv.x - Math.floor( uv.x );
                            }
                            break;
                    }
                }
                if ( uv.y < 0 || uv.y > 1 ) {
                    switch ( this.wrapT ) {
                        case RepeatWrapping:
                            uv.y = uv.y - Math.floor( uv.y );
                            break;
                        case ClampToEdgeWrapping:
                            uv.y = uv.y < 0 ? 0 : 1;
                            break;
                        case MirroredRepeatWrapping:
                            if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
                                uv.y = Math.ceil( uv.y ) - uv.y;
                            } else {
                                uv.y = uv.y - Math.floor( uv.y );
                            }
                            break;
                    }
                }
                if ( this.flipY ) {
                    uv.y = 1 - uv.y;
                }
                return uv;
            }
        }, {
            key: "needsUpdate",
            set: function set( value ) {
                if ( value === true ) {
                    this.version++;
                    this.source.needsUpdate = true;
                }
            }
        } ] );
        return Texture;
    }( EventDispatcher );
    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    var Vector4 = /*#__PURE__*/ function( _Symbol$iterator3 ) {
        function Vector4( ) {
            var x = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0;
            var y = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var z = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var w = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, Vector4 );
            Vector4.prototype.isVector4 = true;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        _createClass( Vector4, [ {
            key: "width",
            get: function get( ) {
                return this.z;
            },
            set: function set( value ) {
                this.z = value;
            }
        }, {
            key: "height",
            get: function get( ) {
                return this.w;
            },
            set: function set( value ) {
                this.w = value;
            }
        }, {
            key: "set",
            value: function set( x, y, z, w ) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
            }
        }, {
            key: "setScalar",
            value: function setScalar( scalar ) {
                this.x = scalar;
                this.y = scalar;
                this.z = scalar;
                this.w = scalar;
                return this;
            }
        }, {
            key: "setX",
            value: function setX( x ) {
                this.x = x;
                return this;
            }
        }, {
            key: "setY",
            value: function setY( y ) {
                this.y = y;
                return this;
            }
        }, {
            key: "setZ",
            value: function setZ( z ) {
                this.z = z;
                return this;
            }
        }, {
            key: "setW",
            value: function setW( w ) {
                this.w = w;
                return this;
            }
        }, {
            key: "setComponent",
            value: function setComponent( index, value ) {
                switch ( index ) {
                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    case 2:
                        this.z = value;
                        break;
                    case 3:
                        this.w = value;
                        break;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
                return this;
            }
        }, {
            key: "getComponent",
            value: function getComponent( index ) {
                switch ( index ) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this.x, this.y, this.z, this.w );
            }
        }, {
            key: "copy",
            value: function copy( v ) {
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                this.w = v.w !== undefined ? v.w : 1;
                return this;
            }
        }, {
            key: "add",
            value: function add( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                    return this.addVectors( v, w );
                }
                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                this.w += v.w;
                return this;
            }
        }, {
            key: "addScalar",
            value: function addScalar( s ) {
                this.x += s;
                this.y += s;
                this.z += s;
                this.w += s;
                return this;
            }
        }, {
            key: "addVectors",
            value: function addVectors( a, b ) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                this.w = a.w + b.w;
                return this;
            }
        }, {
            key: "addScaledVector",
            value: function addScaledVector( v, s ) {
                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;
                this.w += v.w * s;
                return this;
            }
        }, {
            key: "sub",
            value: function sub( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                    return this.subVectors( v, w );
                }
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                this.w -= v.w;
                return this;
            }
        }, {
            key: "subScalar",
            value: function subScalar( s ) {
                this.x -= s;
                this.y -= s;
                this.z -= s;
                this.w -= s;
                return this;
            }
        }, {
            key: "subVectors",
            value: function subVectors( a, b ) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                this.w = a.w - b.w;
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( v ) {
                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z;
                this.w *= v.w;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( scalar ) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
                return this;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( m ) {
                var x = this.x,
                    y = this.y,
                    z = this.z,
                    w = this.w;
                var e = m.elements;
                this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
                this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
                this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
                this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
                return this;
            }
        }, {
            key: "divideScalar",
            value: function divideScalar( scalar ) {
                return this.multiplyScalar( 1 / scalar );
            }
        }, {
            key: "setAxisAngleFromQuaternion",
            value: function setAxisAngleFromQuaternion( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
                // q is assumed to be normalized
                this.w = 2 * Math.acos( q.w );
                var s = Math.sqrt( 1 - q.w * q.w );
                if ( s < 0.0001 ) {
                    this.x = 1;
                    this.y = 0;
                    this.z = 0;
                } else {
                    this.x = q.x / s;
                    this.y = q.y / s;
                    this.z = q.z / s;
                }
                return this;
            }
        }, {
            key: "setAxisAngleFromRotationMatrix",
            value: function setAxisAngleFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                var angle, x, y, z; // variables for result
                var epsilon = 0.01, // margin to allow for rounding errors
                    epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
                    te = m.elements,
                    m11 = te[ 0 ],
                    m12 = te[ 4 ],
                    m13 = te[ 8 ],
                    m21 = te[ 1 ],
                    m22 = te[ 5 ],
                    m23 = te[ 9 ],
                    m31 = te[ 2 ],
                    m32 = te[ 6 ],
                    m33 = te[ 10 ];
                if ( Math.abs( m12 - m21 ) < epsilon && Math.abs( m13 - m31 ) < epsilon && Math.abs( m23 - m32 ) < epsilon ) { // singularity found
                    // first check for identity matrix which must have +1 for all terms
                    // in leading diagonal and zero in other terms
                    if ( Math.abs( m12 + m21 ) < epsilon2 && Math.abs( m13 + m31 ) < epsilon2 && Math.abs( m23 + m32 ) < epsilon2 && Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) { // this singularity is identity matrix so angle = 0
                        this.set( 1, 0, 0, 0 );
                        return this; // zero angle, arbitrary axis
                    } // otherwise this singularity is angle = 180
                    angle = Math.PI;
                    var xx = ( m11 + 1 ) / 2;
                    var yy = ( m22 + 1 ) / 2;
                    var zz = ( m33 + 1 ) / 2;
                    var xy = ( m12 + m21 ) / 4;
                    var xz = ( m13 + m31 ) / 4;
                    var yz = ( m23 + m32 ) / 4;
                    if ( xx > yy && xx > zz ) { // m11 is the largest diagonal term
                        if ( xx < epsilon ) {
                            x = 0;
                            y = 0.707106781;
                            z = 0.707106781;
                        } else {
                            x = Math.sqrt( xx );
                            y = xy / x;
                            z = xz / x;
                        }
                    } else if ( yy > zz ) { // m22 is the largest diagonal term
                        if ( yy < epsilon ) {
                            x = 0.707106781;
                            y = 0;
                            z = 0.707106781;
                        } else {
                            y = Math.sqrt( yy );
                            x = xy / y;
                            z = yz / y;
                        }
                    } else { // m33 is the largest diagonal term so base result on this
                        if ( zz < epsilon ) {
                            x = 0.707106781;
                            y = 0.707106781;
                            z = 0;
                        } else {
                            z = Math.sqrt( zz );
                            x = xz / z;
                            y = yz / z;
                        }
                    }
                    this.set( x, y, z, angle );
                    return this; // return 180 deg rotation
                } // as we have reached here there are no singularities so we can handle normally
                var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
                if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
                // caught by singularity test above, but I've left it in just in case
                this.x = ( m32 - m23 ) / s;
                this.y = ( m13 - m31 ) / s;
                this.z = ( m21 - m12 ) / s;
                this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
                return this;
            }
        }, {
            key: "min",
            value: function min( v ) {
                this.x = Math.min( this.x, v.x );
                this.y = Math.min( this.y, v.y );
                this.z = Math.min( this.z, v.z );
                this.w = Math.min( this.w, v.w );
                return this;
            }
        }, {
            key: "max",
            value: function max( v ) {
                this.x = Math.max( this.x, v.x );
                this.y = Math.max( this.y, v.y );
                this.z = Math.max( this.z, v.z );
                this.w = Math.max( this.w, v.w );
                return this;
            }
        }, {
            key: "clamp",
            value: function clamp( min, max ) { // assumes min < max, componentwise
                this.x = Math.max( min.x, Math.min( max.x, this.x ) );
                this.y = Math.max( min.y, Math.min( max.y, this.y ) );
                this.z = Math.max( min.z, Math.min( max.z, this.z ) );
                this.w = Math.max( min.w, Math.min( max.w, this.w ) );
                return this;
            }
        }, {
            key: "clampScalar",
            value: function clampScalar( minVal, maxVal ) {
                this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
                this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
                this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
                this.w = Math.max( minVal, Math.min( maxVal, this.w ) );
                return this;
            }
        }, {
            key: "clampLength",
            value: function clampLength( min, max ) {
                var length = this.length( );
                return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
            }
        }, {
            key: "floor",
            value: function floor( ) {
                this.x = Math.floor( this.x );
                this.y = Math.floor( this.y );
                this.z = Math.floor( this.z );
                this.w = Math.floor( this.w );
                return this;
            }
        }, {
            key: "ceil",
            value: function ceil( ) {
                this.x = Math.ceil( this.x );
                this.y = Math.ceil( this.y );
                this.z = Math.ceil( this.z );
                this.w = Math.ceil( this.w );
                return this;
            }
        }, {
            key: "round",
            value: function round( ) {
                this.x = Math.round( this.x );
                this.y = Math.round( this.y );
                this.z = Math.round( this.z );
                this.w = Math.round( this.w );
                return this;
            }
        }, {
            key: "roundToZero",
            value: function roundToZero( ) {
                this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x );
                this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y );
                this.z = this.z < 0 ? Math.ceil( this.z ) : Math.floor( this.z );
                this.w = this.w < 0 ? Math.ceil( this.w ) : Math.floor( this.w );
                return this;
            }
        }, {
            key: "negate",
            value: function negate( ) {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this;
            }
        }, {
            key: "dot",
            value: function dot( v ) {
                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            }
        }, {
            key: "lengthSq",
            value: function lengthSq( ) {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "length",
            value: function length( ) {
                return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
            }
        }, {
            key: "manhattanLength",
            value: function manhattanLength( ) {
                return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
            }
        }, {
            key: "normalize",
            value: function normalize( ) {
                return this.divideScalar( this.length( ) || 1 );
            }
        }, {
            key: "setLength",
            value: function setLength( length ) {
                return this.normalize( ).multiplyScalar( length );
            }
        }, {
            key: "lerp",
            value: function lerp( v, alpha ) {
                this.x += ( v.x - this.x ) * alpha;
                this.y += ( v.y - this.y ) * alpha;
                this.z += ( v.z - this.z ) * alpha;
                this.w += ( v.w - this.w ) * alpha;
                return this;
            }
        }, {
            key: "lerpVectors",
            value: function lerpVectors( v1, v2, alpha ) {
                this.x = v1.x + ( v2.x - v1.x ) * alpha;
                this.y = v1.y + ( v2.y - v1.y ) * alpha;
                this.z = v1.z + ( v2.z - v1.z ) * alpha;
                this.w = v1.w + ( v2.w - v1.w ) * alpha;
                return this;
            }
        }, {
            key: "equals",
            value: function equals( v ) {
                return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.x = array[ offset ];
                this.y = array[ offset + 1 ];
                this.z = array[ offset + 2 ];
                this.w = array[ offset + 3 ];
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this.x;
                array[ offset + 1 ] = this.y;
                array[ offset + 2 ] = this.z;
                array[ offset + 3 ] = this.w;
                return array;
            }
        }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute( attribute, index, offset ) {
                if ( offset !== undefined ) {
                    console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
                }
                this.x = attribute.getX( index );
                this.y = attribute.getY( index );
                this.z = attribute.getZ( index );
                this.w = attribute.getW( index );
                return this;
            }
        }, {
            key: "random",
            value: function random( ) {
                this.x = Math.random( );
                this.y = Math.random( );
                this.z = Math.random( );
                this.w = Math.random( );
                return this;
            }
        }, {
            key: _Symbol$iterator3,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context4 ) {
                    while ( 1 ) {
                        switch ( _context4.prev = _context4.next ) {
                            case 0:
                                _context4.next = 2;
                                return this.x;
                            case 2:
                                _context4.next = 4;
                                return this.y;
                            case 4:
                                _context4.next = 6;
                                return this.z;
                            case 6:
                                _context4.next = 8;
                                return this.w;
                            case 8:
                            case "end":
                                return _context4.stop( );
                        }
                    }
                }, value, this );
            } )
        } ] );
        return Vector4;
    }( Symbol.iterator );
    /*
    	 In options, we can specify:
    	 * Texture parameters for an auto-generated target texture
    	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    	*/
    var WebGLRenderTarget = /*#__PURE__*/ function( _EventDispatcher2 ) {
        _inherits( WebGLRenderTarget, _EventDispatcher2 );
        var _super2 = _createSuper( WebGLRenderTarget );

        function WebGLRenderTarget( width, height ) {
            var _this3;
            var options = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : {};
            _classCallCheck( this, WebGLRenderTarget );
            _this3 = _super2.call( this );
            _this3.isWebGLRenderTarget = true;
            _this3.width = width;
            _this3.height = height;
            _this3.depth = 1;
            _this3.scissor = new Vector4( 0, 0, width, height );
            _this3.scissorTest = false;
            _this3.viewport = new Vector4( 0, 0, width, height );
            var image = {
                width: width,
                height: height,
                depth: 1
            };
            _this3.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
            _this3.texture.isRenderTargetTexture = true;
            _this3.texture.flipY = false;
            _this3.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
            _this3.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
            _this3.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
            _this3.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            _this3.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
            _this3.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
            _this3.samples = options.samples !== undefined ? options.samples : 0;
            return _this3;
        }
        _createClass( WebGLRenderTarget, [ {
            key: "setSize",
            value: function setSize( width, height ) {
                var depth = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
                if ( this.width !== width || this.height !== height || this.depth !== depth ) {
                    this.width = width;
                    this.height = height;
                    this.depth = depth;
                    this.texture.image.width = width;
                    this.texture.image.height = height;
                    this.texture.image.depth = depth;
                    this.dispose( );
                }
                this.viewport.set( 0, 0, width, height );
                this.scissor.set( 0, 0, width, height );
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.width = source.width;
                this.height = source.height;
                this.depth = source.depth;
                this.viewport.copy( source.viewport );
                this.texture = source.texture.clone( );
                this.texture.isRenderTargetTexture = true; // ensure image object is not shared, see #20328
                var image = Object.assign( {}, source.texture.image );
                this.texture.source = new Source( image );
                this.depthBuffer = source.depthBuffer;
                this.stencilBuffer = source.stencilBuffer;
                if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone( );
                this.samples = source.samples;
                return this;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.dispatchEvent( {
                    type: 'dispose'
                } );
            }
        } ] );
        return WebGLRenderTarget;
    }( EventDispatcher );
    var DataArrayTexture = /*#__PURE__*/ function( _Texture ) {
        _inherits( DataArrayTexture, _Texture );
        var _super3 = _createSuper( DataArrayTexture );

        function DataArrayTexture( ) {
            var _this4;
            var data = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : null;
            var width = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var height = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var depth = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, DataArrayTexture );
            _this4 = _super3.call( this, null );
            _this4.isDataArrayTexture = true;
            _this4.image = {
                data: data,
                width: width,
                height: height,
                depth: depth
            };
            _this4.magFilter = NearestFilter;
            _this4.minFilter = NearestFilter;
            _this4.wrapR = ClampToEdgeWrapping;
            _this4.generateMipmaps = false;
            _this4.flipY = false;
            _this4.unpackAlignment = 1;
            return _this4;
        }
        return _createClass( DataArrayTexture );
    }( Texture );
    var Data3DTexture = /*#__PURE__*/ function( _Texture2 ) {
        _inherits( Data3DTexture, _Texture2 );
        var _super4 = _createSuper( Data3DTexture );

        function Data3DTexture( ) {
            var _this5;
            var data = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : null;
            var width = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var height = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var depth = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, Data3DTexture ); // We're going to add .setXXX() methods for setting properties later.
            // Users can still set in DataTexture3D directly.
            //
            //	const texture = new THREE.DataTexture3D( data, width, height, depth );
            // 	texture.anisotropy = 16;
            //
            // See #14839
            _this5 = _super4.call( this, null );
            _this5.isData3DTexture = true;
            _this5.image = {
                data: data,
                width: width,
                height: height,
                depth: depth
            };
            _this5.magFilter = NearestFilter;
            _this5.minFilter = NearestFilter;
            _this5.wrapR = ClampToEdgeWrapping;
            _this5.generateMipmaps = false;
            _this5.flipY = false;
            _this5.unpackAlignment = 1;
            return _this5;
        }
        return _createClass( Data3DTexture );
    }( Texture );
    var Quaternion$1 = /*#__PURE__*/ function( _Symbol$iterator4 ) {
        function Quaternion$1( ) {
            var x = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0;
            var y = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var z = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var w = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, Quaternion$1 );
            this.isQuaternion = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
        }
        _createClass( Quaternion$1, [ {
            key: "x",
            get: function get( ) {
                return this._x;
            },
            set: function set( value ) {
                this._x = value;
                this._onChangeCallback( );
            }
        }, {
            key: "y",
            get: function get( ) {
                return this._y;
            },
            set: function set( value ) {
                this._y = value;
                this._onChangeCallback( );
            }
        }, {
            key: "z",
            get: function get( ) {
                return this._z;
            },
            set: function set( value ) {
                this._z = value;
                this._onChangeCallback( );
            }
        }, {
            key: "w",
            get: function get( ) {
                return this._w;
            },
            set: function set( value ) {
                this._w = value;
                this._onChangeCallback( );
            }
        }, {
            key: "set",
            value: function set( x, y, z, w ) {
                this._x = x;
                this._y = y;
                this._z = z;
                this._w = w;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this._x, this._y, this._z, this._w );
            }
        }, {
            key: "copy",
            value: function copy( quaternion ) {
                this._x = quaternion.x;
                this._y = quaternion.y;
                this._z = quaternion.z;
                this._w = quaternion.w;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromEuler",
            value: function setFromEuler( euler, update ) {
                if ( !( euler && euler.isEuler ) ) {
                    throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
                }
                var x = euler._x,
                    y = euler._y,
                    z = euler._z,
                    order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
                // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
                //	content/SpinCalc.m
                var cos = Math.cos;
                var sin = Math.sin;
                var c1 = cos( x / 2 );
                var c2 = cos( y / 2 );
                var c3 = cos( z / 2 );
                var s1 = sin( x / 2 );
                var s2 = sin( y / 2 );
                var s3 = sin( z / 2 );
                switch ( order ) {
                    case 'XYZ':
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                        break;
                    case 'YXZ':
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                        break;
                    case 'ZXY':
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                        break;
                    case 'ZYX':
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                        break;
                    case 'YZX':
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                        break;
                    case 'XZY':
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                        break;
                    default:
                        console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );
                }
                if ( update !== false ) this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromAxisAngle",
            value: function setFromAxisAngle( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
                // assumes axis is normalized
                var halfAngle = angle / 2,
                    s = Math.sin( halfAngle );
                this._x = axis.x * s;
                this._y = axis.y * s;
                this._z = axis.z * s;
                this._w = Math.cos( halfAngle );
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromRotationMatrix",
            value: function setFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                var te = m.elements,
                    m11 = te[ 0 ],
                    m12 = te[ 4 ],
                    m13 = te[ 8 ],
                    m21 = te[ 1 ],
                    m22 = te[ 5 ],
                    m23 = te[ 9 ],
                    m31 = te[ 2 ],
                    m32 = te[ 6 ],
                    m33 = te[ 10 ],
                    trace = m11 + m22 + m33;
                if ( trace > 0 ) {
                    var s = 0.5 / Math.sqrt( trace + 1.0 );
                    this._w = 0.25 / s;
                    this._x = ( m32 - m23 ) * s;
                    this._y = ( m13 - m31 ) * s;
                    this._z = ( m21 - m12 ) * s;
                } else if ( m11 > m22 && m11 > m33 ) {
                    var _s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
                    this._w = ( m32 - m23 ) / _s;
                    this._x = 0.25 * _s;
                    this._y = ( m12 + m21 ) / _s;
                    this._z = ( m13 + m31 ) / _s;
                } else if ( m22 > m33 ) {
                    var _s2 = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
                    this._w = ( m13 - m31 ) / _s2;
                    this._x = ( m12 + m21 ) / _s2;
                    this._y = 0.25 * _s2;
                    this._z = ( m23 + m32 ) / _s2;
                } else {
                    var _s3 = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
                    this._w = ( m21 - m12 ) / _s3;
                    this._x = ( m13 + m31 ) / _s3;
                    this._y = ( m23 + m32 ) / _s3;
                    this._z = 0.25 * _s3;
                }
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromUnitVectors",
            value: function setFromUnitVectors( vFrom, vTo ) { // assumes direction vectors vFrom and vTo are normalized
                var r = vFrom.dot( vTo ) + 1;
                if ( r < Number.EPSILON ) { // vFrom and vTo point in opposite directions
                    r = 0;
                    if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
                        this._x = -vFrom.y;
                        this._y = vFrom.x;
                        this._z = 0;
                        this._w = r;
                    } else {
                        this._x = 0;
                        this._y = -vFrom.z;
                        this._z = vFrom.y;
                        this._w = r;
                    }
                } else { // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                    this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                    this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                    this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                    this._w = r;
                }
                return this.normalize( );
            }
        }, {
            key: "angleTo",
            value: function angleTo( q ) {
                return 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );
            }
        }, {
            key: "rotateTowards",
            value: function rotateTowards( q, step ) {
                var angle = this.angleTo( q );
                if ( angle === 0 ) return this;
                var t = Math.min( 1, step / angle );
                this.slerp( q, t );
                return this;
            }
        }, {
            key: "identity",
            value: function identity( ) {
                return this.set( 0, 0, 0, 1 );
            }
        }, {
            key: "invert",
            value: function invert( ) { // quaternion is assumed to have unit length
                return this.conjugate( );
            }
        }, {
            key: "conjugate",
            value: function conjugate( ) {
                this._x *= -1;
                this._y *= -1;
                this._z *= -1;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "dot",
            value: function dot( v ) {
                return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
            }
        }, {
            key: "lengthSq",
            value: function lengthSq( ) {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            }
        }, {
            key: "length",
            value: function length( ) {
                return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
            }
        }, {
            key: "normalize",
            value: function normalize( ) {
                var l = this.length( );
                if ( l === 0 ) {
                    this._x = 0;
                    this._y = 0;
                    this._z = 0;
                    this._w = 1;
                } else {
                    l = 1 / l;
                    this._x = this._x * l;
                    this._y = this._y * l;
                    this._z = this._z * l;
                    this._w = this._w * l;
                }
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( q, p ) {
                if ( p !== undefined ) {
                    console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
                    return this.multiplyQuaternions( q, p );
                }
                return this.multiplyQuaternions( this, q );
            }
        }, {
            key: "premultiply",
            value: function premultiply( q ) {
                return this.multiplyQuaternions( q, this );
            }
        }, {
            key: "multiplyQuaternions",
            value: function multiplyQuaternions( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
                var qax = a._x,
                    qay = a._y,
                    qaz = a._z,
                    qaw = a._w;
                var qbx = b._x,
                    qby = b._y,
                    qbz = b._z,
                    qbw = b._w;
                this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "slerp",
            value: function slerp( qb, t ) {
                if ( t === 0 ) return this;
                if ( t === 1 ) return this.copy( qb );
                var x = this._x,
                    y = this._y,
                    z = this._z,
                    w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
                var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                if ( cosHalfTheta < 0 ) {
                    this._w = -qb._w;
                    this._x = -qb._x;
                    this._y = -qb._y;
                    this._z = -qb._z;
                    cosHalfTheta = -cosHalfTheta;
                } else {
                    this.copy( qb );
                }
                if ( cosHalfTheta >= 1.0 ) {
                    this._w = w;
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    return this;
                }
                var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
                if ( sqrSinHalfTheta <= Number.EPSILON ) {
                    var s = 1 - t;
                    this._w = s * w + t * this._w;
                    this._x = s * x + t * this._x;
                    this._y = s * y + t * this._y;
                    this._z = s * z + t * this._z;
                    this.normalize( );
                    this._onChangeCallback( );
                    return this;
                }
                var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
                var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
                var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
                    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
                this._w = w * ratioA + this._w * ratioB;
                this._x = x * ratioA + this._x * ratioB;
                this._y = y * ratioA + this._y * ratioB;
                this._z = z * ratioA + this._z * ratioB;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "slerpQuaternions",
            value: function slerpQuaternions( qa, qb, t ) {
                return this.copy( qa ).slerp( qb, t );
            }
        }, {
            key: "random",
            value: function random( ) { // Derived from http://planning.cs.uiuc.edu/node198.html
                // Note, this source uses w, x, y, z ordering,
                // so we swap the order below.
                var u1 = Math.random( );
                var sqrt1u1 = Math.sqrt( 1 - u1 );
                var sqrtu1 = Math.sqrt( u1 );
                var u2 = 2 * Math.PI * Math.random( );
                var u3 = 2 * Math.PI * Math.random( );
                return this.set( sqrt1u1 * Math.cos( u2 ), sqrtu1 * Math.sin( u3 ), sqrtu1 * Math.cos( u3 ), sqrt1u1 * Math.sin( u2 ) );
            }
        }, {
            key: "equals",
            value: function equals( quaternion ) {
                return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this._x = array[ offset ];
                this._y = array[ offset + 1 ];
                this._z = array[ offset + 2 ];
                this._w = array[ offset + 3 ];
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this._x;
                array[ offset + 1 ] = this._y;
                array[ offset + 2 ] = this._z;
                array[ offset + 3 ] = this._w;
                return array;
            }
        }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute( attribute, index ) {
                this._x = attribute.getX( index );
                this._y = attribute.getY( index );
                this._z = attribute.getZ( index );
                this._w = attribute.getW( index );
                return this;
            }
        }, {
            key: "_onChange",
            value: function _onChange( callback ) {
                this._onChangeCallback = callback;
                return this;
            }
        }, {
            key: "_onChangeCallback",
            value: function _onChangeCallback( ) {}
        }, {
            key: _Symbol$iterator4,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context5 ) {
                    while ( 1 ) {
                        switch ( _context5.prev = _context5.next ) {
                            case 0:
                                _context5.next = 2;
                                return this._x;
                            case 2:
                                _context5.next = 4;
                                return this._y;
                            case 4:
                                _context5.next = 6;
                                return this._z;
                            case 6:
                                _context5.next = 8;
                                return this._w;
                            case 8:
                            case "end":
                                return _context5.stop( );
                        }
                    }
                }, value, this );
            } )
        } ], [ {
            key: "slerp",
            value: function slerp( qa, qb, qm, t ) {
                console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
                return qm.slerpQuaternions( qa, qb, t );
            }
        }, {
            key: "slerpFlat",
            value: function slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation
                var x0 = src0[ srcOffset0 + 0 ],
                    y0 = src0[ srcOffset0 + 1 ],
                    z0 = src0[ srcOffset0 + 2 ],
                    w0 = src0[ srcOffset0 + 3 ];
                var x1 = src1[ srcOffset1 + 0 ],
                    y1 = src1[ srcOffset1 + 1 ],
                    z1 = src1[ srcOffset1 + 2 ],
                    w1 = src1[ srcOffset1 + 3 ];
                if ( t === 0 ) {
                    dst[ dstOffset + 0 ] = x0;
                    dst[ dstOffset + 1 ] = y0;
                    dst[ dstOffset + 2 ] = z0;
                    dst[ dstOffset + 3 ] = w0;
                    return;
                }
                if ( t === 1 ) {
                    dst[ dstOffset + 0 ] = x1;
                    dst[ dstOffset + 1 ] = y1;
                    dst[ dstOffset + 2 ] = z1;
                    dst[ dstOffset + 3 ] = w1;
                    return;
                }
                if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
                    var s = 1 - t;
                    var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                        dir = cos >= 0 ? 1 : -1,
                        sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:
                    if ( sqrSin > Number.EPSILON ) {
                        var sin = Math.sqrt( sqrSin ),
                            len = Math.atan2( sin, cos * dir );
                        s = Math.sin( s * len ) / sin;
                        t = Math.sin( t * len ) / sin;
                    }
                    var tDir = t * dir;
                    x0 = x0 * s + x1 * tDir;
                    y0 = y0 * s + y1 * tDir;
                    z0 = z0 * s + z1 * tDir;
                    w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:
                    if ( s === 1 - t ) {
                        var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
                        x0 *= f;
                        y0 *= f;
                        z0 *= f;
                        w0 *= f;
                    }
                }
                dst[ dstOffset ] = x0;
                dst[ dstOffset + 1 ] = y0;
                dst[ dstOffset + 2 ] = z0;
                dst[ dstOffset + 3 ] = w0;
            }
        }, {
            key: "multiplyQuaternionsFlat",
            value: function multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {
                var x0 = src0[ srcOffset0 ];
                var y0 = src0[ srcOffset0 + 1 ];
                var z0 = src0[ srcOffset0 + 2 ];
                var w0 = src0[ srcOffset0 + 3 ];
                var x1 = src1[ srcOffset1 ];
                var y1 = src1[ srcOffset1 + 1 ];
                var z1 = src1[ srcOffset1 + 2 ];
                var w1 = src1[ srcOffset1 + 3 ];
                dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
                dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
                dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
                dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
                return dst;
            }
        } ] );
        return Quaternion$1;
    }( Symbol.iterator );
    var Vector3 = /*#__PURE__*/ function( _Symbol$iterator5 ) {
        function Vector3( ) {
            var x = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0;
            var y = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var z = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            _classCallCheck( this, Vector3 );
            Vector3.prototype.isVector3 = true;
            this.x = x;
            this.y = y;
            this.z = z;
        }
        _createClass( Vector3, [ {
            key: "set",
            value: function set( x, y, z ) {
                if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
        }, {
            key: "setScalar",
            value: function setScalar( scalar ) {
                this.x = scalar;
                this.y = scalar;
                this.z = scalar;
                return this;
            }
        }, {
            key: "setX",
            value: function setX( x ) {
                this.x = x;
                return this;
            }
        }, {
            key: "setY",
            value: function setY( y ) {
                this.y = y;
                return this;
            }
        }, {
            key: "setZ",
            value: function setZ( z ) {
                this.z = z;
                return this;
            }
        }, {
            key: "setComponent",
            value: function setComponent( index, value ) {
                switch ( index ) {
                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    case 2:
                        this.z = value;
                        break;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
                return this;
            }
        }, {
            key: "getComponent",
            value: function getComponent( index ) {
                switch ( index ) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error( 'index is out of range: ' + index );
                }
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this.x, this.y, this.z );
            }
        }, {
            key: "copy",
            value: function copy( v ) {
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return this;
            }
        }, {
            key: "add",
            value: function add( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                    return this.addVectors( v, w );
                }
                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                return this;
            }
        }, {
            key: "addScalar",
            value: function addScalar( s ) {
                this.x += s;
                this.y += s;
                this.z += s;
                return this;
            }
        }, {
            key: "addVectors",
            value: function addVectors( a, b ) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                return this;
            }
        }, {
            key: "addScaledVector",
            value: function addScaledVector( v, s ) {
                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;
                return this;
            }
        }, {
            key: "sub",
            value: function sub( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                    return this.subVectors( v, w );
                }
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                return this;
            }
        }, {
            key: "subScalar",
            value: function subScalar( s ) {
                this.x -= s;
                this.y -= s;
                this.z -= s;
                return this;
            }
        }, {
            key: "subVectors",
            value: function subVectors( a, b ) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
                    return this.multiplyVectors( v, w );
                }
                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( scalar ) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                return this;
            }
        }, {
            key: "multiplyVectors",
            value: function multiplyVectors( a, b ) {
                this.x = a.x * b.x;
                this.y = a.y * b.y;
                this.z = a.z * b.z;
                return this;
            }
        }, {
            key: "applyEuler",
            value: function applyEuler( euler ) {
                if ( !( euler && euler.isEuler ) ) {
                    console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
                }
                return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );
            }
        }, {
            key: "applyAxisAngle",
            value: function applyAxisAngle( axis, angle ) {
                return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );
            }
        }, {
            key: "applyMatrix3",
            value: function applyMatrix3( m ) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
                this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
                this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
                return this;
            }
        }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix( m ) {
                return this.applyMatrix3( m ).normalize( );
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( m ) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
                this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
                this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
                this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
                return this;
            }
        }, {
            key: "applyQuaternion",
            value: function applyQuaternion( q ) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var qx = q.x,
                    qy = q.y,
                    qz = q.z,
                    qw = q.w; // calculate quat * vector
                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat
                this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return this;
            }
        }, {
            key: "project",
            value: function project( camera ) {
                return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
            }
        }, {
            key: "unproject",
            value: function unproject( camera ) {
                return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );
            }
        }, {
            key: "transformDirection",
            value: function transformDirection( m ) { // input: THREE.Matrix4 affine matrix
                // vector interpreted as a direction
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
                this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
                this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
                return this.normalize( );
            }
        }, {
            key: "divide",
            value: function divide( v ) {
                this.x /= v.x;
                this.y /= v.y;
                this.z /= v.z;
                return this;
            }
        }, {
            key: "divideScalar",
            value: function divideScalar( scalar ) {
                return this.multiplyScalar( 1 / scalar );
            }
        }, {
            key: "min",
            value: function min( v ) {
                this.x = Math.min( this.x, v.x );
                this.y = Math.min( this.y, v.y );
                this.z = Math.min( this.z, v.z );
                return this;
            }
        }, {
            key: "max",
            value: function max( v ) {
                this.x = Math.max( this.x, v.x );
                this.y = Math.max( this.y, v.y );
                this.z = Math.max( this.z, v.z );
                return this;
            }
        }, {
            key: "clamp",
            value: function clamp( min, max ) { // assumes min < max, componentwise
                this.x = Math.max( min.x, Math.min( max.x, this.x ) );
                this.y = Math.max( min.y, Math.min( max.y, this.y ) );
                this.z = Math.max( min.z, Math.min( max.z, this.z ) );
                return this;
            }
        }, {
            key: "clampScalar",
            value: function clampScalar( minVal, maxVal ) {
                this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
                this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
                this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
                return this;
            }
        }, {
            key: "clampLength",
            value: function clampLength( min, max ) {
                var length = this.length( );
                return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
            }
        }, {
            key: "floor",
            value: function floor( ) {
                this.x = Math.floor( this.x );
                this.y = Math.floor( this.y );
                this.z = Math.floor( this.z );
                return this;
            }
        }, {
            key: "ceil",
            value: function ceil( ) {
                this.x = Math.ceil( this.x );
                this.y = Math.ceil( this.y );
                this.z = Math.ceil( this.z );
                return this;
            }
        }, {
            key: "round",
            value: function round( ) {
                this.x = Math.round( this.x );
                this.y = Math.round( this.y );
                this.z = Math.round( this.z );
                return this;
            }
        }, {
            key: "roundToZero",
            value: function roundToZero( ) {
                this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x );
                this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y );
                this.z = this.z < 0 ? Math.ceil( this.z ) : Math.floor( this.z );
                return this;
            }
        }, {
            key: "negate",
            value: function negate( ) {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                return this;
            }
        }, {
            key: "dot",
            value: function dot( v ) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            } // TODO lengthSquared?
        }, {
            key: "lengthSq",
            value: function lengthSq( ) {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            }
        }, {
            key: "length",
            value: function length( ) {
                return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
            }
        }, {
            key: "manhattanLength",
            value: function manhattanLength( ) {
                return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
            }
        }, {
            key: "normalize",
            value: function normalize( ) {
                return this.divideScalar( this.length( ) || 1 );
            }
        }, {
            key: "setLength",
            value: function setLength( length ) {
                return this.normalize( ).multiplyScalar( length );
            }
        }, {
            key: "lerp",
            value: function lerp( v, alpha ) {
                this.x += ( v.x - this.x ) * alpha;
                this.y += ( v.y - this.y ) * alpha;
                this.z += ( v.z - this.z ) * alpha;
                return this;
            }
        }, {
            key: "lerpVectors",
            value: function lerpVectors( v1, v2, alpha ) {
                this.x = v1.x + ( v2.x - v1.x ) * alpha;
                this.y = v1.y + ( v2.y - v1.y ) * alpha;
                this.z = v1.z + ( v2.z - v1.z ) * alpha;
                return this;
            }
        }, {
            key: "cross",
            value: function cross( v, w ) {
                if ( w !== undefined ) {
                    console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
                    return this.crossVectors( v, w );
                }
                return this.crossVectors( this, v );
            }
        }, {
            key: "crossVectors",
            value: function crossVectors( a, b ) {
                var ax = a.x,
                    ay = a.y,
                    az = a.z;
                var bx = b.x,
                    by = b.y,
                    bz = b.z;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
            }
        }, {
            key: "projectOnVector",
            value: function projectOnVector( v ) {
                var denominator = v.lengthSq( );
                if ( denominator === 0 ) return this.set( 0, 0, 0 );
                var scalar = v.dot( this ) / denominator;
                return this.copy( v ).multiplyScalar( scalar );
            }
        }, {
            key: "projectOnPlane",
            value: function projectOnPlane( planeNormal ) {
                _vector$c.copy( this ).projectOnVector( planeNormal );
                return this.sub( _vector$c );
            }
        }, {
            key: "reflect",
            value: function reflect( normal ) { // reflect incident vector off plane orthogonal to normal
                // normal is assumed to have unit length
                return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
            }
        }, {
            key: "angleTo",
            value: function angleTo( v ) {
                var denominator = Math.sqrt( this.lengthSq( ) * v.lengthSq( ) );
                if ( denominator === 0 ) return Math.PI / 2;
                var theta = this.dot( v ) / denominator; // clamp, to handle numerical problems
                return Math.acos( clamp( theta, -1, 1 ) );
            }
        }, {
            key: "distanceTo",
            value: function distanceTo( v ) {
                return Math.sqrt( this.distanceToSquared( v ) );
            }
        }, {
            key: "distanceToSquared",
            value: function distanceToSquared( v ) {
                var dx = this.x - v.x,
                    dy = this.y - v.y,
                    dz = this.z - v.z;
                return dx * dx + dy * dy + dz * dz;
            }
        }, {
            key: "manhattanDistanceTo",
            value: function manhattanDistanceTo( v ) {
                return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
            }
        }, {
            key: "setFromSpherical",
            value: function setFromSpherical( s ) {
                return this.setFromSphericalCoords( s.radius, s.phi, s.theta );
            }
        }, {
            key: "setFromSphericalCoords",
            value: function setFromSphericalCoords( radius, phi, theta ) {
                var sinPhiRadius = Math.sin( phi ) * radius;
                this.x = sinPhiRadius * Math.sin( theta );
                this.y = Math.cos( phi ) * radius;
                this.z = sinPhiRadius * Math.cos( theta );
                return this;
            }
        }, {
            key: "setFromCylindrical",
            value: function setFromCylindrical( c ) {
                return this.setFromCylindricalCoords( c.radius, c.theta, c.y );
            }
        }, {
            key: "setFromCylindricalCoords",
            value: function setFromCylindricalCoords( radius, theta, y ) {
                this.x = radius * Math.sin( theta );
                this.y = y;
                this.z = radius * Math.cos( theta );
                return this;
            }
        }, {
            key: "setFromMatrixPosition",
            value: function setFromMatrixPosition( m ) {
                var e = m.elements;
                this.x = e[ 12 ];
                this.y = e[ 13 ];
                this.z = e[ 14 ];
                return this;
            }
        }, {
            key: "setFromMatrixScale",
            value: function setFromMatrixScale( m ) {
                var sx = this.setFromMatrixColumn( m, 0 ).length( );
                var sy = this.setFromMatrixColumn( m, 1 ).length( );
                var sz = this.setFromMatrixColumn( m, 2 ).length( );
                this.x = sx;
                this.y = sy;
                this.z = sz;
                return this;
            }
        }, {
            key: "setFromMatrixColumn",
            value: function setFromMatrixColumn( m, index ) {
                return this.fromArray( m.elements, index * 4 );
            }
        }, {
            key: "setFromMatrix3Column",
            value: function setFromMatrix3Column( m, index ) {
                return this.fromArray( m.elements, index * 3 );
            }
        }, {
            key: "setFromEuler",
            value: function setFromEuler( e ) {
                this.x = e._x;
                this.y = e._y;
                this.z = e._z;
                return this;
            }
        }, {
            key: "equals",
            value: function equals( v ) {
                return v.x === this.x && v.y === this.y && v.z === this.z;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.x = array[ offset ];
                this.y = array[ offset + 1 ];
                this.z = array[ offset + 2 ];
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this.x;
                array[ offset + 1 ] = this.y;
                array[ offset + 2 ] = this.z;
                return array;
            }
        }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute( attribute, index, offset ) {
                if ( offset !== undefined ) {
                    console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
                }
                this.x = attribute.getX( index );
                this.y = attribute.getY( index );
                this.z = attribute.getZ( index );
                return this;
            }
        }, {
            key: "random",
            value: function random( ) {
                this.x = Math.random( );
                this.y = Math.random( );
                this.z = Math.random( );
                return this;
            }
        }, {
            key: "randomDirection",
            value: function randomDirection( ) { // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
                var u = ( Math.random( ) - 0.5 ) * 2;
                var t = Math.random( ) * Math.PI * 2;
                var f = Math.sqrt( 1 - Math.pow( u, 2 ) );
                this.x = f * Math.cos( t );
                this.y = f * Math.sin( t );
                this.z = u;
                return this;
            }
        }, {
            key: _Symbol$iterator5,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context6 ) {
                    while ( 1 ) {
                        switch ( _context6.prev = _context6.next ) {
                            case 0:
                                _context6.next = 2;
                                return this.x;
                            case 2:
                                _context6.next = 4;
                                return this.y;
                            case 4:
                                _context6.next = 6;
                                return this.z;
                            case 6:
                            case "end":
                                return _context6.stop( );
                        }
                    }
                }, value, this );
            } )
        } ] );
        return Vector3;
    }( Symbol.iterator );
    var _vector$c = /*@__PURE__*/ new Vector3( );
    var _quaternion$4 = /*@__PURE__*/ new Quaternion$1( );
    var Box3 = /*#__PURE__*/ function( ) {
        function Box3( ) {
            var min = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Vector3( +Infinity, +Infinity, +Infinity );
            var max = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new Vector3( -Infinity, -Infinity, -Infinity );
            _classCallCheck( this, Box3 );
            this.isBox3 = true;
            this.min = min;
            this.max = max;
        }
        _createClass( Box3, [ {
            key: "set",
            value: function set( min, max ) {
                this.min.copy( min );
                this.max.copy( max );
                return this;
            }
        }, {
            key: "setFromArray",
            value: function setFromArray( array ) {
                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;
                for ( var _i9 = 0, l = array.length; _i9 < l; _i9 += 3 ) {
                    var _x2 = array[ _i9 ];
                    var y = array[ _i9 + 1 ];
                    var z = array[ _i9 + 2 ];
                    if ( _x2 < minX ) minX = _x2;
                    if ( y < minY ) minY = y;
                    if ( z < minZ ) minZ = z;
                    if ( _x2 > maxX ) maxX = _x2;
                    if ( y > maxY ) maxY = y;
                    if ( z > maxZ ) maxZ = z;
                }
                this.min.set( minX, minY, minZ );
                this.max.set( maxX, maxY, maxZ );
                return this;
            }
        }, {
            key: "setFromBufferAttribute",
            value: function setFromBufferAttribute( attribute ) {
                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;
                for ( var _i10 = 0, l = attribute.count; _i10 < l; _i10++ ) {
                    var _x3 = attribute.getX( _i10 );
                    var y = attribute.getY( _i10 );
                    var z = attribute.getZ( _i10 );
                    if ( _x3 < minX ) minX = _x3;
                    if ( y < minY ) minY = y;
                    if ( z < minZ ) minZ = z;
                    if ( _x3 > maxX ) maxX = _x3;
                    if ( y > maxY ) maxY = y;
                    if ( z > maxZ ) maxZ = z;
                }
                this.min.set( minX, minY, minZ );
                this.max.set( maxX, maxY, maxZ );
                return this;
            }
        }, {
            key: "setFromPoints",
            value: function setFromPoints( points ) {
                this.makeEmpty( );
                for ( var _i11 = 0, il = points.length; _i11 < il; _i11++ ) {
                    this.expandByPoint( points[ _i11 ] );
                }
                return this;
            }
        }, {
            key: "setFromCenterAndSize",
            value: function setFromCenterAndSize( center, size ) {
                var halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );
                this.min.copy( center ).sub( halfSize );
                this.max.copy( center ).add( halfSize );
                return this;
            }
        }, {
            key: "setFromObject",
            value: function setFromObject( object ) {
                var precise = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : false;
                this.makeEmpty( );
                return this.expandByObject( object, precise );
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( box ) {
                this.min.copy( box.min );
                this.max.copy( box.max );
                return this;
            }
        }, {
            key: "makeEmpty",
            value: function makeEmpty( ) {
                this.min.x = this.min.y = this.min.z = +Infinity;
                this.max.x = this.max.y = this.max.z = -Infinity;
                return this;
            }
        }, {
            key: "isEmpty",
            value: function isEmpty( ) { // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            }
        }, {
            key: "getCenter",
            value: function getCenter( target ) {
                return this.isEmpty( ) ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
            }
        }, {
            key: "getSize",
            value: function getSize( target ) {
                return this.isEmpty( ) ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );
            }
        }, {
            key: "expandByPoint",
            value: function expandByPoint( point ) {
                this.min.min( point );
                this.max.max( point );
                return this;
            }
        }, {
            key: "expandByVector",
            value: function expandByVector( vector ) {
                this.min.sub( vector );
                this.max.add( vector );
                return this;
            }
        }, {
            key: "expandByScalar",
            value: function expandByScalar( scalar ) {
                this.min.addScalar( -scalar );
                this.max.addScalar( scalar );
                return this;
            }
        }, {
            key: "expandByObject",
            value: function expandByObject( object ) {
                var precise = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : false; // Computes the world-axis-aligned bounding box of an object (including its children),
                // accounting for both the object's, and children's, world transforms
                object.updateWorldMatrix( false, false );
                var geometry = object.geometry;
                if ( geometry !== undefined ) {
                    if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {
                        var position = geometry.attributes.position;
                        for ( var _i12 = 0, l = position.count; _i12 < l; _i12++ ) {
                            _vector$b.fromBufferAttribute( position, _i12 ).applyMatrix4( object.matrixWorld );
                            this.expandByPoint( _vector$b );
                        }
                    } else {
                        if ( geometry.boundingBox === null ) {
                            geometry.computeBoundingBox( );
                        }
                        _box$3.copy( geometry.boundingBox );
                        _box$3.applyMatrix4( object.matrixWorld );
                        this.union( _box$3 );
                    }
                }
                var children = object.children;
                for ( var _i13 = 0, _l = children.length; _i13 < _l; _i13++ ) {
                    this.expandByObject( children[ _i13 ], precise );
                }
                return this;
            }
        }, {
            key: "containsPoint",
            value: function containsPoint( point ) {
                return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
            }
        }, {
            key: "containsBox",
            value: function containsBox( box ) {
                return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
            }
        }, {
            key: "getParameter",
            value: function getParameter( point, target ) { // This can potentially have a divide by zero if the box
                // has a size dimension of 0.
                return target.set( ( point.x - this.min.x ) / ( this.max.x - this.min.x ), ( point.y - this.min.y ) / ( this.max.y - this.min.y ), ( point.z - this.min.z ) / ( this.max.z - this.min.z ) );
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) { // using 6 splitting planes to rule out intersections.
                return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
            }
        }, {
            key: "intersectsSphere",
            value: function intersectsSphere( sphere ) { // Find the point on the AABB closest to the sphere center.
                this.clampPoint( sphere.center, _vector$b ); // If that point is inside the sphere, the AABB and sphere intersect.
                return _vector$b.distanceToSquared( sphere.center ) <= sphere.radius * sphere.radius;
            }
        }, {
            key: "intersectsPlane",
            value: function intersectsPlane( plane ) { // We compute the minimum and maximum dot product values. If those values
                // are on the same side (back or front) of the plane, then there is no intersection.
                var min, max;
                if ( plane.normal.x > 0 ) {
                    min = plane.normal.x * this.min.x;
                    max = plane.normal.x * this.max.x;
                } else {
                    min = plane.normal.x * this.max.x;
                    max = plane.normal.x * this.min.x;
                }
                if ( plane.normal.y > 0 ) {
                    min += plane.normal.y * this.min.y;
                    max += plane.normal.y * this.max.y;
                } else {
                    min += plane.normal.y * this.max.y;
                    max += plane.normal.y * this.min.y;
                }
                if ( plane.normal.z > 0 ) {
                    min += plane.normal.z * this.min.z;
                    max += plane.normal.z * this.max.z;
                } else {
                    min += plane.normal.z * this.max.z;
                    max += plane.normal.z * this.min.z;
                }
                return min <= -plane.constant && max >= -plane.constant;
            }
        }, {
            key: "intersectsTriangle",
            value: function intersectsTriangle( triangle ) {
                if ( this.isEmpty( ) ) {
                    return false;
                } // compute box center and extents
                this.getCenter( _center );
                _extents.subVectors( this.max, _center ); // translate triangle to aabb origin
                _v0$2.subVectors( triangle.a, _center );
                _v1$7.subVectors( triangle.b, _center );
                _v2$3.subVectors( triangle.c, _center ); // compute edge vectors for triangle
                _f0.subVectors( _v1$7, _v0$2 );
                _f1.subVectors( _v2$3, _v1$7 );
                _f2.subVectors( _v0$2, _v2$3 ); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
                // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
                // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
                var axes = [ 0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0 ];
                if ( !satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {
                    return false;
                } // test 3 face normals from the aabb
                axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
                if ( !satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {
                    return false;
                } // finally testing the face normal of the triangle
                // use already existing triangle edge vectors here
                _triangleNormal.crossVectors( _f0, _f1 );
                axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];
                return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );
            }
        }, {
            key: "clampPoint",
            value: function clampPoint( point, target ) {
                return target.copy( point ).clamp( this.min, this.max );
            }
        }, {
            key: "distanceToPoint",
            value: function distanceToPoint( point ) {
                var clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );
                return clampedPoint.sub( point ).length( );
            }
        }, {
            key: "getBoundingSphere",
            value: function getBoundingSphere( target ) {
                this.getCenter( target.center );
                target.radius = this.getSize( _vector$b ).length( ) * 0.5;
                return target;
            }
        }, {
            key: "intersect",
            value: function intersect( box ) {
                this.min.max( box.min );
                this.max.min( box.max ); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
                if ( this.isEmpty( ) ) this.makeEmpty( );
                return this;
            }
        }, {
            key: "union",
            value: function union( box ) {
                this.min.min( box.min );
                this.max.max( box.max );
                return this;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix ) { // transform of empty box is an empty box.
                if ( this.isEmpty( ) ) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                _points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
                _points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
                _points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
                _points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
                _points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
                _points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
                _points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
                _points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111
                this.setFromPoints( _points );
                return this;
            }
        }, {
            key: "translate",
            value: function translate( offset ) {
                this.min.add( offset );
                this.max.add( offset );
                return this;
            }
        }, {
            key: "equals",
            value: function equals( box ) {
                return box.min.equals( this.min ) && box.max.equals( this.max );
            }
        } ] );
        return Box3;
    }( );
    var _points = [ /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ), /*@__PURE__*/ new Vector3( ) ];
    var _vector$b = /*@__PURE__*/ new Vector3( );
    var _box$3 = /*@__PURE__*/ new Box3( ); // triangle centered vertices
    var _v0$2 = /*@__PURE__*/ new Vector3( );
    var _v1$7 = /*@__PURE__*/ new Vector3( );
    var _v2$3 = /*@__PURE__*/ new Vector3( ); // triangle edge vectors
    var _f0 = /*@__PURE__*/ new Vector3( );
    var _f1 = /*@__PURE__*/ new Vector3( );
    var _f2 = /*@__PURE__*/ new Vector3( );
    var _center = /*@__PURE__*/ new Vector3( );
    var _extents = /*@__PURE__*/ new Vector3( );
    var _triangleNormal = /*@__PURE__*/ new Vector3( );
    var _testAxis = /*@__PURE__*/ new Vector3( );

    function satForAxes( axes, v0, v1, v2, extents ) {
        for ( var _i14 = 0, j = axes.length - 3; _i14 <= j; _i14 += 3 ) {
            _testAxis.fromArray( axes, _i14 ); // project the aabb onto the separating axis
            var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z ); // project all 3 vertices of the triangle onto the separating axis
            var p0 = v0.dot( _testAxis );
            var p1 = v1.dot( _testAxis );
            var p2 = v2.dot( _testAxis ); // actual test, basically see if either of the most extreme of the triangle points intersects r
            if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) { // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is separating and we can exit
                return false;
            }
        }
        return true;
    }
    var _box$2 = /*@__PURE__*/ new Box3( );
    var _v1$6 = /*@__PURE__*/ new Vector3( );
    var _toFarthestPoint = /*@__PURE__*/ new Vector3( );
    var _toPoint = /*@__PURE__*/ new Vector3( );
    var Sphere = /*#__PURE__*/ function( ) {
        function Sphere( ) {
            var center = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Vector3( );
            var radius = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : -1;
            _classCallCheck( this, Sphere );
            this.center = center;
            this.radius = radius;
        }
        _createClass( Sphere, [ {
            key: "set",
            value: function set( center, radius ) {
                this.center.copy( center );
                this.radius = radius;
                return this;
            }
        }, {
            key: "setFromPoints",
            value: function setFromPoints( points, optionalCenter ) {
                var center = this.center;
                if ( optionalCenter !== undefined ) {
                    center.copy( optionalCenter );
                } else {
                    _box$2.setFromPoints( points ).getCenter( center );
                }
                var maxRadiusSq = 0;
                for ( var _i15 = 0, il = points.length; _i15 < il; _i15++ ) {
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ _i15 ] ) );
                }
                this.radius = Math.sqrt( maxRadiusSq );
                return this;
            }
        }, {
            key: "copy",
            value: function copy( sphere ) {
                this.center.copy( sphere.center );
                this.radius = sphere.radius;
                return this;
            }
        }, {
            key: "isEmpty",
            value: function isEmpty( ) {
                return this.radius < 0;
            }
        }, {
            key: "makeEmpty",
            value: function makeEmpty( ) {
                this.center.set( 0, 0, 0 );
                this.radius = -1;
                return this;
            }
        }, {
            key: "containsPoint",
            value: function containsPoint( point ) {
                return point.distanceToSquared( this.center ) <= this.radius * this.radius;
            }
        }, {
            key: "distanceToPoint",
            value: function distanceToPoint( point ) {
                return point.distanceTo( this.center ) - this.radius;
            }
        }, {
            key: "intersectsSphere",
            value: function intersectsSphere( sphere ) {
                var radiusSum = this.radius + sphere.radius;
                return sphere.center.distanceToSquared( this.center ) <= radiusSum * radiusSum;
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) {
                return box.intersectsSphere( this );
            }
        }, {
            key: "intersectsPlane",
            value: function intersectsPlane( plane ) {
                return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;
            }
        }, {
            key: "clampPoint",
            value: function clampPoint( point, target ) {
                var deltaLengthSq = this.center.distanceToSquared( point );
                target.copy( point );
                if ( deltaLengthSq > this.radius * this.radius ) {
                    target.sub( this.center ).normalize( );
                    target.multiplyScalar( this.radius ).add( this.center );
                }
                return target;
            }
        }, {
            key: "getBoundingBox",
            value: function getBoundingBox( target ) {
                if ( this.isEmpty( ) ) { // Empty sphere produces empty bounding box
                    target.makeEmpty( );
                    return target;
                }
                target.set( this.center, this.center );
                target.expandByScalar( this.radius );
                return target;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix ) {
                this.center.applyMatrix4( matrix );
                this.radius = this.radius * matrix.getMaxScaleOnAxis( );
                return this;
            }
        }, {
            key: "translate",
            value: function translate( offset ) {
                this.center.add( offset );
                return this;
            }
        }, {
            key: "expandByPoint",
            value: function expandByPoint( point ) { // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
                _toPoint.subVectors( point, this.center );
                var lengthSq = _toPoint.lengthSq( );
                if ( lengthSq > this.radius * this.radius ) {
                    var length = Math.sqrt( lengthSq );
                    var missingRadiusHalf = ( length - this.radius ) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
                    // and the other half to position. This gives a tighter enclosure, instead of if
                    // the whole missing distance were just added to radius.
                    this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
                    this.radius += missingRadiusHalf;
                }
                return this;
            }
        }, {
            key: "union",
            value: function union( sphere ) { // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
                // To enclose another sphere into this sphere, we only need to enclose two points:
                // 1) Enclose the farthest point on the other sphere into this sphere.
                // 2) Enclose the opposite point of the farthest point into this sphere.
                if ( this.center.equals( sphere.center ) === true ) {
                    _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );
                } else {
                    _toFarthestPoint.subVectors( sphere.center, this.center ).normalize( ).multiplyScalar( sphere.radius );
                }
                this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
                this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );
                return this;
            }
        }, {
            key: "equals",
            value: function equals( sphere ) {
                return sphere.center.equals( this.center ) && sphere.radius === this.radius;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        } ] );
        return Sphere;
    }( );
    var _vector$a = /*@__PURE__*/ new Vector3( );
    var _segCenter = /*@__PURE__*/ new Vector3( );
    var _segDir = /*@__PURE__*/ new Vector3( );
    var _diff = /*@__PURE__*/ new Vector3( );
    var _edge1 = /*@__PURE__*/ new Vector3( );
    var _edge2 = /*@__PURE__*/ new Vector3( );
    var _normal$1 = /*@__PURE__*/ new Vector3( );
    var Ray$1 = /*#__PURE__*/ function( ) {
        function Ray$1( ) {
            var origin = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Vector3( );
            var direction = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new Vector3( 0, 0, -1 );
            _classCallCheck( this, Ray$1 );
            this.origin = origin;
            this.direction = direction;
        }
        _createClass( Ray$1, [ {
            key: "set",
            value: function set( origin, direction ) {
                this.origin.copy( origin );
                this.direction.copy( direction );
                return this;
            }
        }, {
            key: "copy",
            value: function copy( ray ) {
                this.origin.copy( ray.origin );
                this.direction.copy( ray.direction );
                return this;
            }
        }, {
            key: "at",
            value: function at( t, target ) {
                return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );
            }
        }, {
            key: "lookAt",
            value: function lookAt( v ) {
                this.direction.copy( v ).sub( this.origin ).normalize( );
                return this;
            }
        }, {
            key: "recast",
            value: function recast( t ) {
                this.origin.copy( this.at( t, _vector$a ) );
                return this;
            }
        }, {
            key: "closestPointToPoint",
            value: function closestPointToPoint( point, target ) {
                target.subVectors( point, this.origin );
                var directionDistance = target.dot( this.direction );
                if ( directionDistance < 0 ) {
                    return target.copy( this.origin );
                }
                return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
            }
        }, {
            key: "distanceToPoint",
            value: function distanceToPoint( point ) {
                return Math.sqrt( this.distanceSqToPoint( point ) );
            }
        }, {
            key: "distanceSqToPoint",
            value: function distanceSqToPoint( point ) {
                var directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction ); // point behind the ray
                if ( directionDistance < 0 ) {
                    return this.origin.distanceToSquared( point );
                }
                _vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
                return _vector$a.distanceToSquared( point );
            }
        }, {
            key: "distanceSqToSegment",
            value: function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) { // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
                // It returns the min distance between the ray and the segment
                // defined by v0 and v1
                // It can also set two optional targets :
                // - The closest point on the ray
                // - The closest point on the segment
                _segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
                _segDir.copy( v1 ).sub( v0 ).normalize( );
                _diff.copy( this.origin ).sub( _segCenter );
                var segExtent = v0.distanceTo( v1 ) * 0.5;
                var a01 = -this.direction.dot( _segDir );
                var b0 = _diff.dot( this.direction );
                var b1 = -_diff.dot( _segDir );
                var c = _diff.lengthSq( );
                var det = Math.abs( 1 - a01 * a01 );
                var s0, s1, sqrDist, extDet;
                if ( det > 0 ) { // The ray and segment are not parallel.
                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;
                    if ( s0 >= 0 ) {
                        if ( s1 >= -extDet ) {
                            if ( s1 <= extDet ) { // region 0
                                // Minimum at interior points of ray and segment.
                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
                            } else { // region 1
                                s1 = segExtent;
                                s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                                sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
                            }
                        } else { // region 5
                            s1 = -segExtent;
                            s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
                        }
                    } else {
                        if ( s1 <= -extDet ) { // region 4
                            s0 = Math.max( 0, -( -a01 * segExtent + b0 ) );
                            s1 = s0 > 0 ? -segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
                        } else if ( s1 <= extDet ) { // region 3
                            s0 = 0;
                            s1 = Math.min( Math.max( -segExtent, -b1 ), segExtent );
                            sqrDist = s1 * ( s1 + 2 * b1 ) + c;
                        } else { // region 2
                            s0 = Math.max( 0, -( a01 * segExtent + b0 ) );
                            s1 = s0 > 0 ? segExtent : Math.min( Math.max( -segExtent, -b1 ), segExtent );
                            sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
                        }
                    }
                } else { // Ray and segment are parallel.
                    s1 = a01 > 0 ? -segExtent : segExtent;
                    s0 = Math.max( 0, -( a01 * s1 + b0 ) );
                    sqrDist = -s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
                }
                if ( optionalPointOnRay ) {
                    optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
                }
                if ( optionalPointOnSegment ) {
                    optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );
                }
                return sqrDist;
            }
        }, {
            key: "intersectSphere",
            value: function intersectSphere( sphere, target ) {
                _vector$a.subVectors( sphere.center, this.origin );
                var tca = _vector$a.dot( this.direction );
                var d2 = _vector$a.dot( _vector$a ) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if ( d2 > radius2 ) return null;
                var thc = Math.sqrt( radius2 - d2 ); // t0 = first intersect point - entrance on front of sphere
                var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere
                var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null
                if ( t0 < 0 && t1 < 0 ) return null; // test to see if t0 is behind the ray:
                // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                // in order to always return an intersect point that is in front of the ray.
                if ( t0 < 0 ) return this.at( t1, target ); // else t0 is in front of the ray, so return the first collision point scaled by t0
                return this.at( t0, target );
            }
        }, {
            key: "intersectsSphere",
            value: function intersectsSphere( sphere ) {
                return this.distanceSqToPoint( sphere.center ) <= sphere.radius * sphere.radius;
            }
        }, {
            key: "distanceToPlane",
            value: function distanceToPlane( plane ) {
                var denominator = plane.normal.dot( this.direction );
                if ( denominator === 0 ) { // line is coplanar, return origin
                    if ( plane.distanceToPoint( this.origin ) === 0 ) {
                        return 0;
                    } // Null is preferable to undefined since undefined means.... it is undefined
                    return null;
                }
                var t = -( this.origin.dot( plane.normal ) + plane.constant ) / denominator; // Return if the ray never intersects the plane
                return t >= 0 ? t : null;
            }
        }, {
            key: "intersectPlane",
            value: function intersectPlane( plane, target ) {
                var t = this.distanceToPlane( plane );
                if ( t === null ) {
                    return null;
                }
                return this.at( t, target );
            }
        }, {
            key: "intersectsPlane",
            value: function intersectsPlane( plane ) { // check if the ray lies on the plane first
                var distToPoint = plane.distanceToPoint( this.origin );
                if ( distToPoint === 0 ) {
                    return true;
                }
                var denominator = plane.normal.dot( this.direction );
                if ( denominator * distToPoint < 0 ) {
                    return true;
                } // ray origin is behind the plane (and is pointing behind it)
                return false;
            }
        }, {
            key: "intersectBox",
            value: function intersectBox( box, target ) {
                var tmin, tmax, tymin, tymax, tzmin, tzmax;
                var invdirx = 1 / this.direction.x,
                    invdiry = 1 / this.direction.y,
                    invdirz = 1 / this.direction.z;
                var origin = this.origin;
                if ( invdirx >= 0 ) {
                    tmin = ( box.min.x - origin.x ) * invdirx;
                    tmax = ( box.max.x - origin.x ) * invdirx;
                } else {
                    tmin = ( box.max.x - origin.x ) * invdirx;
                    tmax = ( box.min.x - origin.x ) * invdirx;
                }
                if ( invdiry >= 0 ) {
                    tymin = ( box.min.y - origin.y ) * invdiry;
                    tymax = ( box.max.y - origin.y ) * invdiry;
                } else {
                    tymin = ( box.max.y - origin.y ) * invdiry;
                    tymax = ( box.min.y - origin.y ) * invdiry;
                }
                if ( tmin > tymax || tymin > tmax ) return null; // These lines also handle the case where tmin or tmax is NaN
                // (result of 0 * Infinity). x !== x returns true if x is NaN
                if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
                if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
                if ( invdirz >= 0 ) {
                    tzmin = ( box.min.z - origin.z ) * invdirz;
                    tzmax = ( box.max.z - origin.z ) * invdirz;
                } else {
                    tzmin = ( box.max.z - origin.z ) * invdirz;
                    tzmax = ( box.min.z - origin.z ) * invdirz;
                }
                if ( tmin > tzmax || tzmin > tmax ) return null;
                if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
                if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax; //return point closest to the ray (positive side)
                if ( tmax < 0 ) return null;
                return this.at( tmin >= 0 ? tmin : tmax, target );
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) {
                return this.intersectBox( box, _vector$a ) !== null;
            }
        }, {
            key: "intersectTriangle",
            value: function intersectTriangle( a, b, c, backfaceCulling, target ) { // Compute the offset origin, edges, and normal.
                // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
                _edge1.subVectors( b, a );
                _edge2.subVectors( c, a );
                _normal$1.crossVectors( _edge1, _edge2 ); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                var DdN = this.direction.dot( _normal$1 );
                var sign;
                if ( DdN > 0 ) {
                    if ( backfaceCulling ) return null;
                    sign = 1;
                } else if ( DdN < 0 ) {
                    sign = -1;
                    DdN = -DdN;
                } else {
                    return null;
                }
                _diff.subVectors( this.origin, a );
                var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) ); // b1 < 0, no intersection
                if ( DdQxE2 < 0 ) {
                    return null;
                }
                var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) ); // b2 < 0, no intersection
                if ( DdE1xQ < 0 ) {
                    return null;
                } // b1+b2 > 1, no intersection
                if ( DdQxE2 + DdE1xQ > DdN ) {
                    return null;
                } // Line intersects triangle, check if ray does.
                var QdN = -sign * _diff.dot( _normal$1 ); // t < 0, no intersection
                if ( QdN < 0 ) {
                    return null;
                } // Ray intersects triangle.
                return this.at( QdN / DdN, target );
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix4 ) {
                this.origin.applyMatrix4( matrix4 );
                this.direction.transformDirection( matrix4 );
                return this;
            }
        }, {
            key: "equals",
            value: function equals( ray ) {
                return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        } ] );
        return Ray$1;
    }( );
    var Matrix4 = /*#__PURE__*/ function( ) {
        function Matrix4( ) {
            _classCallCheck( this, Matrix4 );
            Matrix4.prototype.isMatrix4 = true;
            this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];
            if ( arguments.length > 0 ) {
                console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
            }
        }
        _createClass( Matrix4, [ {
            key: "set",
            value: function set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
                var te = this.elements;
                te[ 0 ] = n11;
                te[ 4 ] = n12;
                te[ 8 ] = n13;
                te[ 12 ] = n14;
                te[ 1 ] = n21;
                te[ 5 ] = n22;
                te[ 9 ] = n23;
                te[ 13 ] = n24;
                te[ 2 ] = n31;
                te[ 6 ] = n32;
                te[ 10 ] = n33;
                te[ 14 ] = n34;
                te[ 3 ] = n41;
                te[ 7 ] = n42;
                te[ 11 ] = n43;
                te[ 15 ] = n44;
                return this;
            }
        }, {
            key: "identity",
            value: function identity( ) {
                this.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new Matrix4( ).fromArray( this.elements );
            }
        }, {
            key: "copy",
            value: function copy( m ) {
                var te = this.elements;
                var me = m.elements;
                te[ 0 ] = me[ 0 ];
                te[ 1 ] = me[ 1 ];
                te[ 2 ] = me[ 2 ];
                te[ 3 ] = me[ 3 ];
                te[ 4 ] = me[ 4 ];
                te[ 5 ] = me[ 5 ];
                te[ 6 ] = me[ 6 ];
                te[ 7 ] = me[ 7 ];
                te[ 8 ] = me[ 8 ];
                te[ 9 ] = me[ 9 ];
                te[ 10 ] = me[ 10 ];
                te[ 11 ] = me[ 11 ];
                te[ 12 ] = me[ 12 ];
                te[ 13 ] = me[ 13 ];
                te[ 14 ] = me[ 14 ];
                te[ 15 ] = me[ 15 ];
                return this;
            }
        }, {
            key: "copyPosition",
            value: function copyPosition( m ) {
                var te = this.elements,
                    me = m.elements;
                te[ 12 ] = me[ 12 ];
                te[ 13 ] = me[ 13 ];
                te[ 14 ] = me[ 14 ];
                return this;
            }
        }, {
            key: "setFromMatrix3",
            value: function setFromMatrix3( m ) {
                var me = m.elements;
                this.set( me[ 0 ], me[ 3 ], me[ 6 ], 0, me[ 1 ], me[ 4 ], me[ 7 ], 0, me[ 2 ], me[ 5 ], me[ 8 ], 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "extractBasis",
            value: function extractBasis( xAxis, yAxis, zAxis ) {
                xAxis.setFromMatrixColumn( this, 0 );
                yAxis.setFromMatrixColumn( this, 1 );
                zAxis.setFromMatrixColumn( this, 2 );
                return this;
            }
        }, {
            key: "makeBasis",
            value: function makeBasis( xAxis, yAxis, zAxis ) {
                this.set( xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "extractRotation",
            value: function extractRotation( m ) { // this method does not support reflection matrices
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length( );
                var scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length( );
                var scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length( );
                te[ 0 ] = me[ 0 ] * scaleX;
                te[ 1 ] = me[ 1 ] * scaleX;
                te[ 2 ] = me[ 2 ] * scaleX;
                te[ 3 ] = 0;
                te[ 4 ] = me[ 4 ] * scaleY;
                te[ 5 ] = me[ 5 ] * scaleY;
                te[ 6 ] = me[ 6 ] * scaleY;
                te[ 7 ] = 0;
                te[ 8 ] = me[ 8 ] * scaleZ;
                te[ 9 ] = me[ 9 ] * scaleZ;
                te[ 10 ] = me[ 10 ] * scaleZ;
                te[ 11 ] = 0;
                te[ 12 ] = 0;
                te[ 13 ] = 0;
                te[ 14 ] = 0;
                te[ 15 ] = 1;
                return this;
            }
        }, {
            key: "makeRotationFromEuler",
            value: function makeRotationFromEuler( euler ) {
                if ( !( euler && euler.isEuler ) ) {
                    console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
                }
                var te = this.elements;
                var x = euler.x,
                    y = euler.y,
                    z = euler.z;
                var a = Math.cos( x ),
                    b = Math.sin( x );
                var c = Math.cos( y ),
                    d = Math.sin( y );
                var e = Math.cos( z ),
                    f = Math.sin( z );
                if ( euler.order === 'XYZ' ) {
                    var ae = a * e,
                        af = a * f,
                        be = b * e,
                        bf = b * f;
                    te[ 0 ] = c * e;
                    te[ 4 ] = -c * f;
                    te[ 8 ] = d;
                    te[ 1 ] = af + be * d;
                    te[ 5 ] = ae - bf * d;
                    te[ 9 ] = -b * c;
                    te[ 2 ] = bf - ae * d;
                    te[ 6 ] = be + af * d;
                    te[ 10 ] = a * c;
                } else if ( euler.order === 'YXZ' ) {
                    var ce = c * e,
                        cf = c * f,
                        de = d * e,
                        df = d * f;
                    te[ 0 ] = ce + df * b;
                    te[ 4 ] = de * b - cf;
                    te[ 8 ] = a * d;
                    te[ 1 ] = a * f;
                    te[ 5 ] = a * e;
                    te[ 9 ] = -b;
                    te[ 2 ] = cf * b - de;
                    te[ 6 ] = df + ce * b;
                    te[ 10 ] = a * c;
                } else if ( euler.order === 'ZXY' ) {
                    var _ce = c * e,
                        _cf = c * f,
                        _de = d * e,
                        _df = d * f;
                    te[ 0 ] = _ce - _df * b;
                    te[ 4 ] = -a * f;
                    te[ 8 ] = _de + _cf * b;
                    te[ 1 ] = _cf + _de * b;
                    te[ 5 ] = a * e;
                    te[ 9 ] = _df - _ce * b;
                    te[ 2 ] = -a * d;
                    te[ 6 ] = b;
                    te[ 10 ] = a * c;
                } else if ( euler.order === 'ZYX' ) {
                    var _ae = a * e,
                        _af = a * f,
                        _be = b * e,
                        _bf = b * f;
                    te[ 0 ] = c * e;
                    te[ 4 ] = _be * d - _af;
                    te[ 8 ] = _ae * d + _bf;
                    te[ 1 ] = c * f;
                    te[ 5 ] = _bf * d + _ae;
                    te[ 9 ] = _af * d - _be;
                    te[ 2 ] = -d;
                    te[ 6 ] = b * c;
                    te[ 10 ] = a * c;
                } else if ( euler.order === 'YZX' ) {
                    var ac = a * c,
                        ad = a * d,
                        bc = b * c,
                        bd = b * d;
                    te[ 0 ] = c * e;
                    te[ 4 ] = bd - ac * f;
                    te[ 8 ] = bc * f + ad;
                    te[ 1 ] = f;
                    te[ 5 ] = a * e;
                    te[ 9 ] = -b * e;
                    te[ 2 ] = -d * e;
                    te[ 6 ] = ad * f + bc;
                    te[ 10 ] = ac - bd * f;
                } else if ( euler.order === 'XZY' ) {
                    var _ac = a * c,
                        _ad = a * d,
                        _bc = b * c,
                        _bd = b * d;
                    te[ 0 ] = c * e;
                    te[ 4 ] = -f;
                    te[ 8 ] = d * e;
                    te[ 1 ] = _ac * f + _bd;
                    te[ 5 ] = a * e;
                    te[ 9 ] = _ad * f - _bc;
                    te[ 2 ] = _bc * f - _ad;
                    te[ 6 ] = b * e;
                    te[ 10 ] = _bd * f + _ac;
                } // bottom row
                te[ 3 ] = 0;
                te[ 7 ] = 0;
                te[ 11 ] = 0; // last column
                te[ 12 ] = 0;
                te[ 13 ] = 0;
                te[ 14 ] = 0;
                te[ 15 ] = 1;
                return this;
            }
        }, {
            key: "makeRotationFromQuaternion",
            value: function makeRotationFromQuaternion( q ) {
                return this.compose( _zero, q, _one );
            }
        }, {
            key: "lookAt",
            value: function lookAt( eye, target, up ) {
                var te = this.elements;
                _z.subVectors( eye, target );
                if ( _z.lengthSq( ) === 0 ) { // eye and target are in the same position
                    _z.z = 1;
                }
                _z.normalize( );
                _x.crossVectors( up, _z );
                if ( _x.lengthSq( ) === 0 ) { // up and z are parallel
                    if ( Math.abs( up.z ) === 1 ) {
                        _z.x += 0.0001;
                    } else {
                        _z.z += 0.0001;
                    }
                    _z.normalize( );
                    _x.crossVectors( up, _z );
                }
                _x.normalize( );
                _y.crossVectors( _z, _x );
                te[ 0 ] = _x.x;
                te[ 4 ] = _y.x;
                te[ 8 ] = _z.x;
                te[ 1 ] = _x.y;
                te[ 5 ] = _y.y;
                te[ 9 ] = _z.y;
                te[ 2 ] = _x.z;
                te[ 6 ] = _y.z;
                te[ 10 ] = _z.z;
                return this;
            }
        }, {
            key: "multiply",
            value: function multiply( m, n ) {
                if ( n !== undefined ) {
                    console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
                    return this.multiplyMatrices( m, n );
                }
                return this.multiplyMatrices( this, m );
            }
        }, {
            key: "premultiply",
            value: function premultiply( m ) {
                return this.multiplyMatrices( m, this );
            }
        }, {
            key: "multiplyMatrices",
            value: function multiplyMatrices( a, b ) {
                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;
                var a11 = ae[ 0 ],
                    a12 = ae[ 4 ],
                    a13 = ae[ 8 ],
                    a14 = ae[ 12 ];
                var a21 = ae[ 1 ],
                    a22 = ae[ 5 ],
                    a23 = ae[ 9 ],
                    a24 = ae[ 13 ];
                var a31 = ae[ 2 ],
                    a32 = ae[ 6 ],
                    a33 = ae[ 10 ],
                    a34 = ae[ 14 ];
                var a41 = ae[ 3 ],
                    a42 = ae[ 7 ],
                    a43 = ae[ 11 ],
                    a44 = ae[ 15 ];
                var b11 = be[ 0 ],
                    b12 = be[ 4 ],
                    b13 = be[ 8 ],
                    b14 = be[ 12 ];
                var b21 = be[ 1 ],
                    b22 = be[ 5 ],
                    b23 = be[ 9 ],
                    b24 = be[ 13 ];
                var b31 = be[ 2 ],
                    b32 = be[ 6 ],
                    b33 = be[ 10 ],
                    b34 = be[ 14 ];
                var b41 = be[ 3 ],
                    b42 = be[ 7 ],
                    b43 = be[ 11 ],
                    b44 = be[ 15 ];
                te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                return this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar( s ) {
                var te = this.elements;
                te[ 0 ] *= s;
                te[ 4 ] *= s;
                te[ 8 ] *= s;
                te[ 12 ] *= s;
                te[ 1 ] *= s;
                te[ 5 ] *= s;
                te[ 9 ] *= s;
                te[ 13 ] *= s;
                te[ 2 ] *= s;
                te[ 6 ] *= s;
                te[ 10 ] *= s;
                te[ 14 ] *= s;
                te[ 3 ] *= s;
                te[ 7 ] *= s;
                te[ 11 ] *= s;
                te[ 15 ] *= s;
                return this;
            }
        }, {
            key: "determinant",
            value: function determinant( ) {
                var te = this.elements;
                var n11 = te[ 0 ],
                    n12 = te[ 4 ],
                    n13 = te[ 8 ],
                    n14 = te[ 12 ];
                var n21 = te[ 1 ],
                    n22 = te[ 5 ],
                    n23 = te[ 9 ],
                    n24 = te[ 13 ];
                var n31 = te[ 2 ],
                    n32 = te[ 6 ],
                    n33 = te[ 10 ],
                    n34 = te[ 14 ];
                var n41 = te[ 3 ],
                    n42 = te[ 7 ],
                    n43 = te[ 11 ],
                    n44 = te[ 15 ]; //TODO: make this more efficient
                //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
                return n41 * ( +n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) + n42 * ( +n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) + n43 * ( +n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) + n44 * ( -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 );
            }
        }, {
            key: "transpose",
            value: function transpose( ) {
                var te = this.elements;
                var tmp;
                tmp = te[ 1 ];
                te[ 1 ] = te[ 4 ];
                te[ 4 ] = tmp;
                tmp = te[ 2 ];
                te[ 2 ] = te[ 8 ];
                te[ 8 ] = tmp;
                tmp = te[ 6 ];
                te[ 6 ] = te[ 9 ];
                te[ 9 ] = tmp;
                tmp = te[ 3 ];
                te[ 3 ] = te[ 12 ];
                te[ 12 ] = tmp;
                tmp = te[ 7 ];
                te[ 7 ] = te[ 13 ];
                te[ 13 ] = tmp;
                tmp = te[ 11 ];
                te[ 11 ] = te[ 14 ];
                te[ 14 ] = tmp;
                return this;
            }
        }, {
            key: "setPosition",
            value: function setPosition( x, y, z ) {
                var te = this.elements;
                if ( x.isVector3 ) {
                    te[ 12 ] = x.x;
                    te[ 13 ] = x.y;
                    te[ 14 ] = x.z;
                } else {
                    te[ 12 ] = x;
                    te[ 13 ] = y;
                    te[ 14 ] = z;
                }
                return this;
            }
        }, {
            key: "invert",
            value: function invert( ) { // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
                var te = this.elements,
                    n11 = te[ 0 ],
                    n21 = te[ 1 ],
                    n31 = te[ 2 ],
                    n41 = te[ 3 ],
                    n12 = te[ 4 ],
                    n22 = te[ 5 ],
                    n32 = te[ 6 ],
                    n42 = te[ 7 ],
                    n13 = te[ 8 ],
                    n23 = te[ 9 ],
                    n33 = te[ 10 ],
                    n43 = te[ 11 ],
                    n14 = te[ 12 ],
                    n24 = te[ 13 ],
                    n34 = te[ 14 ],
                    n44 = te[ 15 ],
                    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
                var detInv = 1 / det;
                te[ 0 ] = t11 * detInv;
                te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
                te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
                te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
                te[ 4 ] = t12 * detInv;
                te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
                te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
                te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
                te[ 8 ] = t13 * detInv;
                te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
                te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
                te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
                te[ 12 ] = t14 * detInv;
                te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
                te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
                te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
                return this;
            }
        }, {
            key: "scale",
            value: function scale( v ) {
                var te = this.elements;
                var x = v.x,
                    y = v.y,
                    z = v.z;
                te[ 0 ] *= x;
                te[ 4 ] *= y;
                te[ 8 ] *= z;
                te[ 1 ] *= x;
                te[ 5 ] *= y;
                te[ 9 ] *= z;
                te[ 2 ] *= x;
                te[ 6 ] *= y;
                te[ 10 ] *= z;
                te[ 3 ] *= x;
                te[ 7 ] *= y;
                te[ 11 ] *= z;
                return this;
            }
        }, {
            key: "getMaxScaleOnAxis",
            value: function getMaxScaleOnAxis( ) {
                var te = this.elements;
                var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
                var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
                var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
                return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
            }
        }, {
            key: "makeTranslation",
            value: function makeTranslation( x, y, z ) {
                this.set( 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeRotationX",
            value: function makeRotationX( theta ) {
                var c = Math.cos( theta ),
                    s = Math.sin( theta );
                this.set( 1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeRotationY",
            value: function makeRotationY( theta ) {
                var c = Math.cos( theta ),
                    s = Math.sin( theta );
                this.set( c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeRotationZ",
            value: function makeRotationZ( theta ) {
                var c = Math.cos( theta ),
                    s = Math.sin( theta );
                this.set( c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeRotationAxis",
            value: function makeRotationAxis( axis, angle ) { // Based on http://www.gamedev.net/reference/articles/article1199.asp
                var c = Math.cos( angle );
                var s = Math.sin( angle );
                var t = 1 - c;
                var x = axis.x,
                    y = axis.y,
                    z = axis.z;
                var tx = t * x,
                    ty = t * y;
                this.set( tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeScale",
            value: function makeScale( x, y, z ) {
                this.set( x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "makeShear",
            value: function makeShear( xy, xz, yx, yz, zx, zy ) {
                this.set( 1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1 );
                return this;
            }
        }, {
            key: "compose",
            value: function compose( position, quaternion, scale ) {
                var te = this.elements;
                var x = quaternion._x,
                    y = quaternion._y,
                    z = quaternion._z,
                    w = quaternion._w;
                var x2 = x + x,
                    y2 = y + y,
                    z2 = z + z;
                var xx = x * x2,
                    xy = x * y2,
                    xz = x * z2;
                var yy = y * y2,
                    yz = y * z2,
                    zz = z * z2;
                var wx = w * x2,
                    wy = w * y2,
                    wz = w * z2;
                var sx = scale.x,
                    sy = scale.y,
                    sz = scale.z;
                te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
                te[ 1 ] = ( xy + wz ) * sx;
                te[ 2 ] = ( xz - wy ) * sx;
                te[ 3 ] = 0;
                te[ 4 ] = ( xy - wz ) * sy;
                te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
                te[ 6 ] = ( yz + wx ) * sy;
                te[ 7 ] = 0;
                te[ 8 ] = ( xz + wy ) * sz;
                te[ 9 ] = ( yz - wx ) * sz;
                te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
                te[ 11 ] = 0;
                te[ 12 ] = position.x;
                te[ 13 ] = position.y;
                te[ 14 ] = position.z;
                te[ 15 ] = 1;
                return this;
            }
        }, {
            key: "decompose",
            value: function decompose( position, quaternion, scale ) {
                var te = this.elements;
                var sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length( );
                var sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length( );
                var sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length( ); // if determine is negative, we need to invert one scale
                var det = this.determinant( );
                if ( det < 0 ) sx = -sx;
                position.x = te[ 12 ];
                position.y = te[ 13 ];
                position.z = te[ 14 ]; // scale the rotation part
                _m1$2.copy( this );
                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                _m1$2.elements[ 0 ] *= invSX;
                _m1$2.elements[ 1 ] *= invSX;
                _m1$2.elements[ 2 ] *= invSX;
                _m1$2.elements[ 4 ] *= invSY;
                _m1$2.elements[ 5 ] *= invSY;
                _m1$2.elements[ 6 ] *= invSY;
                _m1$2.elements[ 8 ] *= invSZ;
                _m1$2.elements[ 9 ] *= invSZ;
                _m1$2.elements[ 10 ] *= invSZ;
                quaternion.setFromRotationMatrix( _m1$2 );
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
            }
        }, {
            key: "makePerspective",
            value: function makePerspective( left, right, top, bottom, near, far ) {
                if ( far === undefined ) {
                    console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
                }
                var te = this.elements;
                var x = 2 * near / ( right - left );
                var y = 2 * near / ( top - bottom );
                var a = ( right + left ) / ( right - left );
                var b = ( top + bottom ) / ( top - bottom );
                var c = -( far + near ) / ( far - near );
                var d = -2 * far * near / ( far - near );
                te[ 0 ] = x;
                te[ 4 ] = 0;
                te[ 8 ] = a;
                te[ 12 ] = 0;
                te[ 1 ] = 0;
                te[ 5 ] = y;
                te[ 9 ] = b;
                te[ 13 ] = 0;
                te[ 2 ] = 0;
                te[ 6 ] = 0;
                te[ 10 ] = c;
                te[ 14 ] = d;
                te[ 3 ] = 0;
                te[ 7 ] = 0;
                te[ 11 ] = -1;
                te[ 15 ] = 0;
                return this;
            }
        }, {
            key: "makeOrthographic",
            value: function makeOrthographic( left, right, top, bottom, near, far ) {
                var te = this.elements;
                var w = 1.0 / ( right - left );
                var h = 1.0 / ( top - bottom );
                var p = 1.0 / ( far - near );
                var x = ( right + left ) * w;
                var y = ( top + bottom ) * h;
                var z = ( far + near ) * p;
                te[ 0 ] = 2 * w;
                te[ 4 ] = 0;
                te[ 8 ] = 0;
                te[ 12 ] = -x;
                te[ 1 ] = 0;
                te[ 5 ] = 2 * h;
                te[ 9 ] = 0;
                te[ 13 ] = -y;
                te[ 2 ] = 0;
                te[ 6 ] = 0;
                te[ 10 ] = -2 * p;
                te[ 14 ] = -z;
                te[ 3 ] = 0;
                te[ 7 ] = 0;
                te[ 11 ] = 0;
                te[ 15 ] = 1;
                return this;
            }
        }, {
            key: "equals",
            value: function equals( matrix ) {
                var te = this.elements;
                var me = matrix.elements;
                for ( var _i16 = 0; _i16 < 16; _i16++ ) {
                    if ( te[ _i16 ] !== me[ _i16 ] ) return false;
                }
                return true;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                for ( var _i17 = 0; _i17 < 16; _i17++ ) {
                    this.elements[ _i17 ] = array[ _i17 + offset ];
                }
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                var te = this.elements;
                array[ offset ] = te[ 0 ];
                array[ offset + 1 ] = te[ 1 ];
                array[ offset + 2 ] = te[ 2 ];
                array[ offset + 3 ] = te[ 3 ];
                array[ offset + 4 ] = te[ 4 ];
                array[ offset + 5 ] = te[ 5 ];
                array[ offset + 6 ] = te[ 6 ];
                array[ offset + 7 ] = te[ 7 ];
                array[ offset + 8 ] = te[ 8 ];
                array[ offset + 9 ] = te[ 9 ];
                array[ offset + 10 ] = te[ 10 ];
                array[ offset + 11 ] = te[ 11 ];
                array[ offset + 12 ] = te[ 12 ];
                array[ offset + 13 ] = te[ 13 ];
                array[ offset + 14 ] = te[ 14 ];
                array[ offset + 15 ] = te[ 15 ];
                return array;
            }
        } ] );
        return Matrix4;
    }( );
    var _v1$5 = /*@__PURE__*/ new Vector3( );
    var _m1$2 = /*@__PURE__*/ new Matrix4( );
    var _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
    var _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
    var _x = /*@__PURE__*/ new Vector3( );
    var _y = /*@__PURE__*/ new Vector3( );
    var _z = /*@__PURE__*/ new Vector3( );
    var _matrix$1 = /*@__PURE__*/ new Matrix4( );
    var _quaternion$3 = /*@__PURE__*/ new Quaternion$1( );
    var Euler = /*#__PURE__*/ function( _Symbol$iterator6 ) {
        function Euler( ) {
            var x = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0;
            var y = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var z = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var order = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : Euler.DefaultOrder;
            _classCallCheck( this, Euler );
            this.isEuler = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
        }
        _createClass( Euler, [ {
            key: "x",
            get: function get( ) {
                return this._x;
            },
            set: function set( value ) {
                this._x = value;
                this._onChangeCallback( );
            }
        }, {
            key: "y",
            get: function get( ) {
                return this._y;
            },
            set: function set( value ) {
                this._y = value;
                this._onChangeCallback( );
            }
        }, {
            key: "z",
            get: function get( ) {
                return this._z;
            },
            set: function set( value ) {
                this._z = value;
                this._onChangeCallback( );
            }
        }, {
            key: "order",
            get: function get( ) {
                return this._order;
            },
            set: function set( value ) {
                this._order = value;
                this._onChangeCallback( );
            }
        }, {
            key: "set",
            value: function set( x, y, z ) {
                var order = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : this._order;
                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this._x, this._y, this._z, this._order );
            }
        }, {
            key: "copy",
            value: function copy( euler ) {
                this._x = euler._x;
                this._y = euler._y;
                this._z = euler._z;
                this._order = euler._order;
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromRotationMatrix",
            value: function setFromRotationMatrix( m ) {
                var order = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : this._order;
                var update = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : true; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                var te = m.elements;
                var m11 = te[ 0 ],
                    m12 = te[ 4 ],
                    m13 = te[ 8 ];
                var m21 = te[ 1 ],
                    m22 = te[ 5 ],
                    m23 = te[ 9 ];
                var m31 = te[ 2 ],
                    m32 = te[ 6 ],
                    m33 = te[ 10 ];
                switch ( order ) {
                    case 'XYZ':
                        this._y = Math.asin( clamp( m13, -1, 1 ) );
                        if ( Math.abs( m13 ) < 0.9999999 ) {
                            this._x = Math.atan2( -m23, m33 );
                            this._z = Math.atan2( -m12, m11 );
                        } else {
                            this._x = Math.atan2( m32, m22 );
                            this._z = 0;
                        }
                        break;
                    case 'YXZ':
                        this._x = Math.asin( -clamp( m23, -1, 1 ) );
                        if ( Math.abs( m23 ) < 0.9999999 ) {
                            this._y = Math.atan2( m13, m33 );
                            this._z = Math.atan2( m21, m22 );
                        } else {
                            this._y = Math.atan2( -m31, m11 );
                            this._z = 0;
                        }
                        break;
                    case 'ZXY':
                        this._x = Math.asin( clamp( m32, -1, 1 ) );
                        if ( Math.abs( m32 ) < 0.9999999 ) {
                            this._y = Math.atan2( -m31, m33 );
                            this._z = Math.atan2( -m12, m22 );
                        } else {
                            this._y = 0;
                            this._z = Math.atan2( m21, m11 );
                        }
                        break;
                    case 'ZYX':
                        this._y = Math.asin( -clamp( m31, -1, 1 ) );
                        if ( Math.abs( m31 ) < 0.9999999 ) {
                            this._x = Math.atan2( m32, m33 );
                            this._z = Math.atan2( m21, m11 );
                        } else {
                            this._x = 0;
                            this._z = Math.atan2( -m12, m22 );
                        }
                        break;
                    case 'YZX':
                        this._z = Math.asin( clamp( m21, -1, 1 ) );
                        if ( Math.abs( m21 ) < 0.9999999 ) {
                            this._x = Math.atan2( -m23, m22 );
                            this._y = Math.atan2( -m31, m11 );
                        } else {
                            this._x = 0;
                            this._y = Math.atan2( m13, m33 );
                        }
                        break;
                    case 'XZY':
                        this._z = Math.asin( -clamp( m12, -1, 1 ) );
                        if ( Math.abs( m12 ) < 0.9999999 ) {
                            this._x = Math.atan2( m32, m22 );
                            this._y = Math.atan2( m13, m11 );
                        } else {
                            this._x = Math.atan2( -m23, m33 );
                            this._y = 0;
                        }
                        break;
                    default:
                        console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );
                }
                this._order = order;
                if ( update === true ) this._onChangeCallback( );
                return this;
            }
        }, {
            key: "setFromQuaternion",
            value: function setFromQuaternion( q, order, update ) {
                _matrix$1.makeRotationFromQuaternion( q );
                return this.setFromRotationMatrix( _matrix$1, order, update );
            }
        }, {
            key: "setFromVector3",
            value: function setFromVector3( v ) {
                var order = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : this._order;
                return this.set( v.x, v.y, v.z, order );
            }
        }, {
            key: "reorder",
            value: function reorder( newOrder ) { // WARNING: this discards revolution information -bhouston
                _quaternion$3.setFromEuler( this );
                return this.setFromQuaternion( _quaternion$3, newOrder );
            }
        }, {
            key: "equals",
            value: function equals( euler ) {
                return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
            }
        }, {
            key: "fromArray",
            value: function fromArray( array ) {
                this._x = array[ 0 ];
                this._y = array[ 1 ];
                this._z = array[ 2 ];
                if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
                this._onChangeCallback( );
                return this;
            }
        }, {
            key: "toArray",
            value: function toArray( ) {
                var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                array[ offset ] = this._x;
                array[ offset + 1 ] = this._y;
                array[ offset + 2 ] = this._z;
                array[ offset + 3 ] = this._order;
                return array;
            }
        }, {
            key: "_onChange",
            value: function _onChange( callback ) {
                this._onChangeCallback = callback;
                return this;
            }
        }, {
            key: "_onChangeCallback",
            value: function _onChangeCallback( ) {}
        }, {
            key: _Symbol$iterator6,
            value: /*#__PURE__*/ _regeneratorRuntime( ).mark( function value( ) {
                return _regeneratorRuntime( ).wrap( function value$( _context7 ) {
                    while ( 1 ) {
                        switch ( _context7.prev = _context7.next ) {
                            case 0:
                                _context7.next = 2;
                                return this._x;
                            case 2:
                                _context7.next = 4;
                                return this._y;
                            case 4:
                                _context7.next = 6;
                                return this._z;
                            case 6:
                                _context7.next = 8;
                                return this._order;
                            case 8:
                            case "end":
                                return _context7.stop( );
                        }
                    }
                }, value, this );
            } ) // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
        }, {
            key: "toVector3",
            value: function toVector3( ) {
                console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );
            }
        } ] );
        return Euler;
    }( Symbol.iterator );
    Euler.DefaultOrder = 'XYZ';
    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
    var Layers = /*#__PURE__*/ function( ) {
        function Layers( ) {
            _classCallCheck( this, Layers );
            this.mask = 1 | 0;
        }
        _createClass( Layers, [ {
            key: "set",
            value: function set( channel ) {
                this.mask = ( 1 << channel | 0 ) >>> 0;
            }
        }, {
            key: "enable",
            value: function enable( channel ) {
                this.mask |= 1 << channel | 0;
            }
        }, {
            key: "enableAll",
            value: function enableAll( ) {
                this.mask = 0xffffffff | 0;
            }
        }, {
            key: "toggle",
            value: function toggle( channel ) {
                this.mask ^= 1 << channel | 0;
            }
        }, {
            key: "disable",
            value: function disable( channel ) {
                this.mask &= ~( 1 << channel | 0 );
            }
        }, {
            key: "disableAll",
            value: function disableAll( ) {
                this.mask = 0;
            }
        }, {
            key: "test",
            value: function test( layers ) {
                return ( this.mask & layers.mask ) !== 0;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled( channel ) {
                return ( this.mask & ( 1 << channel | 0 ) ) !== 0;
            }
        } ] );
        return Layers;
    }( );
    var _object3DId = 0;
    var _v1$4 = /*@__PURE__*/ new Vector3( );
    var _q1 = /*@__PURE__*/ new Quaternion$1( );
    var _m1$1 = /*@__PURE__*/ new Matrix4( );
    var _target = /*@__PURE__*/ new Vector3( );
    var _position$3 = /*@__PURE__*/ new Vector3( );
    var _scale$2 = /*@__PURE__*/ new Vector3( );
    var _quaternion$2 = /*@__PURE__*/ new Quaternion$1( );
    var _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
    var _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
    var _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );
    var _addedEvent = {
        type: 'added'
    };
    var _removedEvent = {
        type: 'removed'
    };
    var Object3D = /*#__PURE__*/ function( _EventDispatcher3 ) {
        _inherits( Object3D, _EventDispatcher3 );
        var _super5 = _createSuper( Object3D );

        function Object3D( ) {
            var _this6;
            _classCallCheck( this, Object3D );
            _this6 = _super5.call( this );
            _this6.isObject3D = true;
            Object.defineProperty( _assertThisInitialized( _this6 ), 'id', {
                value: _object3DId++
            } );
            _this6.uuid = generateUUID( );
            _this6.name = '';
            _this6.type = 'Object3D';
            _this6.parent = null;
            _this6.children = [ ];
            _this6.up = Object3D.DefaultUp.clone( );
            var position = new Vector3( );
            var rotation = new Euler( );
            var quaternion = new Quaternion$1( );
            var scale = new Vector3( 1, 1, 1 );

            function onRotationChange( ) {
                quaternion.setFromEuler( rotation, false );
            }

            function onQuaternionChange( ) {
                rotation.setFromQuaternion( quaternion, undefined, false );
            }
            rotation._onChange( onRotationChange );
            quaternion._onChange( onQuaternionChange );
            Object.defineProperties( _assertThisInitialized( _this6 ), {
                position: {
                    configurable: true,
                    enumerable: true,
                    value: position
                },
                rotation: {
                    configurable: true,
                    enumerable: true,
                    value: rotation
                },
                quaternion: {
                    configurable: true,
                    enumerable: true,
                    value: quaternion
                },
                scale: {
                    configurable: true,
                    enumerable: true,
                    value: scale
                },
                modelViewMatrix: {
                    value: new Matrix4( )
                },
                normalMatrix: {
                    value: new Matrix3( )
                }
            } );
            _this6.matrix = new Matrix4( );
            _this6.matrixWorld = new Matrix4( );
            _this6.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            _this6.matrixWorldNeedsUpdate = false;
            _this6.layers = new Layers( );
            _this6.visible = true;
            _this6.castShadow = false;
            _this6.receiveShadow = false;
            _this6.frustumCulled = true;
            _this6.renderOrder = 0;
            _this6.animations = [ ];
            _this6.userData = {};
            return _this6;
        }
        _createClass( Object3D, [ {
            key: "onBeforeRender",
            value: function /* renderer, scene, camera, geometry, material, group */ onBeforeRender( ) {}
        }, {
            key: "onAfterRender",
            value: function /* renderer, scene, camera, geometry, material, group */ onAfterRender( ) {}
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix ) {
                if ( this.matrixAutoUpdate ) this.updateMatrix( );
                this.matrix.premultiply( matrix );
                this.matrix.decompose( this.position, this.quaternion, this.scale );
            }
        }, {
            key: "applyQuaternion",
            value: function applyQuaternion( q ) {
                this.quaternion.premultiply( q );
                return this;
            }
        }, {
            key: "setRotationFromAxisAngle",
            value: function setRotationFromAxisAngle( axis, angle ) { // assumes axis is normalized
                this.quaternion.setFromAxisAngle( axis, angle );
            }
        }, {
            key: "setRotationFromEuler",
            value: function setRotationFromEuler( euler ) {
                this.quaternion.setFromEuler( euler, true );
            }
        }, {
            key: "setRotationFromMatrix",
            value: function setRotationFromMatrix( m ) { // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                this.quaternion.setFromRotationMatrix( m );
            }
        }, {
            key: "setRotationFromQuaternion",
            value: function setRotationFromQuaternion( q ) { // assumes q is normalized
                this.quaternion.copy( q );
            }
        }, {
            key: "rotateOnAxis",
            value: function rotateOnAxis( axis, angle ) { // rotate object on axis in object space
                // axis is assumed to be normalized
                _q1.setFromAxisAngle( axis, angle );
                this.quaternion.multiply( _q1 );
                return this;
            }
        }, {
            key: "rotateOnWorldAxis",
            value: function rotateOnWorldAxis( axis, angle ) { // rotate object on axis in world space
                // axis is assumed to be normalized
                // method assumes no rotated parent
                _q1.setFromAxisAngle( axis, angle );
                this.quaternion.premultiply( _q1 );
                return this;
            }
        }, {
            key: "rotateX",
            value: function rotateX( angle ) {
                return this.rotateOnAxis( _xAxis, angle );
            }
        }, {
            key: "rotateY",
            value: function rotateY( angle ) {
                return this.rotateOnAxis( _yAxis, angle );
            }
        }, {
            key: "rotateZ",
            value: function rotateZ( angle ) {
                return this.rotateOnAxis( _zAxis, angle );
            }
        }, {
            key: "translateOnAxis",
            value: function translateOnAxis( axis, distance ) { // translate object by distance along axis in object space
                // axis is assumed to be normalized
                _v1$4.copy( axis ).applyQuaternion( this.quaternion );
                this.position.add( _v1$4.multiplyScalar( distance ) );
                return this;
            }
        }, {
            key: "translateX",
            value: function translateX( distance ) {
                return this.translateOnAxis( _xAxis, distance );
            }
        }, {
            key: "translateY",
            value: function translateY( distance ) {
                return this.translateOnAxis( _yAxis, distance );
            }
        }, {
            key: "translateZ",
            value: function translateZ( distance ) {
                return this.translateOnAxis( _zAxis, distance );
            }
        }, {
            key: "localToWorld",
            value: function localToWorld( vector ) {
                return vector.applyMatrix4( this.matrixWorld );
            }
        }, {
            key: "worldToLocal",
            value: function worldToLocal( vector ) {
                return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert( ) );
            }
        }, {
            key: "lookAt",
            value: function lookAt( x, y, z ) { // This method does not support objects having non-uniformly-scaled parent(s)
                if ( x.isVector3 ) {
                    _target.copy( x );
                } else {
                    _target.set( x, y, z );
                }
                var parent = this.parent;
                this.updateWorldMatrix( true, false );
                _position$3.setFromMatrixPosition( this.matrixWorld );
                if ( this.isCamera || this.isLight ) {
                    _m1$1.lookAt( _position$3, _target, this.up );
                } else {
                    _m1$1.lookAt( _target, _position$3, this.up );
                }
                this.quaternion.setFromRotationMatrix( _m1$1 );
                if ( parent ) {
                    _m1$1.extractRotation( parent.matrixWorld );
                    _q1.setFromRotationMatrix( _m1$1 );
                    this.quaternion.premultiply( _q1.invert( ) );
                }
            }
        }, {
            key: "add",
            value: function add( object ) {
                if ( arguments.length > 1 ) {
                    for ( var _i18 = 0; _i18 < arguments.length; _i18++ ) {
                        this.add( arguments[ _i18 ] );
                    }
                    return this;
                }
                if ( object === this ) {
                    console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
                    return this;
                }
                if ( object && object.isObject3D ) {
                    if ( object.parent !== null ) {
                        object.parent.remove( object );
                    }
                    object.parent = this;
                    this.children.push( object );
                    object.dispatchEvent( _addedEvent );
                } else {
                    console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );
                }
                return this;
            }
        }, {
            key: "remove",
            value: function remove( object ) {
                if ( arguments.length > 1 ) {
                    for ( var _i19 = 0; _i19 < arguments.length; _i19++ ) {
                        this.remove( arguments[ _i19 ] );
                    }
                    return this;
                }
                var index = this.children.indexOf( object );
                if ( index !== -1 ) {
                    object.parent = null;
                    this.children.splice( index, 1 );
                    object.dispatchEvent( _removedEvent );
                }
                return this;
            }
        }, {
            key: "removeFromParent",
            value: function removeFromParent( ) {
                var parent = this.parent;
                if ( parent !== null ) {
                    parent.remove( this );
                }
                return this;
            }
        }, {
            key: "clear",
            value: function clear( ) {
                for ( var _i20 = 0; _i20 < this.children.length; _i20++ ) {
                    var object = this.children[ _i20 ];
                    object.parent = null;
                    object.dispatchEvent( _removedEvent );
                }
                this.children.length = 0;
                return this;
            }
        }, {
            key: "attach",
            value: function attach( object ) { // adds object as a child of this, while maintaining the object's world transform
                // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
                this.updateWorldMatrix( true, false );
                _m1$1.copy( this.matrixWorld ).invert( );
                if ( object.parent !== null ) {
                    object.parent.updateWorldMatrix( true, false );
                    _m1$1.multiply( object.parent.matrixWorld );
                }
                object.applyMatrix4( _m1$1 );
                this.add( object );
                object.updateWorldMatrix( false, true );
                return this;
            }
        }, {
            key: "getObjectById",
            value: function getObjectById( id ) {
                return this.getObjectByProperty( 'id', id );
            }
        }, {
            key: "getObjectByName",
            value: function getObjectByName( name ) {
                return this.getObjectByProperty( 'name', name );
            }
        }, {
            key: "getObjectByProperty",
            value: function getObjectByProperty( name, value ) {
                if ( this[ name ] === value ) return this;
                for ( var _i21 = 0, l = this.children.length; _i21 < l; _i21++ ) {
                    var child = this.children[ _i21 ];
                    var object = child.getObjectByProperty( name, value );
                    if ( object !== undefined ) {
                        return object;
                    }
                }
                return undefined;
            }
        }, {
            key: "getWorldPosition",
            value: function getWorldPosition( target ) {
                this.updateWorldMatrix( true, false );
                return target.setFromMatrixPosition( this.matrixWorld );
            }
        }, {
            key: "getWorldQuaternion",
            value: function getWorldQuaternion( target ) {
                this.updateWorldMatrix( true, false );
                this.matrixWorld.decompose( _position$3, target, _scale$2 );
                return target;
            }
        }, {
            key: "getWorldScale",
            value: function getWorldScale( target ) {
                this.updateWorldMatrix( true, false );
                this.matrixWorld.decompose( _position$3, _quaternion$2, target );
                return target;
            }
        }, {
            key: "getWorldDirection",
            value: function getWorldDirection( target ) {
                this.updateWorldMatrix( true, false );
                var e = this.matrixWorld.elements;
                return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize( );
            }
        }, {
            key: "raycast",
            value: function /* raycaster, intersects */ raycast( ) {}
        }, {
            key: "traverse",
            value: function traverse( callback ) {
                callback( this );
                var children = this.children;
                for ( var _i22 = 0, l = children.length; _i22 < l; _i22++ ) {
                    children[ _i22 ].traverse( callback );
                }
            }
        }, {
            key: "traverseVisible",
            value: function traverseVisible( callback ) {
                if ( this.visible === false ) return;
                callback( this );
                var children = this.children;
                for ( var _i23 = 0, l = children.length; _i23 < l; _i23++ ) {
                    children[ _i23 ].traverseVisible( callback );
                }
            }
        }, {
            key: "traverseAncestors",
            value: function traverseAncestors( callback ) {
                var parent = this.parent;
                if ( parent !== null ) {
                    callback( parent );
                    parent.traverseAncestors( callback );
                }
            }
        }, {
            key: "updateMatrix",
            value: function updateMatrix( ) {
                this.matrix.compose( this.position, this.quaternion, this.scale );
                this.matrixWorldNeedsUpdate = true;
            }
        }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld( force ) {
                if ( this.matrixAutoUpdate ) this.updateMatrix( );
                if ( this.matrixWorldNeedsUpdate || force ) {
                    if ( this.parent === null ) {
                        this.matrixWorld.copy( this.matrix );
                    } else {
                        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
                    }
                    this.matrixWorldNeedsUpdate = false;
                    force = true;
                } // update children
                var children = this.children;
                for ( var _i24 = 0, l = children.length; _i24 < l; _i24++ ) {
                    children[ _i24 ].updateMatrixWorld( force );
                }
            }
        }, {
            key: "updateWorldMatrix",
            value: function updateWorldMatrix( updateParents, updateChildren ) {
                var parent = this.parent;
                if ( updateParents === true && parent !== null ) {
                    parent.updateWorldMatrix( true, false );
                }
                if ( this.matrixAutoUpdate ) this.updateMatrix( );
                if ( this.parent === null ) {
                    this.matrixWorld.copy( this.matrix );
                } else {
                    this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
                } // update children
                if ( updateChildren === true ) {
                    var children = this.children;
                    for ( var _i25 = 0, l = children.length; _i25 < l; _i25++ ) {
                        children[ _i25 ].updateWorldMatrix( false, true );
                    }
                }
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) { // meta is a string when called from JSON.stringify
                var isRootObject = meta === undefined || typeof meta === 'string';
                var output = {}; // meta is a hash used to collect geometries, materials.
                // not providing it implies that this is the root object
                // being serialized.
                if ( isRootObject ) { // initialize meta obj
                    meta = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    };
                    output.metadata = {
                        version: 4.5,
                        type: 'Object',
                        generator: 'Object3D.toJSON'
                    };
                } // standard Object3D serialization
                var object = {};
                object.uuid = this.uuid;
                object.type = this.type;
                if ( this.name !== '' ) object.name = this.name;
                if ( this.castShadow === true ) object.castShadow = true;
                if ( this.receiveShadow === true ) object.receiveShadow = true;
                if ( this.visible === false ) object.visible = false;
                if ( this.frustumCulled === false ) object.frustumCulled = false;
                if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
                if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
                object.layers = this.layers.mask;
                object.matrix = this.matrix.toArray( );
                if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false; // object specific properties
                if ( this.isInstancedMesh ) {
                    object.type = 'InstancedMesh';
                    object.count = this.count;
                    object.instanceMatrix = this.instanceMatrix.toJSON( );
                    if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON( );
                } //
                function serialize( library, element ) {
                    if ( library[ element.uuid ] === undefined ) {
                        library[ element.uuid ] = element.toJSON( meta );
                    }
                    return element.uuid;
                }
                if ( this.isScene ) {
                    if ( this.background ) {
                        if ( this.background.isColor ) {
                            object.background = this.background.toJSON( );
                        } else if ( this.background.isTexture ) {
                            object.background = this.background.toJSON( meta ).uuid;
                        }
                    }
                    if ( this.environment && this.environment.isTexture ) {
                        object.environment = this.environment.toJSON( meta ).uuid;
                    }
                } else if ( this.isMesh || this.isLine || this.isPoints ) {
                    object.geometry = serialize( meta.geometries, this.geometry );
                    var parameters = this.geometry.parameters;
                    if ( parameters !== undefined && parameters.shapes !== undefined ) {
                        var shapes = parameters.shapes;
                        if ( Array.isArray( shapes ) ) {
                            for ( var _i26 = 0, l = shapes.length; _i26 < l; _i26++ ) {
                                var shape = shapes[ _i26 ];
                                serialize( meta.shapes, shape );
                            }
                        } else {
                            serialize( meta.shapes, shapes );
                        }
                    }
                }
                if ( this.isSkinnedMesh ) {
                    object.bindMode = this.bindMode;
                    object.bindMatrix = this.bindMatrix.toArray( );
                    if ( this.skeleton !== undefined ) {
                        serialize( meta.skeletons, this.skeleton );
                        object.skeleton = this.skeleton.uuid;
                    }
                }
                if ( this.material !== undefined ) {
                    if ( Array.isArray( this.material ) ) {
                        var uuids = [ ];
                        for ( var _i27 = 0, _l2 = this.material.length; _i27 < _l2; _i27++ ) {
                            uuids.push( serialize( meta.materials, this.material[ _i27 ] ) );
                        }
                        object.material = uuids;
                    } else {
                        object.material = serialize( meta.materials, this.material );
                    }
                } //
                if ( this.children.length > 0 ) {
                    object.children = [ ];
                    for ( var _i28 = 0; _i28 < this.children.length; _i28++ ) {
                        object.children.push( this.children[ _i28 ].toJSON( meta ).object );
                    }
                } //
                if ( this.animations.length > 0 ) {
                    object.animations = [ ];
                    for ( var _i29 = 0; _i29 < this.animations.length; _i29++ ) {
                        var animation = this.animations[ _i29 ];
                        object.animations.push( serialize( meta.animations, animation ) );
                    }
                }
                if ( isRootObject ) {
                    var geometries = extractFromCache( meta.geometries );
                    var materials = extractFromCache( meta.materials );
                    var textures = extractFromCache( meta.textures );
                    var images = extractFromCache( meta.images );
                    var _shapes = extractFromCache( meta.shapes );
                    var skeletons = extractFromCache( meta.skeletons );
                    var _animations = extractFromCache( meta.animations );
                    var nodes = extractFromCache( meta.nodes );
                    if ( geometries.length > 0 ) output.geometries = geometries;
                    if ( materials.length > 0 ) output.materials = materials;
                    if ( textures.length > 0 ) output.textures = textures;
                    if ( images.length > 0 ) output.images = images;
                    if ( _shapes.length > 0 ) output.shapes = _shapes;
                    if ( skeletons.length > 0 ) output.skeletons = skeletons;
                    if ( _animations.length > 0 ) output.animations = _animations;
                    if ( nodes.length > 0 ) output.nodes = nodes;
                }
                output.object = object;
                return output; // extract data from the cache hash
                // remove metadata on each item
                // and return as array
                function extractFromCache( cache ) {
                    var values = [ ];
                    for ( var key in cache ) {
                        var data = cache[ key ];
                        delete data.metadata;
                        values.push( data );
                    }
                    return values;
                }
            }
        }, {
            key: "clone",
            value: function clone( recursive ) {
                return new this.constructor( ).copy( this, recursive );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                var recursive = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : true;
                this.name = source.name;
                this.up.copy( source.up );
                this.position.copy( source.position );
                this.rotation.order = source.rotation.order;
                this.quaternion.copy( source.quaternion );
                this.scale.copy( source.scale );
                this.matrix.copy( source.matrix );
                this.matrixWorld.copy( source.matrixWorld );
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                this.layers.mask = source.layers.mask;
                this.visible = source.visible;
                this.castShadow = source.castShadow;
                this.receiveShadow = source.receiveShadow;
                this.frustumCulled = source.frustumCulled;
                this.renderOrder = source.renderOrder;
                this.userData = JSON.parse( JSON.stringify( source.userData ) );
                if ( recursive === true ) {
                    for ( var _i30 = 0; _i30 < source.children.length; _i30++ ) {
                        var child = source.children[ _i30 ];
                        this.add( child.clone( ) );
                    }
                }
                return this;
            }
        } ] );
        return Object3D;
    }( EventDispatcher );
    Object3D.DefaultUp = /*@__PURE__*/ new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;
    var _v0$1 = /*@__PURE__*/ new Vector3( );
    var _v1$3 = /*@__PURE__*/ new Vector3( );
    var _v2$2 = /*@__PURE__*/ new Vector3( );
    var _v3$1 = /*@__PURE__*/ new Vector3( );
    var _vab = /*@__PURE__*/ new Vector3( );
    var _vac = /*@__PURE__*/ new Vector3( );
    var _vbc = /*@__PURE__*/ new Vector3( );
    var _vap = /*@__PURE__*/ new Vector3( );
    var _vbp = /*@__PURE__*/ new Vector3( );
    var _vcp = /*@__PURE__*/ new Vector3( );
    var Triangle = /*#__PURE__*/ function( ) {
        function Triangle( ) {
            var a = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Vector3( );
            var b = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new Vector3( );
            var c = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : new Vector3( );
            _classCallCheck( this, Triangle );
            this.a = a;
            this.b = b;
            this.c = c;
        }
        _createClass( Triangle, [ {
            key: "set",
            value: function set( a, b, c ) {
                this.a.copy( a );
                this.b.copy( b );
                this.c.copy( c );
                return this;
            }
        }, {
            key: "setFromPointsAndIndices",
            value: function setFromPointsAndIndices( points, i0, i1, i2 ) {
                this.a.copy( points[ i0 ] );
                this.b.copy( points[ i1 ] );
                this.c.copy( points[ i2 ] );
                return this;
            }
        }, {
            key: "setFromAttributeAndIndices",
            value: function setFromAttributeAndIndices( attribute, i0, i1, i2 ) {
                this.a.fromBufferAttribute( attribute, i0 );
                this.b.fromBufferAttribute( attribute, i1 );
                this.c.fromBufferAttribute( attribute, i2 );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( triangle ) {
                this.a.copy( triangle.a );
                this.b.copy( triangle.b );
                this.c.copy( triangle.c );
                return this;
            }
        }, {
            key: "getArea",
            value: function getArea( ) {
                _v0$1.subVectors( this.c, this.b );
                _v1$3.subVectors( this.a, this.b );
                return _v0$1.cross( _v1$3 ).length( ) * 0.5;
            }
        }, {
            key: "getMidpoint",
            value: function getMidpoint( target ) {
                return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
            }
        }, {
            key: "getNormal",
            value: function getNormal( target ) {
                return Triangle.getNormal( this.a, this.b, this.c, target );
            }
        }, {
            key: "getPlane",
            value: function getPlane( target ) {
                return target.setFromCoplanarPoints( this.a, this.b, this.c );
            }
        }, {
            key: "getBarycoord",
            value: function getBarycoord( point, target ) {
                return Triangle.getBarycoord( point, this.a, this.b, this.c, target );
            }
        }, {
            key: "getUV",
            value: function getUV( point, uv1, uv2, uv3, target ) {
                return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );
            }
        }, {
            key: "containsPoint",
            value: function containsPoint( point ) {
                return Triangle.containsPoint( point, this.a, this.b, this.c );
            }
        }, {
            key: "isFrontFacing",
            value: function isFrontFacing( direction ) {
                return Triangle.isFrontFacing( this.a, this.b, this.c, direction );
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) {
                return box.intersectsTriangle( this );
            }
        }, {
            key: "closestPointToPoint",
            value: function closestPointToPoint( p, target ) {
                var a = this.a,
                    b = this.b,
                    c = this.c;
                var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
                // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
                // under the accompanying license; see chapter 5.1.5 for detailed explanation.
                // basically, we're distinguishing which of the voronoi regions of the triangle
                // the point lies in with the minimum amount of redundant computation.
                _vab.subVectors( b, a );
                _vac.subVectors( c, a );
                _vap.subVectors( p, a );
                var d1 = _vab.dot( _vap );
                var d2 = _vac.dot( _vap );
                if ( d1 <= 0 && d2 <= 0 ) { // vertex region of A; barycentric coords (1, 0, 0)
                    return target.copy( a );
                }
                _vbp.subVectors( p, b );
                var d3 = _vab.dot( _vbp );
                var d4 = _vac.dot( _vbp );
                if ( d3 >= 0 && d4 <= d3 ) { // vertex region of B; barycentric coords (0, 1, 0)
                    return target.copy( b );
                }
                var vc = d1 * d4 - d3 * d2;
                if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {
                    v = d1 / ( d1 - d3 ); // edge region of AB; barycentric coords (1-v, v, 0)
                    return target.copy( a ).addScaledVector( _vab, v );
                }
                _vcp.subVectors( p, c );
                var d5 = _vab.dot( _vcp );
                var d6 = _vac.dot( _vcp );
                if ( d6 >= 0 && d5 <= d6 ) { // vertex region of C; barycentric coords (0, 0, 1)
                    return target.copy( c );
                }
                var vb = d5 * d2 - d1 * d6;
                if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {
                    w = d2 / ( d2 - d6 ); // edge region of AC; barycentric coords (1-w, 0, w)
                    return target.copy( a ).addScaledVector( _vac, w );
                }
                var va = d3 * d6 - d5 * d4;
                if ( va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0 ) {
                    _vbc.subVectors( c, b );
                    w = ( d4 - d3 ) / ( d4 - d3 + ( d5 - d6 ) ); // edge region of BC; barycentric coords (0, 1-w, w)
                    return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC
                } // face region
                var denom = 1 / ( va + vb + vc ); // u = va * denom
                v = vb * denom;
                w = vc * denom;
                return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );
            }
        }, {
            key: "equals",
            value: function equals( triangle ) {
                return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
            }
        } ], [ {
            key: "getNormal",
            value: function getNormal( a, b, c, target ) {
                target.subVectors( c, b );
                _v0$1.subVectors( a, b );
                target.cross( _v0$1 );
                var targetLengthSq = target.lengthSq( );
                if ( targetLengthSq > 0 ) {
                    return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );
                }
                return target.set( 0, 0, 0 );
            } // static/instance method to calculate barycentric coordinates
            // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
        }, {
            key: "getBarycoord",
            value: function getBarycoord( point, a, b, c, target ) {
                _v0$1.subVectors( c, a );
                _v1$3.subVectors( b, a );
                _v2$2.subVectors( point, a );
                var dot00 = _v0$1.dot( _v0$1 );
                var dot01 = _v0$1.dot( _v1$3 );
                var dot02 = _v0$1.dot( _v2$2 );
                var dot11 = _v1$3.dot( _v1$3 );
                var dot12 = _v1$3.dot( _v2$2 );
                var denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle
                if ( denom === 0 ) { // arbitrary location outside of triangle?
                    // not sure if this is the best idea, maybe should be returning undefined
                    return target.set( -2, -1, -1 );
                }
                var invDenom = 1 / denom;
                var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
                var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom; // barycentric coordinates must always sum to 1
                return target.set( 1 - u - v, v, u );
            }
        }, {
            key: "containsPoint",
            value: function containsPoint( point, a, b, c ) {
                this.getBarycoord( point, a, b, c, _v3$1 );
                return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
            }
        }, {
            key: "getUV",
            value: function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {
                this.getBarycoord( point, p1, p2, p3, _v3$1 );
                target.set( 0, 0 );
                target.addScaledVector( uv1, _v3$1.x );
                target.addScaledVector( uv2, _v3$1.y );
                target.addScaledVector( uv3, _v3$1.z );
                return target;
            }
        }, {
            key: "isFrontFacing",
            value: function isFrontFacing( a, b, c, direction ) {
                _v0$1.subVectors( c, b );
                _v1$3.subVectors( a, b ); // strictly front facing
                return _v0$1.cross( _v1$3 ).dot( direction ) < 0 ? true : false;
            }
        } ] );
        return Triangle;
    }( );
    var materialId = 0;
    var Material$1 = /*#__PURE__*/ function( _EventDispatcher4 ) {
        _inherits( Material$1, _EventDispatcher4 );
        var _super6 = _createSuper( Material$1 );

        function Material$1( ) {
            var _this7;
            _classCallCheck( this, Material$1 );
            _this7 = _super6.call( this );
            _this7.isMaterial = true;
            Object.defineProperty( _assertThisInitialized( _this7 ), 'id', {
                value: materialId++
            } );
            _this7.uuid = generateUUID( );
            _this7.name = '';
            _this7.type = 'Material';
            _this7.blending = NormalBlending;
            _this7.side = FrontSide;
            _this7.vertexColors = false;
            _this7.opacity = 1;
            _this7.transparent = false;
            _this7.blendSrc = SrcAlphaFactor;
            _this7.blendDst = OneMinusSrcAlphaFactor;
            _this7.blendEquation = AddEquation;
            _this7.blendSrcAlpha = null;
            _this7.blendDstAlpha = null;
            _this7.blendEquationAlpha = null;
            _this7.depthFunc = LessEqualDepth;
            _this7.depthTest = true;
            _this7.depthWrite = true;
            _this7.stencilWriteMask = 0xff;
            _this7.stencilFunc = AlwaysStencilFunc;
            _this7.stencilRef = 0;
            _this7.stencilFuncMask = 0xff;
            _this7.stencilFail = KeepStencilOp;
            _this7.stencilZFail = KeepStencilOp;
            _this7.stencilZPass = KeepStencilOp;
            _this7.stencilWrite = false;
            _this7.clippingPlanes = null;
            _this7.clipIntersection = false;
            _this7.clipShadows = false;
            _this7.shadowSide = null;
            _this7.colorWrite = true;
            _this7.precision = null; // override the renderer's default precision for this material
            _this7.polygonOffset = false;
            _this7.polygonOffsetFactor = 0;
            _this7.polygonOffsetUnits = 0;
            _this7.dithering = false;
            _this7.alphaToCoverage = false;
            _this7.premultipliedAlpha = false;
            _this7.visible = true;
            _this7.toneMapped = true;
            _this7.userData = {};
            _this7.version = 0;
            _this7._alphaTest = 0;
            return _this7;
        }
        _createClass( Material$1, [ {
            key: "alphaTest",
            get: function get( ) {
                return this._alphaTest;
            },
            set: function set( value ) {
                if ( this._alphaTest > 0 !== value > 0 ) {
                    this.version++;
                }
                this._alphaTest = value;
            }
        }, {
            key: "onBuild",
            value: function /* shaderobject, renderer */ onBuild( ) {}
        }, {
            key: "onBeforeRender",
            value: function /* renderer, scene, camera, geometry, object, group */ onBeforeRender( ) {}
        }, {
            key: "onBeforeCompile",
            value: function /* shaderobject, renderer */ onBeforeCompile( ) {}
        }, {
            key: "customProgramCacheKey",
            value: function customProgramCacheKey( ) {
                return this.onBeforeCompile.toString( );
            }
        }, {
            key: "setValues",
            value: function setValues( values ) {
                if ( values === undefined ) return;
                for ( var key in values ) {
                    var newValue = values[ key ];
                    if ( newValue === undefined ) {
                        console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
                        continue;
                    } // for backward compatibility if shading is set in the constructor
                    if ( key === 'shading' ) {
                        console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
                        this.flatShading = newValue === FlatShading ? true : false;
                        continue;
                    }
                    var currentValue = this[ key ];
                    if ( currentValue === undefined ) {
                        console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
                        continue;
                    }
                    if ( currentValue && currentValue.isColor ) {
                        currentValue.set( newValue );
                    } else if ( currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ) {
                        currentValue.copy( newValue );
                    } else {
                        this[ key ] = newValue;
                    }
                }
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var isRootObject = meta === undefined || typeof meta === 'string';
                if ( isRootObject ) {
                    meta = {
                        textures: {},
                        images: {}
                    };
                }
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Material',
                        generator: 'Material.toJSON'
                    }
                }; // standard Material serialization
                data.uuid = this.uuid;
                data.type = this.type;
                if ( this.name !== '' ) data.name = this.name;
                if ( this.color && this.color.isColor ) data.color = this.color.getHex( );
                if ( this.roughness !== undefined ) data.roughness = this.roughness;
                if ( this.metalness !== undefined ) data.metalness = this.metalness;
                if ( this.sheen !== undefined ) data.sheen = this.sheen;
                if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex( );
                if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
                if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex( );
                if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;
                if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex( );
                if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
                if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex( );
                if ( this.shininess !== undefined ) data.shininess = this.shininess;
                if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
                if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;
                if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {
                    data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;
                }
                if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {
                    data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;
                }
                if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {
                    data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
                    data.clearcoatNormalScale = this.clearcoatNormalScale.toArray( );
                }
                if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
                if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
                if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
                if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {
                    data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;
                }
                if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {
                    data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;
                }
                if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
                if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
                if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
                if ( this.lightMap && this.lightMap.isTexture ) {
                    data.lightMap = this.lightMap.toJSON( meta ).uuid;
                    data.lightMapIntensity = this.lightMapIntensity;
                }
                if ( this.aoMap && this.aoMap.isTexture ) {
                    data.aoMap = this.aoMap.toJSON( meta ).uuid;
                    data.aoMapIntensity = this.aoMapIntensity;
                }
                if ( this.bumpMap && this.bumpMap.isTexture ) {
                    data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
                    data.bumpScale = this.bumpScale;
                }
                if ( this.normalMap && this.normalMap.isTexture ) {
                    data.normalMap = this.normalMap.toJSON( meta ).uuid;
                    data.normalMapType = this.normalMapType;
                    data.normalScale = this.normalScale.toArray( );
                }
                if ( this.displacementMap && this.displacementMap.isTexture ) {
                    data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
                    data.displacementScale = this.displacementScale;
                    data.displacementBias = this.displacementBias;
                }
                if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
                if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
                if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
                if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
                if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
                if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;
                if ( this.envMap && this.envMap.isTexture ) {
                    data.envMap = this.envMap.toJSON( meta ).uuid;
                    if ( this.combine !== undefined ) data.combine = this.combine;
                }
                if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
                if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
                if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;
                if ( this.gradientMap && this.gradientMap.isTexture ) {
                    data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
                }
                if ( this.transmission !== undefined ) data.transmission = this.transmission;
                if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
                if ( this.thickness !== undefined ) data.thickness = this.thickness;
                if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
                if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
                if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex( );
                if ( this.size !== undefined ) data.size = this.size;
                if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
                if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
                if ( this.blending !== NormalBlending ) data.blending = this.blending;
                if ( this.side !== FrontSide ) data.side = this.side;
                if ( this.vertexColors ) data.vertexColors = true;
                if ( this.opacity < 1 ) data.opacity = this.opacity;
                if ( this.transparent === true ) data.transparent = this.transparent;
                data.depthFunc = this.depthFunc;
                data.depthTest = this.depthTest;
                data.depthWrite = this.depthWrite;
                data.colorWrite = this.colorWrite;
                data.stencilWrite = this.stencilWrite;
                data.stencilWriteMask = this.stencilWriteMask;
                data.stencilFunc = this.stencilFunc;
                data.stencilRef = this.stencilRef;
                data.stencilFuncMask = this.stencilFuncMask;
                data.stencilFail = this.stencilFail;
                data.stencilZFail = this.stencilZFail;
                data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)
                if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;
                if ( this.polygonOffset === true ) data.polygonOffset = true;
                if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
                if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;
                if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
                if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
                if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
                if ( this.scale !== undefined ) data.scale = this.scale;
                if ( this.dithering === true ) data.dithering = true;
                if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
                if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
                if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
                if ( this.wireframe === true ) data.wireframe = this.wireframe;
                if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
                if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
                if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
                if ( this.flatShading === true ) data.flatShading = this.flatShading;
                if ( this.visible === false ) data.visible = false;
                if ( this.toneMapped === false ) data.toneMapped = false;
                if ( this.fog === false ) data.fog = false;
                if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData; // TODO: Copied from Object3D.toJSON
                function extractFromCache( cache ) {
                    var values = [ ];
                    for ( var key in cache ) {
                        var _data2 = cache[ key ];
                        delete _data2.metadata;
                        values.push( _data2 );
                    }
                    return values;
                }
                if ( isRootObject ) {
                    var textures = extractFromCache( meta.textures );
                    var images = extractFromCache( meta.images );
                    if ( textures.length > 0 ) data.textures = textures;
                    if ( images.length > 0 ) data.images = images;
                }
                return data;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.name = source.name;
                this.blending = source.blending;
                this.side = source.side;
                this.vertexColors = source.vertexColors;
                this.opacity = source.opacity;
                this.transparent = source.transparent;
                this.blendSrc = source.blendSrc;
                this.blendDst = source.blendDst;
                this.blendEquation = source.blendEquation;
                this.blendSrcAlpha = source.blendSrcAlpha;
                this.blendDstAlpha = source.blendDstAlpha;
                this.blendEquationAlpha = source.blendEquationAlpha;
                this.depthFunc = source.depthFunc;
                this.depthTest = source.depthTest;
                this.depthWrite = source.depthWrite;
                this.stencilWriteMask = source.stencilWriteMask;
                this.stencilFunc = source.stencilFunc;
                this.stencilRef = source.stencilRef;
                this.stencilFuncMask = source.stencilFuncMask;
                this.stencilFail = source.stencilFail;
                this.stencilZFail = source.stencilZFail;
                this.stencilZPass = source.stencilZPass;
                this.stencilWrite = source.stencilWrite;
                var srcPlanes = source.clippingPlanes;
                var dstPlanes = null;
                if ( srcPlanes !== null ) {
                    var n = srcPlanes.length;
                    dstPlanes = new Array( n );
                    for ( var _i31 = 0; _i31 !== n; ++_i31 ) {
                        dstPlanes[ _i31 ] = srcPlanes[ _i31 ].clone( );
                    }
                }
                this.clippingPlanes = dstPlanes;
                this.clipIntersection = source.clipIntersection;
                this.clipShadows = source.clipShadows;
                this.shadowSide = source.shadowSide;
                this.colorWrite = source.colorWrite;
                this.precision = source.precision;
                this.polygonOffset = source.polygonOffset;
                this.polygonOffsetFactor = source.polygonOffsetFactor;
                this.polygonOffsetUnits = source.polygonOffsetUnits;
                this.dithering = source.dithering;
                this.alphaTest = source.alphaTest;
                this.alphaToCoverage = source.alphaToCoverage;
                this.premultipliedAlpha = source.premultipliedAlpha;
                this.visible = source.visible;
                this.toneMapped = source.toneMapped;
                this.userData = JSON.parse( JSON.stringify( source.userData ) );
                return this;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.dispatchEvent( {
                    type: 'dispose'
                } );
            }
        }, {
            key: "needsUpdate",
            set: function set( value ) {
                if ( value === true ) this.version++;
            }
        } ] );
        return Material$1;
    }( EventDispatcher );
    var MeshBasicMaterial = /*#__PURE__*/ function( _Material$ ) {
        _inherits( MeshBasicMaterial, _Material$ );
        var _super7 = _createSuper( MeshBasicMaterial );

        function MeshBasicMaterial( parameters ) {
            var _this8;
            _classCallCheck( this, MeshBasicMaterial );
            _this8 = _super7.call( this );
            _this8.isMeshBasicMaterial = true;
            _this8.type = 'MeshBasicMaterial';
            _this8.color = new Color( 0xffffff ); // emissive
            _this8.map = null;
            _this8.lightMap = null;
            _this8.lightMapIntensity = 1.0;
            _this8.aoMap = null;
            _this8.aoMapIntensity = 1.0;
            _this8.specularMap = null;
            _this8.alphaMap = null;
            _this8.envMap = null;
            _this8.combine = MultiplyOperation;
            _this8.reflectivity = 1;
            _this8.refractionRatio = 0.98;
            _this8.wireframe = false;
            _this8.wireframeLinewidth = 1;
            _this8.wireframeLinecap = 'round';
            _this8.wireframeLinejoin = 'round';
            _this8.fog = true;
            _this8.setValues( parameters );
            return _this8;
        }
        _createClass( MeshBasicMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( MeshBasicMaterial.prototype ), "copy", this ).call( this, source );
                this.color.copy( source.color );
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.fog = source.fog;
                return this;
            }
        } ] );
        return MeshBasicMaterial;
    }( Material$1 );
    var _vector$9 = /*@__PURE__*/ new Vector3( );
    var _vector2$1 = /*@__PURE__*/ new Vector2( );
    var BufferAttribute = /*#__PURE__*/ function( ) {
        function BufferAttribute( array, itemSize, normalized ) {
            _classCallCheck( this, BufferAttribute );
            if ( Array.isArray( array ) ) {
                throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
            }
            this.isBufferAttribute = true;
            this.name = '';
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized === true;
            this.usage = StaticDrawUsage;
            this.updateRange = {
                offset: 0,
                count: -1
            };
            this.version = 0;
        }
        _createClass( BufferAttribute, [ {
            key: "onUploadCallback",
            value: function onUploadCallback( ) {}
        }, {
            key: "needsUpdate",
            set: function set( value ) {
                if ( value === true ) this.version++;
            }
        }, {
            key: "setUsage",
            value: function setUsage( value ) {
                this.usage = value;
                return this;
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.name = source.name;
                this.array = new source.array.constructor( source.array );
                this.itemSize = source.itemSize;
                this.count = source.count;
                this.normalized = source.normalized;
                this.usage = source.usage;
                return this;
            }
        }, {
            key: "copyAt",
            value: function copyAt( index1, attribute, index2 ) {
                index1 *= this.itemSize;
                index2 *= attribute.itemSize;
                for ( var _i32 = 0, l = this.itemSize; _i32 < l; _i32++ ) {
                    this.array[ index1 + _i32 ] = attribute.array[ index2 + _i32 ];
                }
                return this;
            }
        }, {
            key: "copyArray",
            value: function copyArray( array ) {
                this.array.set( array );
                return this;
            }
        }, {
            key: "copyColorsArray",
            value: function copyColorsArray( colors ) {
                var array = this.array;
                var offset = 0;
                for ( var _i33 = 0, l = colors.length; _i33 < l; _i33++ ) {
                    var color = colors[ _i33 ];
                    if ( color === undefined ) {
                        console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', _i33 );
                        color = new Color( );
                    }
                    array[ offset++ ] = color.r;
                    array[ offset++ ] = color.g;
                    array[ offset++ ] = color.b;
                }
                return this;
            }
        }, {
            key: "copyVector2sArray",
            value: function copyVector2sArray( vectors ) {
                var array = this.array;
                var offset = 0;
                for ( var _i34 = 0, l = vectors.length; _i34 < l; _i34++ ) {
                    var vector = vectors[ _i34 ];
                    if ( vector === undefined ) {
                        console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', _i34 );
                        vector = new Vector2( );
                    }
                    array[ offset++ ] = vector.x;
                    array[ offset++ ] = vector.y;
                }
                return this;
            }
        }, {
            key: "copyVector3sArray",
            value: function copyVector3sArray( vectors ) {
                var array = this.array;
                var offset = 0;
                for ( var _i35 = 0, l = vectors.length; _i35 < l; _i35++ ) {
                    var vector = vectors[ _i35 ];
                    if ( vector === undefined ) {
                        console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', _i35 );
                        vector = new Vector3( );
                    }
                    array[ offset++ ] = vector.x;
                    array[ offset++ ] = vector.y;
                    array[ offset++ ] = vector.z;
                }
                return this;
            }
        }, {
            key: "copyVector4sArray",
            value: function copyVector4sArray( vectors ) {
                var array = this.array;
                var offset = 0;
                for ( var _i36 = 0, l = vectors.length; _i36 < l; _i36++ ) {
                    var vector = vectors[ _i36 ];
                    if ( vector === undefined ) {
                        console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', _i36 );
                        vector = new Vector4( );
                    }
                    array[ offset++ ] = vector.x;
                    array[ offset++ ] = vector.y;
                    array[ offset++ ] = vector.z;
                    array[ offset++ ] = vector.w;
                }
                return this;
            }
        }, {
            key: "applyMatrix3",
            value: function applyMatrix3( m ) {
                if ( this.itemSize === 2 ) {
                    for ( var _i37 = 0, l = this.count; _i37 < l; _i37++ ) {
                        _vector2$1.fromBufferAttribute( this, _i37 );
                        _vector2$1.applyMatrix3( m );
                        this.setXY( _i37, _vector2$1.x, _vector2$1.y );
                    }
                } else if ( this.itemSize === 3 ) {
                    for ( var _i38 = 0, _l3 = this.count; _i38 < _l3; _i38++ ) {
                        _vector$9.fromBufferAttribute( this, _i38 );
                        _vector$9.applyMatrix3( m );
                        this.setXYZ( _i38, _vector$9.x, _vector$9.y, _vector$9.z );
                    }
                }
                return this;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( m ) {
                for ( var _i39 = 0, l = this.count; _i39 < l; _i39++ ) {
                    _vector$9.fromBufferAttribute( this, _i39 );
                    _vector$9.applyMatrix4( m );
                    this.setXYZ( _i39, _vector$9.x, _vector$9.y, _vector$9.z );
                }
                return this;
            }
        }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix( m ) {
                for ( var _i40 = 0, l = this.count; _i40 < l; _i40++ ) {
                    _vector$9.fromBufferAttribute( this, _i40 );
                    _vector$9.applyNormalMatrix( m );
                    this.setXYZ( _i40, _vector$9.x, _vector$9.y, _vector$9.z );
                }
                return this;
            }
        }, {
            key: "transformDirection",
            value: function transformDirection( m ) {
                for ( var _i41 = 0, l = this.count; _i41 < l; _i41++ ) {
                    _vector$9.fromBufferAttribute( this, _i41 );
                    _vector$9.transformDirection( m );
                    this.setXYZ( _i41, _vector$9.x, _vector$9.y, _vector$9.z );
                }
                return this;
            }
        }, {
            key: "set",
            value: function set( value ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.array.set( value, offset );
                return this;
            }
        }, {
            key: "getX",
            value: function getX( index ) {
                return this.array[ index * this.itemSize ];
            }
        }, {
            key: "setX",
            value: function setX( index, x ) {
                this.array[ index * this.itemSize ] = x;
                return this;
            }
        }, {
            key: "getY",
            value: function getY( index ) {
                return this.array[ index * this.itemSize + 1 ];
            }
        }, {
            key: "setY",
            value: function setY( index, y ) {
                this.array[ index * this.itemSize + 1 ] = y;
                return this;
            }
        }, {
            key: "getZ",
            value: function getZ( index ) {
                return this.array[ index * this.itemSize + 2 ];
            }
        }, {
            key: "setZ",
            value: function setZ( index, z ) {
                this.array[ index * this.itemSize + 2 ] = z;
                return this;
            }
        }, {
            key: "getW",
            value: function getW( index ) {
                return this.array[ index * this.itemSize + 3 ];
            }
        }, {
            key: "setW",
            value: function setW( index, w ) {
                this.array[ index * this.itemSize + 3 ] = w;
                return this;
            }
        }, {
            key: "setXY",
            value: function setXY( index, x, y ) {
                index *= this.itemSize;
                this.array[ index + 0 ] = x;
                this.array[ index + 1 ] = y;
                return this;
            }
        }, {
            key: "setXYZ",
            value: function setXYZ( index, x, y, z ) {
                index *= this.itemSize;
                this.array[ index + 0 ] = x;
                this.array[ index + 1 ] = y;
                this.array[ index + 2 ] = z;
                return this;
            }
        }, {
            key: "setXYZW",
            value: function setXYZW( index, x, y, z, w ) {
                index *= this.itemSize;
                this.array[ index + 0 ] = x;
                this.array[ index + 1 ] = y;
                this.array[ index + 2 ] = z;
                this.array[ index + 3 ] = w;
                return this;
            }
        }, {
            key: "onUpload",
            value: function onUpload( callback ) {
                this.onUploadCallback = callback;
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( this.array, this.itemSize ).copy( this );
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from( this.array ),
                    normalized: this.normalized
                };
                if ( this.name !== '' ) data.name = this.name;
                if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
                if ( this.updateRange.offset !== 0 || this.updateRange.count !== -1 ) data.updateRange = this.updateRange;
                return data;
            }
        } ] );
        return BufferAttribute;
    }( );
    var Uint16BufferAttribute = /*#__PURE__*/ function( _BufferAttribute ) {
        _inherits( Uint16BufferAttribute, _BufferAttribute );
        var _super8 = _createSuper( Uint16BufferAttribute );

        function Uint16BufferAttribute( array, itemSize, normalized ) {
            _classCallCheck( this, Uint16BufferAttribute );
            return _super8.call( this, new Uint16Array( array ), itemSize, normalized );
        }
        return _createClass( Uint16BufferAttribute );
    }( BufferAttribute );
    var Uint32BufferAttribute = /*#__PURE__*/ function( _BufferAttribute2 ) {
        _inherits( Uint32BufferAttribute, _BufferAttribute2 );
        var _super9 = _createSuper( Uint32BufferAttribute );

        function Uint32BufferAttribute( array, itemSize, normalized ) {
            _classCallCheck( this, Uint32BufferAttribute );
            return _super9.call( this, new Uint32Array( array ), itemSize, normalized );
        }
        return _createClass( Uint32BufferAttribute );
    }( BufferAttribute );
    var Float32BufferAttribute = /*#__PURE__*/ function( _BufferAttribute3 ) {
        _inherits( Float32BufferAttribute, _BufferAttribute3 );
        var _super10 = _createSuper( Float32BufferAttribute );

        function Float32BufferAttribute( array, itemSize, normalized ) {
            _classCallCheck( this, Float32BufferAttribute );
            return _super10.call( this, new Float32Array( array ), itemSize, normalized );
        }
        return _createClass( Float32BufferAttribute );
    }( BufferAttribute );
    var _id$1 = 0;
    var _m1 = /*@__PURE__*/ new Matrix4( );
    var _obj = /*@__PURE__*/ new Object3D( );
    var _offset = /*@__PURE__*/ new Vector3( );
    var _box$1 = /*@__PURE__*/ new Box3( );
    var _boxMorphTargets = /*@__PURE__*/ new Box3( );
    var _vector$8 = /*@__PURE__*/ new Vector3( );
    var BufferGeometry = /*#__PURE__*/ function( _EventDispatcher5 ) {
        _inherits( BufferGeometry, _EventDispatcher5 );
        var _super11 = _createSuper( BufferGeometry );

        function BufferGeometry( ) {
            var _this9;
            _classCallCheck( this, BufferGeometry );
            _this9 = _super11.call( this );
            _this9.isBufferGeometry = true;
            Object.defineProperty( _assertThisInitialized( _this9 ), 'id', {
                value: _id$1++
            } );
            _this9.uuid = generateUUID( );
            _this9.name = '';
            _this9.type = 'BufferGeometry';
            _this9.index = null;
            _this9.attributes = {};
            _this9.morphAttributes = {};
            _this9.morphTargetsRelative = false;
            _this9.groups = [ ];
            _this9.boundingBox = null;
            _this9.boundingSphere = null;
            _this9.drawRange = {
                start: 0,
                count: Infinity
            };
            _this9.userData = {};
            return _this9;
        }
        _createClass( BufferGeometry, [ {
            key: "getIndex",
            value: function getIndex( ) {
                return this.index;
            }
        }, {
            key: "setIndex",
            value: function setIndex( index ) {
                if ( Array.isArray( index ) ) {
                    this.index = new( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
                } else {
                    this.index = index;
                }
                return this;
            }
        }, {
            key: "getAttribute",
            value: function getAttribute( name ) {
                return this.attributes[ name ];
            }
        }, {
            key: "setAttribute",
            value: function setAttribute( name, attribute ) {
                this.attributes[ name ] = attribute;
                return this;
            }
        }, {
            key: "deleteAttribute",
            value: function deleteAttribute( name ) {
                delete this.attributes[ name ];
                return this;
            }
        }, {
            key: "hasAttribute",
            value: function hasAttribute( name ) {
                return this.attributes[ name ] !== undefined;
            }
        }, {
            key: "addGroup",
            value: function addGroup( start, count ) {
                var materialIndex = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
                this.groups.push( {
                    start: start,
                    count: count,
                    materialIndex: materialIndex
                } );
            }
        }, {
            key: "clearGroups",
            value: function clearGroups( ) {
                this.groups = [ ];
            }
        }, {
            key: "setDrawRange",
            value: function setDrawRange( start, count ) {
                this.drawRange.start = start;
                this.drawRange.count = count;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix ) {
                var position = this.attributes.position;
                if ( position !== undefined ) {
                    position.applyMatrix4( matrix );
                    position.needsUpdate = true;
                }
                var normal = this.attributes.normal;
                if ( normal !== undefined ) {
                    var normalMatrix = new Matrix3( ).getNormalMatrix( matrix );
                    normal.applyNormalMatrix( normalMatrix );
                    normal.needsUpdate = true;
                }
                var tangent = this.attributes.tangent;
                if ( tangent !== undefined ) {
                    tangent.transformDirection( matrix );
                    tangent.needsUpdate = true;
                }
                if ( this.boundingBox !== null ) {
                    this.computeBoundingBox( );
                }
                if ( this.boundingSphere !== null ) {
                    this.computeBoundingSphere( );
                }
                return this;
            }
        }, {
            key: "applyQuaternion",
            value: function applyQuaternion( q ) {
                _m1.makeRotationFromQuaternion( q );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "rotateX",
            value: function rotateX( angle ) { // rotate geometry around world x-axis
                _m1.makeRotationX( angle );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "rotateY",
            value: function rotateY( angle ) { // rotate geometry around world y-axis
                _m1.makeRotationY( angle );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ( angle ) { // rotate geometry around world z-axis
                _m1.makeRotationZ( angle );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "translate",
            value: function translate( x, y, z ) { // translate geometry
                _m1.makeTranslation( x, y, z );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "scale",
            value: function scale( x, y, z ) { // scale geometry
                _m1.makeScale( x, y, z );
                this.applyMatrix4( _m1 );
                return this;
            }
        }, {
            key: "lookAt",
            value: function lookAt( vector ) {
                _obj.lookAt( vector );
                _obj.updateMatrix( );
                this.applyMatrix4( _obj.matrix );
                return this;
            }
        }, {
            key: "center",
            value: function center( ) {
                this.computeBoundingBox( );
                this.boundingBox.getCenter( _offset ).negate( );
                this.translate( _offset.x, _offset.y, _offset.z );
                return this;
            }
        }, {
            key: "setFromPoints",
            value: function setFromPoints( points ) {
                var position = [ ];
                for ( var _i42 = 0, l = points.length; _i42 < l; _i42++ ) {
                    var point = points[ _i42 ];
                    position.push( point.x, point.y, point.z || 0 );
                }
                this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
                return this;
            }
        }, {
            key: "computeBoundingBox",
            value: function computeBoundingBox( ) {
                if ( this.boundingBox === null ) {
                    this.boundingBox = new Box3( );
                }
                var position = this.attributes.position;
                var morphAttributesPosition = this.morphAttributes.position;
                if ( position && position.isGLBufferAttribute ) {
                    console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );
                    this.boundingBox.set( new Vector3( -Infinity, -Infinity, -Infinity ), new Vector3( +Infinity, +Infinity, +Infinity ) );
                    return;
                }
                if ( position !== undefined ) {
                    this.boundingBox.setFromBufferAttribute( position ); // process morph attributes if present
                    if ( morphAttributesPosition ) {
                        for ( var _i43 = 0, il = morphAttributesPosition.length; _i43 < il; _i43++ ) {
                            var morphAttribute = morphAttributesPosition[ _i43 ];
                            _box$1.setFromBufferAttribute( morphAttribute );
                            if ( this.morphTargetsRelative ) {
                                _vector$8.addVectors( this.boundingBox.min, _box$1.min );
                                this.boundingBox.expandByPoint( _vector$8 );
                                _vector$8.addVectors( this.boundingBox.max, _box$1.max );
                                this.boundingBox.expandByPoint( _vector$8 );
                            } else {
                                this.boundingBox.expandByPoint( _box$1.min );
                                this.boundingBox.expandByPoint( _box$1.max );
                            }
                        }
                    }
                } else {
                    this.boundingBox.makeEmpty( );
                }
                if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
                    console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
                }
            }
        }, {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere( ) {
                if ( this.boundingSphere === null ) {
                    this.boundingSphere = new Sphere( );
                }
                var position = this.attributes.position;
                var morphAttributesPosition = this.morphAttributes.position;
                if ( position && position.isGLBufferAttribute ) {
                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );
                    this.boundingSphere.set( new Vector3( ), Infinity );
                    return;
                }
                if ( position ) { // first, find the center of the bounding sphere
                    var center = this.boundingSphere.center;
                    _box$1.setFromBufferAttribute( position ); // process morph attributes if present
                    if ( morphAttributesPosition ) {
                        for ( var _i44 = 0, il = morphAttributesPosition.length; _i44 < il; _i44++ ) {
                            var morphAttribute = morphAttributesPosition[ _i44 ];
                            _boxMorphTargets.setFromBufferAttribute( morphAttribute );
                            if ( this.morphTargetsRelative ) {
                                _vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
                                _box$1.expandByPoint( _vector$8 );
                                _vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
                                _box$1.expandByPoint( _vector$8 );
                            } else {
                                _box$1.expandByPoint( _boxMorphTargets.min );
                                _box$1.expandByPoint( _boxMorphTargets.max );
                            }
                        }
                    }
                    _box$1.getCenter( center ); // second, try to find a boundingSphere with a radius smaller than the
                    // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                    var maxRadiusSq = 0;
                    for ( var _i45 = 0, _il = position.count; _i45 < _il; _i45++ ) {
                        _vector$8.fromBufferAttribute( position, _i45 );
                        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );
                    } // process morph attributes if present
                    if ( morphAttributesPosition ) {
                        for ( var _i46 = 0, _il2 = morphAttributesPosition.length; _i46 < _il2; _i46++ ) {
                            var _morphAttribute = morphAttributesPosition[ _i46 ];
                            var morphTargetsRelative = this.morphTargetsRelative;
                            for ( var j = 0, jl = _morphAttribute.count; j < jl; j++ ) {
                                _vector$8.fromBufferAttribute( _morphAttribute, j );
                                if ( morphTargetsRelative ) {
                                    _offset.fromBufferAttribute( position, j );
                                    _vector$8.add( _offset );
                                }
                                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );
                            }
                        }
                    }
                    this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
                    if ( isNaN( this.boundingSphere.radius ) ) {
                        console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
                    }
                }
            }
        }, {
            key: "computeTangents",
            value: function computeTangents( ) {
                var index = this.index;
                var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
                // (per vertex tangents)
                if ( index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined ) {
                    console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
                    return;
                }
                var indices = index.array;
                var positions = attributes.position.array;
                var normals = attributes.normal.array;
                var uvs = attributes.uv.array;
                var nVertices = positions.length / 3;
                if ( this.hasAttribute( 'tangent' ) === false ) {
                    this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );
                }
                var tangents = this.getAttribute( 'tangent' ).array;
                var tan1 = [ ],
                    tan2 = [ ];
                for ( var _i47 = 0; _i47 < nVertices; _i47++ ) {
                    tan1[ _i47 ] = new Vector3( );
                    tan2[ _i47 ] = new Vector3( );
                }
                var vA = new Vector3( ),
                    vB = new Vector3( ),
                    vC = new Vector3( ),
                    uvA = new Vector2( ),
                    uvB = new Vector2( ),
                    uvC = new Vector2( ),
                    sdir = new Vector3( ),
                    tdir = new Vector3( );

                function handleTriangle( a, b, c ) {
                    vA.fromArray( positions, a * 3 );
                    vB.fromArray( positions, b * 3 );
                    vC.fromArray( positions, c * 3 );
                    uvA.fromArray( uvs, a * 2 );
                    uvB.fromArray( uvs, b * 2 );
                    uvC.fromArray( uvs, c * 2 );
                    vB.sub( vA );
                    vC.sub( vA );
                    uvB.sub( uvA );
                    uvC.sub( uvA );
                    var r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y ); // silently ignore degenerate uv triangles having coincident or colinear vertices
                    if ( !isFinite( r ) ) return;
                    sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, -uvB.y ).multiplyScalar( r );
                    tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, -uvC.x ).multiplyScalar( r );
                    tan1[ a ].add( sdir );
                    tan1[ b ].add( sdir );
                    tan1[ c ].add( sdir );
                    tan2[ a ].add( tdir );
                    tan2[ b ].add( tdir );
                    tan2[ c ].add( tdir );
                }
                var groups = this.groups;
                if ( groups.length === 0 ) {
                    groups = [ {
                        start: 0,
                        count: indices.length
                    } ];
                }
                for ( var _i48 = 0, il = groups.length; _i48 < il; ++_i48 ) {
                    var group = groups[ _i48 ];
                    var start = group.start;
                    var count = group.count;
                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {
                        handleTriangle( indices[ j + 0 ], indices[ j + 1 ], indices[ j + 2 ] );
                    }
                }
                var tmp = new Vector3( ),
                    tmp2 = new Vector3( );
                var n = new Vector3( ),
                    n2 = new Vector3( );

                function handleVertex( v ) {
                    n.fromArray( normals, v * 3 );
                    n2.copy( n );
                    var t = tan1[ v ]; // Gram-Schmidt orthogonalize
                    tmp.copy( t );
                    tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize( ); // Calculate handedness
                    tmp2.crossVectors( n2, t );
                    var test = tmp2.dot( tan2[ v ] );
                    var w = test < 0.0 ? -1.0 : 1.0;
                    tangents[ v * 4 ] = tmp.x;
                    tangents[ v * 4 + 1 ] = tmp.y;
                    tangents[ v * 4 + 2 ] = tmp.z;
                    tangents[ v * 4 + 3 ] = w;
                }
                for ( var _i49 = 0, _il3 = groups.length; _i49 < _il3; ++_i49 ) {
                    var _group2 = groups[ _i49 ];
                    var _start2 = _group2.start;
                    var _count = _group2.count;
                    for ( var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3 ) {
                        handleVertex( indices[ _j + 0 ] );
                        handleVertex( indices[ _j + 1 ] );
                        handleVertex( indices[ _j + 2 ] );
                    }
                }
            }
        }, {
            key: "computeVertexNormals",
            value: function computeVertexNormals( ) {
                var index = this.index;
                var positionAttribute = this.getAttribute( 'position' );
                if ( positionAttribute !== undefined ) {
                    var normalAttribute = this.getAttribute( 'normal' );
                    if ( normalAttribute === undefined ) {
                        normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
                        this.setAttribute( 'normal', normalAttribute );
                    } else { // reset existing normals to zero
                        for ( var _i50 = 0, il = normalAttribute.count; _i50 < il; _i50++ ) {
                            normalAttribute.setXYZ( _i50, 0, 0, 0 );
                        }
                    }
                    var pA = new Vector3( ),
                        pB = new Vector3( ),
                        pC = new Vector3( );
                    var nA = new Vector3( ),
                        nB = new Vector3( ),
                        nC = new Vector3( );
                    var cb = new Vector3( ),
                        ab = new Vector3( ); // indexed elements
                    if ( index ) {
                        for ( var _i51 = 0, _il4 = index.count; _i51 < _il4; _i51 += 3 ) {
                            var vA = index.getX( _i51 + 0 );
                            var vB = index.getX( _i51 + 1 );
                            var vC = index.getX( _i51 + 2 );
                            pA.fromBufferAttribute( positionAttribute, vA );
                            pB.fromBufferAttribute( positionAttribute, vB );
                            pC.fromBufferAttribute( positionAttribute, vC );
                            cb.subVectors( pC, pB );
                            ab.subVectors( pA, pB );
                            cb.cross( ab );
                            nA.fromBufferAttribute( normalAttribute, vA );
                            nB.fromBufferAttribute( normalAttribute, vB );
                            nC.fromBufferAttribute( normalAttribute, vC );
                            nA.add( cb );
                            nB.add( cb );
                            nC.add( cb );
                            normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
                            normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
                            normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );
                        }
                    } else { // non-indexed elements (unconnected triangle soup)
                        for ( var _i52 = 0, _il5 = positionAttribute.count; _i52 < _il5; _i52 += 3 ) {
                            pA.fromBufferAttribute( positionAttribute, _i52 + 0 );
                            pB.fromBufferAttribute( positionAttribute, _i52 + 1 );
                            pC.fromBufferAttribute( positionAttribute, _i52 + 2 );
                            cb.subVectors( pC, pB );
                            ab.subVectors( pA, pB );
                            cb.cross( ab );
                            normalAttribute.setXYZ( _i52 + 0, cb.x, cb.y, cb.z );
                            normalAttribute.setXYZ( _i52 + 1, cb.x, cb.y, cb.z );
                            normalAttribute.setXYZ( _i52 + 2, cb.x, cb.y, cb.z );
                        }
                    }
                    this.normalizeNormals( );
                    normalAttribute.needsUpdate = true;
                }
            }
        }, {
            key: "merge",
            value: function merge( geometry, offset ) {
                if ( !( geometry && geometry.isBufferGeometry ) ) {
                    console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
                    return;
                }
                if ( offset === undefined ) {
                    offset = 0;
                    console.warn( 'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.' );
                }
                var attributes = this.attributes;
                for ( var key in attributes ) {
                    if ( geometry.attributes[ key ] === undefined ) continue;
                    var attribute1 = attributes[ key ];
                    var attributeArray1 = attribute1.array;
                    var attribute2 = geometry.attributes[ key ];
                    var attributeArray2 = attribute2.array;
                    var attributeOffset = attribute2.itemSize * offset;
                    var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );
                    for ( var _i53 = 0, j = attributeOffset; _i53 < length; _i53++, j++ ) {
                        attributeArray1[ j ] = attributeArray2[ _i53 ];
                    }
                }
                return this;
            }
        }, {
            key: "normalizeNormals",
            value: function normalizeNormals( ) {
                var normals = this.attributes.normal;
                for ( var _i54 = 0, il = normals.count; _i54 < il; _i54++ ) {
                    _vector$8.fromBufferAttribute( normals, _i54 );
                    _vector$8.normalize( );
                    normals.setXYZ( _i54, _vector$8.x, _vector$8.y, _vector$8.z );
                }
            }
        }, {
            key: "toNonIndexed",
            value: function toNonIndexed( ) {
                function convertBufferAttribute( attribute, indices ) {
                    var array = attribute.array;
                    var itemSize = attribute.itemSize;
                    var normalized = attribute.normalized;
                    var array2 = new array.constructor( indices.length * itemSize );
                    var index = 0,
                        index2 = 0;
                    for ( var _i55 = 0, l = indices.length; _i55 < l; _i55++ ) {
                        if ( attribute.isInterleavedBufferAttribute ) {
                            index = indices[ _i55 ] * attribute.data.stride + attribute.offset;
                        } else {
                            index = indices[ _i55 ] * itemSize;
                        }
                        for ( var j = 0; j < itemSize; j++ ) {
                            array2[ index2++ ] = array[ index++ ];
                        }
                    }
                    return new BufferAttribute( array2, itemSize, normalized );
                } //
                if ( this.index === null ) {
                    console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
                    return this;
                }
                var geometry2 = new BufferGeometry( );
                var indices = this.index.array;
                var attributes = this.attributes; // attributes
                for ( var name in attributes ) {
                    var attribute = attributes[ name ];
                    var newAttribute = convertBufferAttribute( attribute, indices );
                    geometry2.setAttribute( name, newAttribute );
                } // morph attributes
                var morphAttributes = this.morphAttributes;
                for ( var _name in morphAttributes ) {
                    var morphArray = [ ];
                    var morphAttribute = morphAttributes[ _name ]; // morphAttribute: array of Float32BufferAttributes
                    for ( var _i56 = 0, il = morphAttribute.length; _i56 < il; _i56++ ) {
                        var _attribute = morphAttribute[ _i56 ];
                        var _newAttribute = convertBufferAttribute( _attribute, indices );
                        morphArray.push( _newAttribute );
                    }
                    geometry2.morphAttributes[ _name ] = morphArray;
                }
                geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups
                var groups = this.groups;
                for ( var _i57 = 0, l = groups.length; _i57 < l; _i57++ ) {
                    var group = groups[ _i57 ];
                    geometry2.addGroup( group.start, group.count, group.materialIndex );
                }
                return geometry2;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'BufferGeometry',
                        generator: 'BufferGeometry.toJSON'
                    }
                }; // standard BufferGeometry serialization
                data.uuid = this.uuid;
                data.type = this.type;
                if ( this.name !== '' ) data.name = this.name;
                if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;
                if ( this.parameters !== undefined ) {
                    var parameters = this.parameters;
                    for ( var key in parameters ) {
                        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
                    }
                    return data;
                } // for simplicity the code assumes attributes are not shared across geometries, see #15811
                data.data = {
                    attributes: {}
                };
                var index = this.index;
                if ( index !== null ) {
                    data.data.index = {
                        type: index.array.constructor.name,
                        array: Array.prototype.slice.call( index.array )
                    };
                }
                var attributes = this.attributes;
                for ( var _key in attributes ) {
                    var attribute = attributes[ _key ];
                    data.data.attributes[ _key ] = attribute.toJSON( data.data );
                }
                var morphAttributes = {};
                var hasMorphAttributes = false;
                for ( var _key2 in this.morphAttributes ) {
                    var attributeArray = this.morphAttributes[ _key2 ];
                    var array = [ ];
                    for ( var _i58 = 0, il = attributeArray.length; _i58 < il; _i58++ ) {
                        var _attribute2 = attributeArray[ _i58 ];
                        array.push( _attribute2.toJSON( data.data ) );
                    }
                    if ( array.length > 0 ) {
                        morphAttributes[ _key2 ] = array;
                        hasMorphAttributes = true;
                    }
                }
                if ( hasMorphAttributes ) {
                    data.data.morphAttributes = morphAttributes;
                    data.data.morphTargetsRelative = this.morphTargetsRelative;
                }
                var groups = this.groups;
                if ( groups.length > 0 ) {
                    data.data.groups = JSON.parse( JSON.stringify( groups ) );
                }
                var boundingSphere = this.boundingSphere;
                if ( boundingSphere !== null ) {
                    data.data.boundingSphere = {
                        center: boundingSphere.center.toArray( ),
                        radius: boundingSphere.radius
                    };
                }
                return data;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( source ) { // reset
                this.index = null;
                this.attributes = {};
                this.morphAttributes = {};
                this.groups = [ ];
                this.boundingBox = null;
                this.boundingSphere = null; // used for storing cloned, shared data
                var data = {}; // name
                this.name = source.name; // index
                var index = source.index;
                if ( index !== null ) {
                    this.setIndex( index.clone( data ) );
                } // attributes
                var attributes = source.attributes;
                for ( var name in attributes ) {
                    var attribute = attributes[ name ];
                    this.setAttribute( name, attribute.clone( data ) );
                } // morph attributes
                var morphAttributes = source.morphAttributes;
                for ( var _name2 in morphAttributes ) {
                    var array = [ ];
                    var morphAttribute = morphAttributes[ _name2 ]; // morphAttribute: array of Float32BufferAttributes
                    for ( var _i59 = 0, l = morphAttribute.length; _i59 < l; _i59++ ) {
                        array.push( morphAttribute[ _i59 ].clone( data ) );
                    }
                    this.morphAttributes[ _name2 ] = array;
                }
                this.morphTargetsRelative = source.morphTargetsRelative; // groups
                var groups = source.groups;
                for ( var _i60 = 0, _l4 = groups.length; _i60 < _l4; _i60++ ) {
                    var group = groups[ _i60 ];
                    this.addGroup( group.start, group.count, group.materialIndex );
                } // bounding box
                var boundingBox = source.boundingBox;
                if ( boundingBox !== null ) {
                    this.boundingBox = boundingBox.clone( );
                } // bounding sphere
                var boundingSphere = source.boundingSphere;
                if ( boundingSphere !== null ) {
                    this.boundingSphere = boundingSphere.clone( );
                } // draw range
                this.drawRange.start = source.drawRange.start;
                this.drawRange.count = source.drawRange.count; // user data
                this.userData = source.userData; // geometry generator parameters
                if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );
                return this;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.dispatchEvent( {
                    type: 'dispose'
                } );
            }
        } ] );
        return BufferGeometry;
    }( EventDispatcher );
    var _inverseMatrix$2 = /*@__PURE__*/ new Matrix4( );
    var _ray$2 = /*@__PURE__*/ new Ray$1( );
    var _sphere$3 = /*@__PURE__*/ new Sphere( );
    var _vA$1 = /*@__PURE__*/ new Vector3( );
    var _vB$1 = /*@__PURE__*/ new Vector3( );
    var _vC$1 = /*@__PURE__*/ new Vector3( );
    var _tempA = /*@__PURE__*/ new Vector3( );
    var _tempB = /*@__PURE__*/ new Vector3( );
    var _tempC = /*@__PURE__*/ new Vector3( );
    var _morphA = /*@__PURE__*/ new Vector3( );
    var _morphB = /*@__PURE__*/ new Vector3( );
    var _morphC = /*@__PURE__*/ new Vector3( );
    var _uvA$1 = /*@__PURE__*/ new Vector2( );
    var _uvB$1 = /*@__PURE__*/ new Vector2( );
    var _uvC$1 = /*@__PURE__*/ new Vector2( );
    var _intersectionPoint = /*@__PURE__*/ new Vector3( );
    var _intersectionPointWorld = /*@__PURE__*/ new Vector3( );
    var Mesh = /*#__PURE__*/ function( _Object3D ) {
        _inherits( Mesh, _Object3D );
        var _super12 = _createSuper( Mesh );

        function Mesh( ) {
            var _this10;
            var geometry = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new BufferGeometry( );
            var material = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new MeshBasicMaterial( );
            _classCallCheck( this, Mesh );
            _this10 = _super12.call( this );
            _this10.isMesh = true;
            _this10.type = 'Mesh';
            _this10.geometry = geometry;
            _this10.material = material;
            _this10.updateMorphTargets( );
            return _this10;
        }
        _createClass( Mesh, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Mesh.prototype ), "copy", this ).call( this, source, recursive );
                if ( source.morphTargetInfluences !== undefined ) {
                    this.morphTargetInfluences = source.morphTargetInfluences.slice( );
                }
                if ( source.morphTargetDictionary !== undefined ) {
                    this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );
                }
                this.material = source.material;
                this.geometry = source.geometry;
                return this;
            }
        }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets( ) {
                var geometry = this.geometry;
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys( morphAttributes );
                if ( keys.length > 0 ) {
                    var morphAttribute = morphAttributes[ keys[ 0 ] ];
                    if ( morphAttribute !== undefined ) {
                        this.morphTargetInfluences = [ ];
                        this.morphTargetDictionary = {};
                        for ( var m = 0, ml = morphAttribute.length; m < ml; m++ ) {
                            var name = morphAttribute[ m ].name || String( m );
                            this.morphTargetInfluences.push( 0 );
                            this.morphTargetDictionary[ name ] = m;
                        }
                    }
                }
            }
        }, {
            key: "raycast",
            value: function raycast( raycaster, intersects ) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if ( material === undefined ) return; // Checking boundingSphere distance to ray
                if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere( );
                _sphere$3.copy( geometry.boundingSphere );
                _sphere$3.applyMatrix4( matrixWorld );
                if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return; //
                _inverseMatrix$2.copy( matrixWorld ).invert( );
                _ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 ); // Check boundingBox before continuing
                if ( geometry.boundingBox !== null ) {
                    if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;
                }
                var intersection;
                var index = geometry.index;
                var position = geometry.attributes.position;
                var morphPosition = geometry.morphAttributes.position;
                var morphTargetsRelative = geometry.morphTargetsRelative;
                var uv = geometry.attributes.uv;
                var uv2 = geometry.attributes.uv2;
                var groups = geometry.groups;
                var drawRange = geometry.drawRange;
                if ( index !== null ) { // indexed buffer geometry
                    if ( Array.isArray( material ) ) {
                        for ( var _i61 = 0, il = groups.length; _i61 < il; _i61++ ) {
                            var group = groups[ _i61 ];
                            var groupMaterial = material[ group.materialIndex ];
                            var start = Math.max( group.start, drawRange.start );
                            var end = Math.min( index.count, Math.min( group.start + group.count, drawRange.start + drawRange.count ) );
                            for ( var j = start, jl = end; j < jl; j += 3 ) {
                                var _a2 = index.getX( j );
                                var _b2 = index.getX( j + 1 );
                                var _c2 = index.getX( j + 2 );
                                intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2 );
                                if ( intersection ) {
                                    intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
                                    intersection.face.materialIndex = group.materialIndex;
                                    intersects.push( intersection );
                                }
                            }
                        }
                    } else {
                        var _start3 = Math.max( 0, drawRange.start );
                        var _end2 = Math.min( index.count, drawRange.start + drawRange.count );
                        for ( var _i62 = _start3, _il6 = _end2; _i62 < _il6; _i62 += 3 ) {
                            var _a3 = index.getX( _i62 );
                            var _b3 = index.getX( _i62 + 1 );
                            var _c3 = index.getX( _i62 + 2 );
                            intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3 );
                            if ( intersection ) {
                                intersection.faceIndex = Math.floor( _i62 / 3 ); // triangle number in indexed buffer semantics
                                intersects.push( intersection );
                            }
                        }
                    }
                } else if ( position !== undefined ) { // non-indexed buffer geometry
                    if ( Array.isArray( material ) ) {
                        for ( var _i63 = 0, _il7 = groups.length; _i63 < _il7; _i63++ ) {
                            var _group3 = groups[ _i63 ];
                            var _groupMaterial = material[ _group3.materialIndex ];
                            var _start4 = Math.max( _group3.start, drawRange.start );
                            var _end3 = Math.min( position.count, Math.min( _group3.start + _group3.count, drawRange.start + drawRange.count ) );
                            for ( var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3 ) {
                                var _a4 = _j2;
                                var _b4 = _j2 + 1;
                                var _c4 = _j2 + 2;
                                intersection = checkBufferGeometryIntersection( this, _groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a4, _b4, _c4 );
                                if ( intersection ) {
                                    intersection.faceIndex = Math.floor( _j2 / 3 ); // triangle number in non-indexed buffer semantics
                                    intersection.face.materialIndex = _group3.materialIndex;
                                    intersects.push( intersection );
                                }
                            }
                        }
                    } else {
                        var _start5 = Math.max( 0, drawRange.start );
                        var _end4 = Math.min( position.count, drawRange.start + drawRange.count );
                        for ( var _i64 = _start5, _il8 = _end4; _i64 < _il8; _i64 += 3 ) {
                            var _a5 = _i64;
                            var _b5 = _i64 + 1;
                            var _c5 = _i64 + 2;
                            intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a5, _b5, _c5 );
                            if ( intersection ) {
                                intersection.faceIndex = Math.floor( _i64 / 3 ); // triangle number in non-indexed buffer semantics
                                intersects.push( intersection );
                            }
                        }
                    }
                }
            }
        } ] );
        return Mesh;
    }( Object3D );

    function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {
        var intersect;
        if ( material.side === BackSide ) {
            intersect = ray.intersectTriangle( pC, pB, pA, true, point );
        } else {
            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
        }
        if ( intersect === null ) return null;
        _intersectionPointWorld.copy( point );
        _intersectionPointWorld.applyMatrix4( object.matrixWorld );
        var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );
        if ( distance < raycaster.near || distance > raycaster.far ) return null;
        return {
            distance: distance,
            point: _intersectionPointWorld.clone( ),
            object: object
        };
    }

    function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {
        _vA$1.fromBufferAttribute( position, a );
        _vB$1.fromBufferAttribute( position, b );
        _vC$1.fromBufferAttribute( position, c );
        var morphInfluences = object.morphTargetInfluences;
        if ( morphPosition && morphInfluences ) {
            _morphA.set( 0, 0, 0 );
            _morphB.set( 0, 0, 0 );
            _morphC.set( 0, 0, 0 );
            for ( var _i65 = 0, il = morphPosition.length; _i65 < il; _i65++ ) {
                var influence = morphInfluences[ _i65 ];
                var morphAttribute = morphPosition[ _i65 ];
                if ( influence === 0 ) continue;
                _tempA.fromBufferAttribute( morphAttribute, a );
                _tempB.fromBufferAttribute( morphAttribute, b );
                _tempC.fromBufferAttribute( morphAttribute, c );
                if ( morphTargetsRelative ) {
                    _morphA.addScaledVector( _tempA, influence );
                    _morphB.addScaledVector( _tempB, influence );
                    _morphC.addScaledVector( _tempC, influence );
                } else {
                    _morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
                    _morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
                    _morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );
                }
            }
            _vA$1.add( _morphA );
            _vB$1.add( _morphB );
            _vC$1.add( _morphC );
        }
        if ( object.isSkinnedMesh ) {
            object.boneTransform( a, _vA$1 );
            object.boneTransform( b, _vB$1 );
            object.boneTransform( c, _vC$1 );
        }
        var intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );
        if ( intersection ) {
            if ( uv ) {
                _uvA$1.fromBufferAttribute( uv, a );
                _uvB$1.fromBufferAttribute( uv, b );
                _uvC$1.fromBufferAttribute( uv, c );
                intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2( ) );
            }
            if ( uv2 ) {
                _uvA$1.fromBufferAttribute( uv2, a );
                _uvB$1.fromBufferAttribute( uv2, b );
                _uvC$1.fromBufferAttribute( uv2, c );
                intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2( ) );
            }
            var face = {
                a: a,
                b: b,
                c: c,
                normal: new Vector3( ),
                materialIndex: 0
            };
            Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );
            intersection.face = face;
        }
        return intersection;
    }
    var BoxGeometry = /*#__PURE__*/ function( _BufferGeometry ) {
        _inherits( BoxGeometry, _BufferGeometry );
        var _super13 = _createSuper( BoxGeometry );

        function BoxGeometry( ) {
            var _this11;
            var width = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 1;
            var height = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var depth = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var widthSegments = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            var heightSegments = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : 1;
            var depthSegments = arguments.length > 5 && arguments[ 5 ] !== undefined ? arguments[ 5 ] : 1;
            _classCallCheck( this, BoxGeometry );
            _this11 = _super13.call( this );
            _this11.type = 'BoxGeometry';
            _this11.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            var scope = _assertThisInitialized( _this11 ); // segments
            widthSegments = Math.floor( widthSegments );
            heightSegments = Math.floor( heightSegments );
            depthSegments = Math.floor( depthSegments ); // buffers
            var indices = [ ];
            var vertices = [ ];
            var normals = [ ];
            var uvs = [ ]; // helper variables
            var numberOfVertices = 0;
            var groupStart = 0; // build each side of the box geometry
            buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
            buildPlane( 'z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1 ); // nx
            buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
            buildPlane( 'x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3 ); // ny
            buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
            buildPlane( 'x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5 ); // nz
            // build geometry
            _this11.setIndex( indices );
            _this11.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
            _this11.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
            _this11.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

            function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCounter = 0;
                var groupCount = 0;
                var vector = new Vector3( ); // generate vertices, normals and uvs
                for ( var iy = 0; iy < gridY1; iy++ ) {
                    var y = iy * segmentHeight - heightHalf;
                    for ( var ix = 0; ix < gridX1; ix++ ) {
                        var _x4 = ix * segmentWidth - widthHalf; // set values to correct vector component
                        vector[ u ] = _x4 * udir;
                        vector[ v ] = y * vdir;
                        vector[ w ] = depthHalf; // now apply vector to vertex buffer
                        vertices.push( vector.x, vector.y, vector.z ); // set values to correct vector component
                        vector[ u ] = 0;
                        vector[ v ] = 0;
                        vector[ w ] = depth > 0 ? 1 : -1; // now apply vector to normal buffer
                        normals.push( vector.x, vector.y, vector.z ); // uvs
                        uvs.push( ix / gridX );
                        uvs.push( 1 - iy / gridY ); // counters
                        vertexCounter += 1;
                    }
                } // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for ( var _iy = 0; _iy < gridY; _iy++ ) {
                    for ( var _ix = 0; _ix < gridX; _ix++ ) {
                        var _a6 = numberOfVertices + _ix + gridX1 * _iy;
                        var _b6 = numberOfVertices + _ix + gridX1 * ( _iy + 1 );
                        var _c6 = numberOfVertices + ( _ix + 1 ) + gridX1 * ( _iy + 1 );
                        var d = numberOfVertices + ( _ix + 1 ) + gridX1 * _iy; // faces
                        indices.push( _a6, _b6, d );
                        indices.push( _b6, _c6, d ); // increase counter
                        groupCount += 6;
                    }
                } // add a group to the geometry. this will ensure multi material support
                scope.addGroup( groupStart, groupCount, materialIndex ); // calculate new start value for groups
                groupStart += groupCount; // update total number of vertices
                numberOfVertices += vertexCounter;
            }
            return _this11;
        }
        _createClass( BoxGeometry, null, [ {
            key: "fromJSON",
            value: function fromJSON( data ) {
                return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );
            }
        } ] );
        return BoxGeometry;
    }( BufferGeometry );
    /**
     * Uniform Utilities
     */
    function cloneUniforms( src ) {
        var dst = {};
        for ( var u in src ) {
            dst[ u ] = {};
            for ( var p in src[ u ] ) {
                var property = src[ u ][ p ];
                if ( property && ( property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion ) ) {
                    dst[ u ][ p ] = property.clone( );
                } else if ( Array.isArray( property ) ) {
                    dst[ u ][ p ] = property.slice( );
                } else {
                    dst[ u ][ p ] = property;
                }
            }
        }
        return dst;
    }

    function mergeUniforms( uniforms ) {
        var merged = {};
        for ( var u = 0; u < uniforms.length; u++ ) {
            var _tmp = cloneUniforms( uniforms[ u ] );
            for ( var p in _tmp ) {
                merged[ p ] = _tmp[ p ];
            }
        }
        return merged;
    } // Legacy
    var UniformsUtils = {
        clone: cloneUniforms,
        merge: mergeUniforms
    };
    var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    var ShaderMaterial = /*#__PURE__*/ function( _Material$2 ) {
        _inherits( ShaderMaterial, _Material$2 );
        var _super14 = _createSuper( ShaderMaterial );

        function ShaderMaterial( parameters ) {
            var _this12;
            _classCallCheck( this, ShaderMaterial );
            _this12 = _super14.call( this );
            _this12.isShaderMaterial = true;
            _this12.type = 'ShaderMaterial';
            _this12.defines = {};
            _this12.uniforms = {};
            _this12.vertexShader = default_vertex;
            _this12.fragmentShader = default_fragment;
            _this12.linewidth = 1;
            _this12.wireframe = false;
            _this12.wireframeLinewidth = 1;
            _this12.fog = false; // set to use scene fog
            _this12.lights = false; // set to use scene lights
            _this12.clipping = false; // set to use user-defined clipping planes
            _this12.extensions = {
                derivatives: false, // set to use derivatives
                fragDepth: false, // set to use fragment depth values
                drawBuffers: false, // set to use draw buffers
                shaderTextureLOD: false // set to use shader texture LOD
            }; // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.
            _this12.defaultAttributeValues = {
                'color': [ 1, 1, 1 ],
                'uv': [ 0, 0 ],
                'uv2': [ 0, 0 ]
            };
            _this12.index0AttributeName = undefined;
            _this12.uniformsNeedUpdate = false;
            _this12.glslVersion = null;
            if ( parameters !== undefined ) {
                if ( parameters.attributes !== undefined ) {
                    console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
                }
                _this12.setValues( parameters );
            }
            return _this12;
        }
        _createClass( ShaderMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( ShaderMaterial.prototype ), "copy", this ).call( this, source );
                this.fragmentShader = source.fragmentShader;
                this.vertexShader = source.vertexShader;
                this.uniforms = cloneUniforms( source.uniforms );
                this.defines = Object.assign( {}, source.defines );
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.fog = source.fog;
                this.lights = source.lights;
                this.clipping = source.clipping;
                this.extensions = Object.assign( {}, source.extensions );
                this.glslVersion = source.glslVersion;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var data = _get( _getPrototypeOf( ShaderMaterial.prototype ), "toJSON", this ).call( this, meta );
                data.glslVersion = this.glslVersion;
                data.uniforms = {};
                for ( var name in this.uniforms ) {
                    var uniform = this.uniforms[ name ];
                    var _value = uniform.value;
                    if ( _value && _value.isTexture ) {
                        data.uniforms[ name ] = {
                            type: 't',
                            value: _value.toJSON( meta ).uuid
                        };
                    } else if ( _value && _value.isColor ) {
                        data.uniforms[ name ] = {
                            type: 'c',
                            value: _value.getHex( )
                        };
                    } else if ( _value && _value.isVector2 ) {
                        data.uniforms[ name ] = {
                            type: 'v2',
                            value: _value.toArray( )
                        };
                    } else if ( _value && _value.isVector3 ) {
                        data.uniforms[ name ] = {
                            type: 'v3',
                            value: _value.toArray( )
                        };
                    } else if ( _value && _value.isVector4 ) {
                        data.uniforms[ name ] = {
                            type: 'v4',
                            value: _value.toArray( )
                        };
                    } else if ( _value && _value.isMatrix3 ) {
                        data.uniforms[ name ] = {
                            type: 'm3',
                            value: _value.toArray( )
                        };
                    } else if ( _value && _value.isMatrix4 ) {
                        data.uniforms[ name ] = {
                            type: 'm4',
                            value: _value.toArray( )
                        };
                    } else {
                        data.uniforms[ name ] = {
                            value: _value
                        }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                    }
                }
                if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;
                data.vertexShader = this.vertexShader;
                data.fragmentShader = this.fragmentShader;
                var extensions = {};
                for ( var key in this.extensions ) {
                    if ( this.extensions[ key ] === true ) extensions[ key ] = true;
                }
                if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;
                return data;
            }
        } ] );
        return ShaderMaterial;
    }( Material$1 );
    var Camera = /*#__PURE__*/ function( _Object3D2 ) {
        _inherits( Camera, _Object3D2 );
        var _super15 = _createSuper( Camera );

        function Camera( ) {
            var _this13;
            _classCallCheck( this, Camera );
            _this13 = _super15.call( this );
            _this13.isCamera = true;
            _this13.type = 'Camera';
            _this13.matrixWorldInverse = new Matrix4( );
            _this13.projectionMatrix = new Matrix4( );
            _this13.projectionMatrixInverse = new Matrix4( );
            return _this13;
        }
        _createClass( Camera, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Camera.prototype ), "copy", this ).call( this, source, recursive );
                this.matrixWorldInverse.copy( source.matrixWorldInverse );
                this.projectionMatrix.copy( source.projectionMatrix );
                this.projectionMatrixInverse.copy( source.projectionMatrixInverse );
                return this;
            }
        }, {
            key: "getWorldDirection",
            value: function getWorldDirection( target ) {
                this.updateWorldMatrix( true, false );
                var e = this.matrixWorld.elements;
                return target.set( -e[ 8 ], -e[ 9 ], -e[ 10 ] ).normalize( );
            }
        }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld( force ) {
                _get( _getPrototypeOf( Camera.prototype ), "updateMatrixWorld", this ).call( this, force );
                this.matrixWorldInverse.copy( this.matrixWorld ).invert( );
            }
        }, {
            key: "updateWorldMatrix",
            value: function updateWorldMatrix( updateParents, updateChildren ) {
                _get( _getPrototypeOf( Camera.prototype ), "updateWorldMatrix", this ).call( this, updateParents, updateChildren );
                this.matrixWorldInverse.copy( this.matrixWorld ).invert( );
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        } ] );
        return Camera;
    }( Object3D );
    var PerspectiveCamera = /*#__PURE__*/ function( _Camera ) {
        _inherits( PerspectiveCamera, _Camera );
        var _super16 = _createSuper( PerspectiveCamera );

        function PerspectiveCamera( ) {
            var _this14;
            var fov = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 50;
            var aspect = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var near = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0.1;
            var far = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 2000;
            _classCallCheck( this, PerspectiveCamera );
            _this14 = _super16.call( this );
            _this14.isPerspectiveCamera = true;
            _this14.type = 'PerspectiveCamera';
            _this14.fov = fov;
            _this14.zoom = 1;
            _this14.near = near;
            _this14.far = far;
            _this14.focus = 10;
            _this14.aspect = aspect;
            _this14.view = null;
            _this14.filmGauge = 35; // width of the film (default in millimeters)
            _this14.filmOffset = 0; // horizontal film offset (same unit as gauge)
            _this14.updateProjectionMatrix( );
            return _this14;
        }
        _createClass( PerspectiveCamera, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( PerspectiveCamera.prototype ), "copy", this ).call( this, source, recursive );
                this.fov = source.fov;
                this.zoom = source.zoom;
                this.near = source.near;
                this.far = source.far;
                this.focus = source.focus;
                this.aspect = source.aspect;
                this.view = source.view === null ? null : Object.assign( {}, source.view );
                this.filmGauge = source.filmGauge;
                this.filmOffset = source.filmOffset;
                return this;
            }
            /**
             * Sets the FOV by focal length in respect to the current .filmGauge.
             *
             * The default film gauge is 35, so that the focal length can be specified for
             * a 35mm (full frame) camera.
             *
             * Values for focal length and film gauge must have the same unit.
             */
        }, {
            key: "setFocalLength",
            value: function setFocalLength( focalLength ) {
                /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
                var vExtentSlope = 0.5 * this.getFilmHeight( ) / focalLength;
                this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
                this.updateProjectionMatrix( );
            }
            /**
             * Calculates the focal length from the current .fov and .filmGauge.
             */
        }, {
            key: "getFocalLength",
            value: function getFocalLength( ) {
                var vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );
                return 0.5 * this.getFilmHeight( ) / vExtentSlope;
            }
        }, {
            key: "getEffectiveFOV",
            value: function getEffectiveFOV( ) {
                return RAD2DEG * 2 * Math.atan( Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );
            }
        }, {
            key: "getFilmWidth",
            value: function getFilmWidth( ) { // film not completely covered in portrait format (aspect < 1)
                return this.filmGauge * Math.min( this.aspect, 1 );
            }
        }, {
            key: "getFilmHeight",
            value: function getFilmHeight( ) { // film not completely covered in landscape format (aspect > 1)
                return this.filmGauge / Math.max( this.aspect, 1 );
            }
            /**
             * Sets an offset in a larger frustum. This is useful for multi-window or
             * multi-monitor/multi-machine setups.
             *
             * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
             * the monitors are in grid like this
             *
             *   +---+---+---+
             *   | A | B | C |
             *   +---+---+---+
             *   | D | E | F |
             *   +---+---+---+
             *
             * then for each monitor you would call it like this
             *
             *   const w = 1920;
             *   const h = 1080;
             *   const fullWidth = w * 3;
             *   const fullHeight = h * 2;
             *
             *   --A--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
             *   --B--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
             *   --C--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
             *   --D--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
             *   --E--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
             *   --F--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
             *
             *   Note there is no reason monitors have to be the same size or in a grid.
             */
        }, {
            key: "setViewOffset",
            value: function setViewOffset( fullWidth, fullHeight, x, y, width, height ) {
                this.aspect = fullWidth / fullHeight;
                if ( this.view === null ) {
                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };
                }
                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;
                this.updateProjectionMatrix( );
            }
        }, {
            key: "clearViewOffset",
            value: function clearViewOffset( ) {
                if ( this.view !== null ) {
                    this.view.enabled = false;
                }
                this.updateProjectionMatrix( );
            }
        }, {
            key: "updateProjectionMatrix",
            value: function updateProjectionMatrix( ) {
                var near = this.near;
                var top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
                var height = 2 * top;
                var width = this.aspect * height;
                var left = -0.5 * width;
                var view = this.view;
                if ( this.view !== null && this.view.enabled ) {
                    var fullWidth = view.fullWidth,
                        fullHeight = view.fullHeight;
                    left += view.offsetX * width / fullWidth;
                    top -= view.offsetY * height / fullHeight;
                    width *= view.width / fullWidth;
                    height *= view.height / fullHeight;
                }
                var skew = this.filmOffset;
                if ( skew !== 0 ) left += near * skew / this.getFilmWidth( );
                this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
                this.projectionMatrixInverse.copy( this.projectionMatrix ).invert( );
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var data = _get( _getPrototypeOf( PerspectiveCamera.prototype ), "toJSON", this ).call( this, meta );
                data.object.fov = this.fov;
                data.object.zoom = this.zoom;
                data.object.near = this.near;
                data.object.far = this.far;
                data.object.focus = this.focus;
                data.object.aspect = this.aspect;
                if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
                data.object.filmGauge = this.filmGauge;
                data.object.filmOffset = this.filmOffset;
                return data;
            }
        } ] );
        return PerspectiveCamera;
    }( Camera );
    var fov = 90,
        aspect = 1;
    var CubeCamera = /*#__PURE__*/ function( _Object3D3 ) {
        _inherits( CubeCamera, _Object3D3 );
        var _super17 = _createSuper( CubeCamera );

        function CubeCamera( near, far, renderTarget ) {
            var _this15;
            _classCallCheck( this, CubeCamera );
            _this15 = _super17.call( this );
            _this15.type = 'CubeCamera';
            if ( renderTarget.isWebGLCubeRenderTarget !== true ) {
                console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
                return _possibleConstructorReturn( _this15 );
            }
            _this15.renderTarget = renderTarget;
            var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
            cameraPX.layers = _this15.layers;
            cameraPX.up.set( 0, -1, 0 );
            cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
            _this15.add( cameraPX );
            var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
            cameraNX.layers = _this15.layers;
            cameraNX.up.set( 0, -1, 0 );
            cameraNX.lookAt( new Vector3( -1, 0, 0 ) );
            _this15.add( cameraNX );
            var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
            cameraPY.layers = _this15.layers;
            cameraPY.up.set( 0, 0, 1 );
            cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
            _this15.add( cameraPY );
            var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
            cameraNY.layers = _this15.layers;
            cameraNY.up.set( 0, 0, -1 );
            cameraNY.lookAt( new Vector3( 0, -1, 0 ) );
            _this15.add( cameraNY );
            var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
            cameraPZ.layers = _this15.layers;
            cameraPZ.up.set( 0, -1, 0 );
            cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
            _this15.add( cameraPZ );
            var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
            cameraNZ.layers = _this15.layers;
            cameraNZ.up.set( 0, -1, 0 );
            cameraNZ.lookAt( new Vector3( 0, 0, -1 ) );
            _this15.add( cameraNZ );
            return _this15;
        }
        _createClass( CubeCamera, [ {
            key: "update",
            value: function update( renderer, scene ) {
                if ( this.parent === null ) this.updateMatrixWorld( );
                var renderTarget = this.renderTarget;
                var _this$children = _slicedToArray( this.children, 6 ),
                    cameraPX = _this$children[ 0 ],
                    cameraNX = _this$children[ 1 ],
                    cameraPY = _this$children[ 2 ],
                    cameraNY = _this$children[ 3 ],
                    cameraPZ = _this$children[ 4 ],
                    cameraNZ = _this$children[ 5 ];
                var currentRenderTarget = renderer.getRenderTarget( );
                var currentToneMapping = renderer.toneMapping;
                var currentXrEnabled = renderer.xr.enabled;
                renderer.toneMapping = NoToneMapping;
                renderer.xr.enabled = false;
                var generateMipmaps = renderTarget.texture.generateMipmaps;
                renderTarget.texture.generateMipmaps = false;
                renderer.setRenderTarget( renderTarget, 0 );
                renderer.render( scene, cameraPX );
                renderer.setRenderTarget( renderTarget, 1 );
                renderer.render( scene, cameraNX );
                renderer.setRenderTarget( renderTarget, 2 );
                renderer.render( scene, cameraPY );
                renderer.setRenderTarget( renderTarget, 3 );
                renderer.render( scene, cameraNY );
                renderer.setRenderTarget( renderTarget, 4 );
                renderer.render( scene, cameraPZ );
                renderTarget.texture.generateMipmaps = generateMipmaps;
                renderer.setRenderTarget( renderTarget, 5 );
                renderer.render( scene, cameraNZ );
                renderer.setRenderTarget( currentRenderTarget );
                renderer.toneMapping = currentToneMapping;
                renderer.xr.enabled = currentXrEnabled;
                renderTarget.texture.needsPMREMUpdate = true;
            }
        } ] );
        return CubeCamera;
    }( Object3D );
    var CubeTexture = /*#__PURE__*/ function( _Texture3 ) {
        _inherits( CubeTexture, _Texture3 );
        var _super18 = _createSuper( CubeTexture );

        function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
            var _this16;
            _classCallCheck( this, CubeTexture );
            images = images !== undefined ? images : [ ];
            mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
            _this16 = _super18.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
            _this16.isCubeTexture = true;
            _this16.flipY = false;
            return _this16;
        }
        _createClass( CubeTexture, [ {
            key: "images",
            get: function get( ) {
                return this.image;
            },
            set: function set( value ) {
                this.image = value;
            }
        } ] );
        return CubeTexture;
    }( Texture );
    var WebGLCubeRenderTarget = /*#__PURE__*/ function( _WebGLRenderTarget ) {
        _inherits( WebGLCubeRenderTarget, _WebGLRenderTarget );
        var _super19 = _createSuper( WebGLCubeRenderTarget );

        function WebGLCubeRenderTarget( size ) {
            var _this17;
            var options = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : {};
            _classCallCheck( this, WebGLCubeRenderTarget );
            _this17 = _super19.call( this, size, size, options );
            _this17.isWebGLCubeRenderTarget = true;
            var image = {
                width: size,
                height: size,
                depth: 1
            };
            var images = [ image, image, image, image, image, image ];
            _this17.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding ); // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
            // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
            // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
            // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
            // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
            // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
            _this17.texture.isRenderTargetTexture = true;
            _this17.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
            _this17.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
            return _this17;
        }
        _createClass( WebGLCubeRenderTarget, [ {
            key: "fromEquirectangularTexture",
            value: function fromEquirectangularTexture( renderer, texture ) {
                this.texture.type = texture.type;
                this.texture.encoding = texture.encoding;
                this.texture.generateMipmaps = texture.generateMipmaps;
                this.texture.minFilter = texture.minFilter;
                this.texture.magFilter = texture.magFilter;
                var shader = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: /* glsl */ "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: /* glsl */ "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                };
                var geometry = new BoxGeometry( 5, 5, 5 );
                var material = new ShaderMaterial( {
                    name: 'CubemapFromEquirect',
                    uniforms: cloneUniforms( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader,
                    side: BackSide,
                    blending: NoBlending
                } );
                material.uniforms.tEquirect.value = texture;
                var mesh = new Mesh( geometry, material );
                var currentMinFilter = texture.minFilter; // Avoid blurred poles
                if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;
                var camera = new CubeCamera( 1, 10, this );
                camera.update( renderer, mesh );
                texture.minFilter = currentMinFilter;
                mesh.geometry.dispose( );
                mesh.material.dispose( );
                return this;
            }
        }, {
            key: "clear",
            value: function clear( renderer, color, depth, stencil ) {
                var currentRenderTarget = renderer.getRenderTarget( );
                for ( var _i66 = 0; _i66 < 6; _i66++ ) {
                    renderer.setRenderTarget( this, _i66 );
                    renderer.clear( color, depth, stencil );
                }
                renderer.setRenderTarget( currentRenderTarget );
            }
        } ] );
        return WebGLCubeRenderTarget;
    }( WebGLRenderTarget );
    var _vector1 = /*@__PURE__*/ new Vector3( );
    var _vector2 = /*@__PURE__*/ new Vector3( );
    var _normalMatrix = /*@__PURE__*/ new Matrix3( );
    var Plane = /*#__PURE__*/ function( ) {
        function Plane( ) {
            var normal = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Vector3( 1, 0, 0 );
            var constant = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            _classCallCheck( this, Plane );
            this.isPlane = true; // normal is assumed to be normalized
            this.normal = normal;
            this.constant = constant;
        }
        _createClass( Plane, [ {
            key: "set",
            value: function set( normal, constant ) {
                this.normal.copy( normal );
                this.constant = constant;
                return this;
            }
        }, {
            key: "setComponents",
            value: function setComponents( x, y, z, w ) {
                this.normal.set( x, y, z );
                this.constant = w;
                return this;
            }
        }, {
            key: "setFromNormalAndCoplanarPoint",
            value: function setFromNormalAndCoplanarPoint( normal, point ) {
                this.normal.copy( normal );
                this.constant = -point.dot( this.normal );
                return this;
            }
        }, {
            key: "setFromCoplanarPoints",
            value: function setFromCoplanarPoints( a, b, c ) {
                var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize( ); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
                this.setFromNormalAndCoplanarPoint( normal, a );
                return this;
            }
        }, {
            key: "copy",
            value: function copy( plane ) {
                this.normal.copy( plane.normal );
                this.constant = plane.constant;
                return this;
            }
        }, {
            key: "normalize",
            value: function normalize( ) { // Note: will lead to a divide by zero if the plane is invalid.
                var inverseNormalLength = 1.0 / this.normal.length( );
                this.normal.multiplyScalar( inverseNormalLength );
                this.constant *= inverseNormalLength;
                return this;
            }
        }, {
            key: "negate",
            value: function negate( ) {
                this.constant *= -1;
                this.normal.negate( );
                return this;
            }
        }, {
            key: "distanceToPoint",
            value: function distanceToPoint( point ) {
                return this.normal.dot( point ) + this.constant;
            }
        }, {
            key: "distanceToSphere",
            value: function distanceToSphere( sphere ) {
                return this.distanceToPoint( sphere.center ) - sphere.radius;
            }
        }, {
            key: "projectPoint",
            value: function projectPoint( point, target ) {
                return target.copy( this.normal ).multiplyScalar( -this.distanceToPoint( point ) ).add( point );
            }
        }, {
            key: "intersectLine",
            value: function intersectLine( line, target ) {
                var direction = line.delta( _vector1 );
                var denominator = this.normal.dot( direction );
                if ( denominator === 0 ) { // line is coplanar, return origin
                    if ( this.distanceToPoint( line.start ) === 0 ) {
                        return target.copy( line.start );
                    } // Unsure if this is the correct method to handle this case.
                    return null;
                }
                var t = -( line.start.dot( this.normal ) + this.constant ) / denominator;
                if ( t < 0 || t > 1 ) {
                    return null;
                }
                return target.copy( direction ).multiplyScalar( t ).add( line.start );
            }
        }, {
            key: "intersectsLine",
            value: function intersectsLine( line ) { // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
                var startSign = this.distanceToPoint( line.start );
                var endSign = this.distanceToPoint( line.end );
                return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) {
                return box.intersectsPlane( this );
            }
        }, {
            key: "intersectsSphere",
            value: function intersectsSphere( sphere ) {
                return sphere.intersectsPlane( this );
            }
        }, {
            key: "coplanarPoint",
            value: function coplanarPoint( target ) {
                return target.copy( this.normal ).multiplyScalar( -this.constant );
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( matrix, optionalNormalMatrix ) {
                var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );
                var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );
                var normal = this.normal.applyMatrix3( normalMatrix ).normalize( );
                this.constant = -referencePoint.dot( normal );
                return this;
            }
        }, {
            key: "translate",
            value: function translate( offset ) {
                this.constant -= offset.dot( this.normal );
                return this;
            }
        }, {
            key: "equals",
            value: function equals( plane ) {
                return plane.normal.equals( this.normal ) && plane.constant === this.constant;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        } ] );
        return Plane;
    }( );
    var _sphere$2 = /*@__PURE__*/ new Sphere( );
    var _vector$7 = /*@__PURE__*/ new Vector3( );
    var Frustum = /*#__PURE__*/ function( ) {
        function Frustum( ) {
            var p0 = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new Plane( );
            var p1 = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new Plane( );
            var p2 = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : new Plane( );
            var p3 = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : new Plane( );
            var p4 = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : new Plane( );
            var p5 = arguments.length > 5 && arguments[ 5 ] !== undefined ? arguments[ 5 ] : new Plane( );
            _classCallCheck( this, Frustum );
            this.planes = [ p0, p1, p2, p3, p4, p5 ];
        }
        _createClass( Frustum, [ {
            key: "set",
            value: function set( p0, p1, p2, p3, p4, p5 ) {
                var planes = this.planes;
                planes[ 0 ].copy( p0 );
                planes[ 1 ].copy( p1 );
                planes[ 2 ].copy( p2 );
                planes[ 3 ].copy( p3 );
                planes[ 4 ].copy( p4 );
                planes[ 5 ].copy( p5 );
                return this;
            }
        }, {
            key: "copy",
            value: function copy( frustum ) {
                var planes = this.planes;
                for ( var _i67 = 0; _i67 < 6; _i67++ ) {
                    planes[ _i67 ].copy( frustum.planes[ _i67 ] );
                }
                return this;
            }
        }, {
            key: "setFromProjectionMatrix",
            value: function setFromProjectionMatrix( m ) {
                var planes = this.planes;
                var me = m.elements;
                var me0 = me[ 0 ],
                    me1 = me[ 1 ],
                    me2 = me[ 2 ],
                    me3 = me[ 3 ];
                var me4 = me[ 4 ],
                    me5 = me[ 5 ],
                    me6 = me[ 6 ],
                    me7 = me[ 7 ];
                var me8 = me[ 8 ],
                    me9 = me[ 9 ],
                    me10 = me[ 10 ],
                    me11 = me[ 11 ];
                var me12 = me[ 12 ],
                    me13 = me[ 13 ],
                    me14 = me[ 14 ],
                    me15 = me[ 15 ];
                planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize( );
                planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize( );
                planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize( );
                planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize( );
                planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize( );
                planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize( );
                return this;
            }
        }, {
            key: "intersectsObject",
            value: function intersectsObject( object ) {
                var geometry = object.geometry;
                if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere( );
                _sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );
                return this.intersectsSphere( _sphere$2 );
            }
        }, {
            key: "intersectsSprite",
            value: function intersectsSprite( sprite ) {
                _sphere$2.center.set( 0, 0, 0 );
                _sphere$2.radius = 0.7071067811865476;
                _sphere$2.applyMatrix4( sprite.matrixWorld );
                return this.intersectsSphere( _sphere$2 );
            }
        }, {
            key: "intersectsSphere",
            value: function intersectsSphere( sphere ) {
                var planes = this.planes;
                var center = sphere.center;
                var negRadius = -sphere.radius;
                for ( var _i68 = 0; _i68 < 6; _i68++ ) {
                    var distance = planes[ _i68 ].distanceToPoint( center );
                    if ( distance < negRadius ) {
                        return false;
                    }
                }
                return true;
            }
        }, {
            key: "intersectsBox",
            value: function intersectsBox( box ) {
                var planes = this.planes;
                for ( var _i69 = 0; _i69 < 6; _i69++ ) {
                    var plane = planes[ _i69 ]; // corner at max distance
                    _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    if ( plane.distanceToPoint( _vector$7 ) < 0 ) {
                        return false;
                    }
                }
                return true;
            }
        }, {
            key: "containsPoint",
            value: function containsPoint( point ) {
                var planes = this.planes;
                for ( var _i70 = 0; _i70 < 6; _i70++ ) {
                    if ( planes[ _i70 ].distanceToPoint( point ) < 0 ) {
                        return false;
                    }
                }
                return true;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        } ] );
        return Frustum;
    }( );

    function WebGLAnimation( ) {
        var context = null;
        var isAnimating = false;
        var animationLoop = null;
        var requestId = null;

        function onAnimationFrame( time, frame ) {
            animationLoop( time, frame );
            requestId = context.requestAnimationFrame( onAnimationFrame );
        }
        return {
            start: function start( ) {
                if ( isAnimating === true ) return;
                if ( animationLoop === null ) return;
                requestId = context.requestAnimationFrame( onAnimationFrame );
                isAnimating = true;
            },
            stop: function stop( ) {
                context.cancelAnimationFrame( requestId );
                isAnimating = false;
            },
            setAnimationLoop: function setAnimationLoop( callback ) {
                animationLoop = callback;
            },
            setContext: function setContext( value ) {
                context = value;
            }
        };
    }

    function WebGLAttributes( gl, capabilities ) {
        var isWebGL2 = capabilities.isWebGL2;
        var buffers = new WeakMap( );

        function createBuffer( attribute, bufferType ) {
            var array = attribute.array;
            var usage = attribute.usage;
            var buffer = gl.createBuffer( );
            gl.bindBuffer( bufferType, buffer );
            gl.bufferData( bufferType, array, usage );
            attribute.onUploadCallback( );
            var type;
            if ( array instanceof Float32Array ) {
                type = 5126;
            } else if ( array instanceof Uint16Array ) {
                if ( attribute.isFloat16BufferAttribute ) {
                    if ( isWebGL2 ) {
                        type = 5131;
                    } else {
                        throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );
                    }
                } else {
                    type = 5123;
                }
            } else if ( array instanceof Int16Array ) {
                type = 5122;
            } else if ( array instanceof Uint32Array ) {
                type = 5125;
            } else if ( array instanceof Int32Array ) {
                type = 5124;
            } else if ( array instanceof Int8Array ) {
                type = 5120;
            } else if ( array instanceof Uint8Array ) {
                type = 5121;
            } else if ( array instanceof Uint8ClampedArray ) {
                type = 5121;
            } else {
                throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );
            }
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }

        function updateBuffer( buffer, attribute, bufferType ) {
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer( bufferType, buffer );
            if ( updateRange.count === -1 ) { // Not using update ranges
                gl.bufferSubData( bufferType, 0, array );
            } else {
                if ( isWebGL2 ) {
                    gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count );
                } else {
                    gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
                }
                updateRange.count = -1; // reset range
            }
        } //
        function get( attribute ) {
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
            return buffers.get( attribute );
        }

        function remove( attribute ) {
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
            var data = buffers.get( attribute );
            if ( data ) {
                gl.deleteBuffer( data.buffer );
                buffers[ "delete" ]( attribute );
            }
        }

        function update( attribute, bufferType ) {
            if ( attribute.isGLBufferAttribute ) {
                var cached = buffers.get( attribute );
                if ( !cached || cached.version < attribute.version ) {
                    buffers.set( attribute, {
                        buffer: attribute.buffer,
                        type: attribute.type,
                        bytesPerElement: attribute.elementSize,
                        version: attribute.version
                    } );
                }
                return;
            }
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
            var data = buffers.get( attribute );
            if ( data === undefined ) {
                buffers.set( attribute, createBuffer( attribute, bufferType ) );
            } else if ( data.version < attribute.version ) {
                updateBuffer( data.buffer, attribute, bufferType );
                data.version = attribute.version;
            }
        }
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    var PlaneGeometry = /*#__PURE__*/ function( _BufferGeometry2 ) {
        _inherits( PlaneGeometry, _BufferGeometry2 );
        var _super20 = _createSuper( PlaneGeometry );

        function PlaneGeometry( ) {
            var _this18;
            var width = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 1;
            var height = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var widthSegments = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var heightSegments = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, PlaneGeometry );
            _this18 = _super20.call( this );
            _this18.type = 'PlaneGeometry';
            _this18.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor( widthSegments );
            var gridY = Math.floor( heightSegments );
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY; //
            var indices = [ ];
            var vertices = [ ];
            var normals = [ ];
            var uvs = [ ];
            for ( var iy = 0; iy < gridY1; iy++ ) {
                var y = iy * segment_height - height_half;
                for ( var ix = 0; ix < gridX1; ix++ ) {
                    var _x5 = ix * segment_width - width_half;
                    vertices.push( _x5, -y, 0 );
                    normals.push( 0, 0, 1 );
                    uvs.push( ix / gridX );
                    uvs.push( 1 - iy / gridY );
                }
            }
            for ( var _iy2 = 0; _iy2 < gridY; _iy2++ ) {
                for ( var _ix2 = 0; _ix2 < gridX; _ix2++ ) {
                    var _a7 = _ix2 + gridX1 * _iy2;
                    var _b7 = _ix2 + gridX1 * ( _iy2 + 1 );
                    var _c7 = _ix2 + 1 + gridX1 * ( _iy2 + 1 );
                    var d = _ix2 + 1 + gridX1 * _iy2;
                    indices.push( _a7, _b7, d );
                    indices.push( _b7, _c7, d );
                }
            }
            _this18.setIndex( indices );
            _this18.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
            _this18.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
            _this18.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
            return _this18;
        }
        _createClass( PlaneGeometry, null, [ {
            key: "fromJSON",
            value: function fromJSON( data ) {
                return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );
            }
        } ] );
        return PlaneGeometry;
    }( BufferGeometry );
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
    var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "vec3 transformed = vec3( position );";
    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
    var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";
    var iridescence_fragment = "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
    var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
    var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
    var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
    var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";
    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";
    var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
    var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
    var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
    var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
    var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
    var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
    var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
    var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";
    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
    var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
    var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
    var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
    var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
    var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
    var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
    var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
    var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
    var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
    var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
    var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
    var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        alphatest_pars_fragment: alphatest_pars_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        iridescence_fragment: iridescence_fragment,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_common_pars_fragment: envmap_common_pars_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_physical_pars_fragment: envmap_physical_pars_fragment,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars_begin: lights_pars_begin,
        lights_toon_fragment: lights_toon_fragment,
        lights_toon_pars_fragment: lights_toon_pars_fragment,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_fragment_begin: lights_fragment_begin,
        lights_fragment_maps: lights_fragment_maps,
        lights_fragment_end: lights_fragment_end,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphcolor_vertex: morphcolor_vertex,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment_begin: normal_fragment_begin,
        normal_fragment_maps: normal_fragment_maps,
        normal_pars_fragment: normal_pars_fragment,
        normal_pars_vertex: normal_pars_vertex,
        normal_vertex: normal_vertex,
        normalmap_pars_fragment: normalmap_pars_fragment,
        clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment: clearcoat_pars_fragment,
        iridescence_pars_fragment: iridescence_pars_fragment,
        output_fragment: output_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        transmission_fragment: transmission_fragment,
        transmission_pars_fragment: transmission_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        background_vert: vertex$g,
        background_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
    };
    /**
     * Uniforms library for shared webgl shaders
     */
    var UniformsLib = {
        common: {
            diffuse: {
                value: /*@__PURE__*/ new Color( 0xffffff )
            },
            opacity: {
                value: 1.0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: /*@__PURE__*/ new Matrix3( )
            },
            uv2Transform: {
                value: /*@__PURE__*/ new Matrix3( )
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1.0
            }, // basic, lambert, phong
            ior: {
                value: 1.5
            }, // physical
            refractionRatio: {
                value: 0.98
            } // basic, lambert, phong
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: /*@__PURE__*/ new Vector2( 1, 1 )
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 0.00025
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2000
            },
            fogColor: {
                value: /*@__PURE__*/ new Color( 0xffffff )
            }
        },
        lights: {
            ambientLightColor: {
                value: [ ]
            },
            lightProbe: {
                value: [ ]
            },
            directionalLights: {
                value: [ ],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [ ],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: [ ]
            },
            directionalShadowMatrix: {
                value: [ ]
            },
            spotLights: {
                value: [ ],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [ ],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: [ ]
            },
            spotShadowMatrix: {
                value: [ ]
            },
            pointLights: {
                value: [ ],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [ ],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: [ ]
            },
            pointShadowMatrix: {
                value: [ ]
            },
            hemisphereLights: {
                value: [ ],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            }, // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: {
                value: [ ],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: /*@__PURE__*/ new Color( 0xffffff )
            },
            opacity: {
                value: 1.0
            },
            size: {
                value: 1.0
            },
            scale: {
                value: 1.0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: /*@__PURE__*/ new Matrix3( )
            }
        },
        sprite: {
            diffuse: {
                value: /*@__PURE__*/ new Color( 0xffffff )
            },
            opacity: {
                value: 1.0
            },
            center: {
                value: /*@__PURE__*/ new Vector2( 0.5, 0.5 )
            },
            rotation: {
                value: 0.0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: /*@__PURE__*/ new Matrix3( )
            }
        }
    };
    var ShaderLib = {
        basic: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog ] ),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: /*@__PURE__*/ new Color( 0x000000 )
                }
            } ] ),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: /*@__PURE__*/ new Color( 0x000000 )
                },
                specular: {
                    value: /*@__PURE__*/ new Color( 0x111111 )
                },
                shininess: {
                    value: 30
                }
            } ] ),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: /*@__PURE__*/ new Color( 0x000000 )
                },
                roughness: {
                    value: 1.0
                },
                metalness: {
                    value: 0.0
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            } ] ),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: /*@__PURE__*/ new Color( 0x000000 )
                }
            } ] ),
            vertexShader: ShaderChunk.meshtoon_vert,
            fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
                matcap: {
                    value: null
                }
            } ] ),
            vertexShader: ShaderChunk.meshmatcap_vert,
            fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.points, UniformsLib.fog ] ),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ] ),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.displacementmap ] ),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1.0
                }
            } ] ),
            vertexShader: ShaderChunk.meshnormal_vert,
            fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.sprite, UniformsLib.fog ] ),
            vertexShader: ShaderChunk.sprite_vert,
            fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: /*@__PURE__*/ new Matrix3( )
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.background_vert,
            fragmentShader: ShaderChunk.background_frag
        },
        cube: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.envmap, {
                opacity: {
                    value: 1.0
                }
            } ] ),
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.common, UniformsLib.displacementmap, {
                referencePosition: {
                    value: /*@__PURE__*/ new Vector3( )
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            } ] ),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: /*@__PURE__*/ mergeUniforms( [ UniformsLib.lights, UniformsLib.fog, {
                color: {
                    value: /*@__PURE__*/ new Color( 0x00000 )
                },
                opacity: {
                    value: 1.0
                }
            } ] ),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: /*@__PURE__*/ mergeUniforms( [ ShaderLib.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: /*@__PURE__*/ new Vector2( 1, 1 )
            },
            clearcoatNormalMap: {
                value: null
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: /*@__PURE__*/ new Color( 0x000000 )
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: /*@__PURE__*/ new Vector2( )
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: /*@__PURE__*/ new Color( 0x000000 )
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: /*@__PURE__*/ new Color( 1, 1, 1 )
            },
            specularColorMap: {
                value: null
            }
        } ] ),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    };

    function WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {
        var clearColor = new Color( 0x000000 );
        var clearAlpha = alpha === true ? 0 : 1;
        var planeMesh;
        var boxMesh;
        var currentBackground = null;
        var currentBackgroundVersion = 0;
        var currentTonemapping = null;

        function render( renderList, scene ) {
            var forceClear = false;
            var background = scene.isScene === true ? scene.background : null;
            if ( background && background.isTexture ) {
                background = cubemaps.get( background );
            } // Ignore background in AR
            // TODO: Reconsider this.
            var xr = renderer.xr;
            var session = xr.getSession && xr.getSession( );
            if ( session && session.environmentBlendMode === 'additive' ) {
                background = null;
            }
            if ( background === null ) {
                setClear( clearColor, clearAlpha );
            } else if ( background && background.isColor ) {
                setClear( background, 1 );
                forceClear = true;
            }
            if ( renderer.autoClear || forceClear ) {
                renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
            }
            if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {
                if ( boxMesh === undefined ) {
                    boxMesh = new Mesh( new BoxGeometry( 1, 1, 1 ), new ShaderMaterial( {
                        name: 'BackgroundCubeMaterial',
                        uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    } ) );
                    boxMesh.geometry.deleteAttribute( 'normal' );
                    boxMesh.geometry.deleteAttribute( 'uv' );
                    boxMesh.onBeforeRender = function( renderer, scene, camera ) {
                        this.matrixWorld.copyPosition( camera.matrixWorld );
                    }; // enable code injection for non-built-in material
                    Object.defineProperty( boxMesh.material, 'envMap', {
                        get: function get( ) {
                            return this.uniforms.envMap.value;
                        }
                    } );
                    objects.update( boxMesh );
                }
                boxMesh.material.uniforms.envMap.value = background;
                boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
                if ( currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping ) {
                    boxMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
                }
                boxMesh.layers.enableAll( ); // push to the pre-sorted opaque render list
                renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );
            } else if ( background && background.isTexture ) {
                if ( planeMesh === undefined ) {
                    planeMesh = new Mesh( new PlaneGeometry( 2, 2 ), new ShaderMaterial( {
                        name: 'BackgroundMaterial',
                        uniforms: cloneUniforms( ShaderLib.background.uniforms ),
                        vertexShader: ShaderLib.background.vertexShader,
                        fragmentShader: ShaderLib.background.fragmentShader,
                        side: FrontSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    } ) );
                    planeMesh.geometry.deleteAttribute( 'normal' ); // enable code injection for non-built-in material
                    Object.defineProperty( planeMesh.material, 'map', {
                        get: function get( ) {
                            return this.uniforms.t2D.value;
                        }
                    } );
                    objects.update( planeMesh );
                }
                planeMesh.material.uniforms.t2D.value = background;
                if ( background.matrixAutoUpdate === true ) {
                    background.updateMatrix( );
                }
                planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );
                if ( currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping ) {
                    planeMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
                }
                planeMesh.layers.enableAll( ); // push to the pre-sorted opaque render list
                renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );
            }
        }

        function setClear( color, alpha ) {
            state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
        }
        return {
            getClearColor: function getClearColor( ) {
                return clearColor;
            },
            setClearColor: function setClearColor( color ) {
                var alpha = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
                clearColor.set( color );
                clearAlpha = alpha;
                setClear( clearColor, clearAlpha );
            },
            getClearAlpha: function getClearAlpha( ) {
                return clearAlpha;
            },
            setClearAlpha: function setClearAlpha( alpha ) {
                clearAlpha = alpha;
                setClear( clearColor, clearAlpha );
            },
            render: render
        };
    }

    function WebGLBindingStates( gl, extensions, attributes, capabilities ) {
        var maxVertexAttributes = gl.getParameter( 34921 );
        var extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
        var vaoAvailable = capabilities.isWebGL2 || extension !== null;
        var bindingStates = {};
        var defaultState = createBindingState( null );
        var currentState = defaultState;
        var forceUpdate = false;

        function setup( object, material, program, geometry, index ) {
            var updateBuffers = false;
            if ( vaoAvailable ) {
                var state = getBindingState( geometry, program, material );
                if ( currentState !== state ) {
                    currentState = state;
                    bindVertexArrayObject( currentState.object );
                }
                updateBuffers = needsUpdate( object, geometry, program, index );
                if ( updateBuffers ) saveCache( object, geometry, program, index );
            } else {
                var wireframe = material.wireframe === true;
                if ( currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe ) {
                    currentState.geometry = geometry.id;
                    currentState.program = program.id;
                    currentState.wireframe = wireframe;
                    updateBuffers = true;
                }
            }
            if ( index !== null ) {
                attributes.update( index, 34963 );
            }
            if ( updateBuffers || forceUpdate ) {
                forceUpdate = false;
                setupVertexAttributes( object, material, program, geometry );
                if ( index !== null ) {
                    gl.bindBuffer( 34963, attributes.get( index ).buffer );
                }
            }
        }

        function createVertexArrayObject( ) {
            if ( capabilities.isWebGL2 ) return gl.createVertexArray( );
            return extension.createVertexArrayOES( );
        }

        function bindVertexArrayObject( vao ) {
            if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );
            return extension.bindVertexArrayOES( vao );
        }

        function deleteVertexArrayObject( vao ) {
            if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );
            return extension.deleteVertexArrayOES( vao );
        }

        function getBindingState( geometry, program, material ) {
            var wireframe = material.wireframe === true;
            var programMap = bindingStates[ geometry.id ];
            if ( programMap === undefined ) {
                programMap = {};
                bindingStates[ geometry.id ] = programMap;
            }
            var stateMap = programMap[ program.id ];
            if ( stateMap === undefined ) {
                stateMap = {};
                programMap[ program.id ] = stateMap;
            }
            var state = stateMap[ wireframe ];
            if ( state === undefined ) {
                state = createBindingState( createVertexArrayObject( ) );
                stateMap[ wireframe ] = state;
            }
            return state;
        }

        function createBindingState( vao ) {
            var newAttributes = [ ];
            var enabledAttributes = [ ];
            var attributeDivisors = [ ];
            for ( var _i71 = 0; _i71 < maxVertexAttributes; _i71++ ) {
                newAttributes[ _i71 ] = 0;
                enabledAttributes[ _i71 ] = 0;
                attributeDivisors[ _i71 ] = 0;
            }
            return { // for backward compatibility on non-VAO support browser
                geometry: null,
                program: null,
                wireframe: false,
                newAttributes: newAttributes,
                enabledAttributes: enabledAttributes,
                attributeDivisors: attributeDivisors,
                object: vao,
                attributes: {},
                index: null
            };
        }

        function needsUpdate( object, geometry, program, index ) {
            var cachedAttributes = currentState.attributes;
            var geometryAttributes = geometry.attributes;
            var attributesNum = 0;
            var programAttributes = program.getAttributes( );
            for ( var name in programAttributes ) {
                var programAttribute = programAttributes[ name ];
                if ( programAttribute.location >= 0 ) {
                    var cachedAttribute = cachedAttributes[ name ];
                    var geometryAttribute = geometryAttributes[ name ];
                    if ( geometryAttribute === undefined ) {
                        if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
                        if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;
                    }
                    if ( cachedAttribute === undefined ) return true;
                    if ( cachedAttribute.attribute !== geometryAttribute ) return true;
                    if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;
                    attributesNum++;
                }
            }
            if ( currentState.attributesNum !== attributesNum ) return true;
            if ( currentState.index !== index ) return true;
            return false;
        }

        function saveCache( object, geometry, program, index ) {
            var cache = {};
            var attributes = geometry.attributes;
            var attributesNum = 0;
            var programAttributes = program.getAttributes( );
            for ( var name in programAttributes ) {
                var programAttribute = programAttributes[ name ];
                if ( programAttribute.location >= 0 ) {
                    var attribute = attributes[ name ];
                    if ( attribute === undefined ) {
                        if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
                        if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;
                    }
                    var data = {};
                    data.attribute = attribute;
                    if ( attribute && attribute.data ) {
                        data.data = attribute.data;
                    }
                    cache[ name ] = data;
                    attributesNum++;
                }
            }
            currentState.attributes = cache;
            currentState.attributesNum = attributesNum;
            currentState.index = index;
        }

        function initAttributes( ) {
            var newAttributes = currentState.newAttributes;
            for ( var _i72 = 0, il = newAttributes.length; _i72 < il; _i72++ ) {
                newAttributes[ _i72 ] = 0;
            }
        }

        function enableAttribute( attribute ) {
            enableAttributeAndDivisor( attribute, 0 );
        }

        function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            var attributeDivisors = currentState.attributeDivisors;
            newAttributes[ attribute ] = 1;
            if ( enabledAttributes[ attribute ] === 0 ) {
                gl.enableVertexAttribArray( attribute );
                enabledAttributes[ attribute ] = 1;
            }
            if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
                var _extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );
                _extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
                attributeDivisors[ attribute ] = meshPerAttribute;
            }
        }

        function disableUnusedAttributes( ) {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            for ( var _i73 = 0, il = enabledAttributes.length; _i73 < il; _i73++ ) {
                if ( enabledAttributes[ _i73 ] !== newAttributes[ _i73 ] ) {
                    gl.disableVertexAttribArray( _i73 );
                    enabledAttributes[ _i73 ] = 0;
                }
            }
        }

        function vertexAttribPointer( index, size, type, normalized, stride, offset ) {
            if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {
                gl.vertexAttribIPointer( index, size, type, stride, offset );
            } else {
                gl.vertexAttribPointer( index, size, type, normalized, stride, offset );
            }
        }

        function setupVertexAttributes( object, material, program, geometry ) {
            if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {
                if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;
            }
            initAttributes( );
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes( );
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for ( var name in programAttributes ) {
                var programAttribute = programAttributes[ name ];
                if ( programAttribute.location >= 0 ) {
                    var geometryAttribute = geometryAttributes[ name ];
                    if ( geometryAttribute === undefined ) {
                        if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
                        if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;
                    }
                    if ( geometryAttribute !== undefined ) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attribute = attributes.get( geometryAttribute ); // TODO Attribute may not be available on context restore
                        if ( attribute === undefined ) continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
                        if ( geometryAttribute.isInterleavedBufferAttribute ) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if ( data.isInstancedInterleavedBuffer ) {
                                for ( var _i74 = 0; _i74 < programAttribute.locationSize; _i74++ ) {
                                    enableAttributeAndDivisor( programAttribute.location + _i74, data.meshPerAttribute );
                                }
                                if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {
                                    geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                                }
                            } else {
                                for ( var _i75 = 0; _i75 < programAttribute.locationSize; _i75++ ) {
                                    enableAttribute( programAttribute.location + _i75 );
                                }
                            }
                            gl.bindBuffer( 34962, buffer );
                            for ( var _i76 = 0; _i76 < programAttribute.locationSize; _i76++ ) {
                                vertexAttribPointer( programAttribute.location + _i76, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, ( offset + size / programAttribute.locationSize * _i76 ) * bytesPerElement );
                            }
                        } else {
                            if ( geometryAttribute.isInstancedBufferAttribute ) {
                                for ( var _i77 = 0; _i77 < programAttribute.locationSize; _i77++ ) {
                                    enableAttributeAndDivisor( programAttribute.location + _i77, geometryAttribute.meshPerAttribute );
                                }
                                if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {
                                    geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {
                                for ( var _i78 = 0; _i78 < programAttribute.locationSize; _i78++ ) {
                                    enableAttribute( programAttribute.location + _i78 );
                                }
                            }
                            gl.bindBuffer( 34962, buffer );
                            for ( var _i79 = 0; _i79 < programAttribute.locationSize; _i79++ ) {
                                vertexAttribPointer( programAttribute.location + _i79, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i79 * bytesPerElement );
                            }
                        }
                    } else if ( materialDefaultAttributeValues !== undefined ) {
                        var _value2 = materialDefaultAttributeValues[ name ];
                        if ( _value2 !== undefined ) {
                            switch ( _value2.length ) {
                                case 2:
                                    gl.vertexAttrib2fv( programAttribute.location, _value2 );
                                    break;
                                case 3:
                                    gl.vertexAttrib3fv( programAttribute.location, _value2 );
                                    break;
                                case 4:
                                    gl.vertexAttrib4fv( programAttribute.location, _value2 );
                                    break;
                                default:
                                    gl.vertexAttrib1fv( programAttribute.location, _value2 );
                            }
                        }
                    }
                }
            }
            disableUnusedAttributes( );
        }

        function dispose( ) {
            reset( );
            for ( var geometryId in bindingStates ) {
                var programMap = bindingStates[ geometryId ];
                for ( var programId in programMap ) {
                    var stateMap = programMap[ programId ];
                    for ( var wireframe in stateMap ) {
                        deleteVertexArrayObject( stateMap[ wireframe ].object );
                        delete stateMap[ wireframe ];
                    }
                    delete programMap[ programId ];
                }
                delete bindingStates[ geometryId ];
            }
        }

        function releaseStatesOfGeometry( geometry ) {
            if ( bindingStates[ geometry.id ] === undefined ) return;
            var programMap = bindingStates[ geometry.id ];
            for ( var programId in programMap ) {
                var stateMap = programMap[ programId ];
                for ( var wireframe in stateMap ) {
                    deleteVertexArrayObject( stateMap[ wireframe ].object );
                    delete stateMap[ wireframe ];
                }
                delete programMap[ programId ];
            }
            delete bindingStates[ geometry.id ];
        }

        function releaseStatesOfProgram( program ) {
            for ( var geometryId in bindingStates ) {
                var programMap = bindingStates[ geometryId ];
                if ( programMap[ program.id ] === undefined ) continue;
                var stateMap = programMap[ program.id ];
                for ( var wireframe in stateMap ) {
                    deleteVertexArrayObject( stateMap[ wireframe ].object );
                    delete stateMap[ wireframe ];
                }
                delete programMap[ program.id ];
            }
        }

        function reset( ) {
            resetDefaultState( );
            forceUpdate = true;
            if ( currentState === defaultState ) return;
            currentState = defaultState;
            bindVertexArrayObject( currentState.object );
        } // for backward-compatibility
        function resetDefaultState( ) {
            defaultState.geometry = null;
            defaultState.program = null;
            defaultState.wireframe = false;
        }
        return {
            setup: setup,
            reset: reset,
            resetDefaultState: resetDefaultState,
            dispose: dispose,
            releaseStatesOfGeometry: releaseStatesOfGeometry,
            releaseStatesOfProgram: releaseStatesOfProgram,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            disableUnusedAttributes: disableUnusedAttributes
        };
    }

    function WebGLBufferRenderer( gl, extensions, info, capabilities ) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;

        function setMode( value ) {
            mode = value;
        }

        function render( start, count ) {
            gl.drawArrays( mode, start, count );
            info.update( count, mode, 1 );
        }

        function renderInstances( start, count, primcount ) {
            if ( primcount === 0 ) return;
            var extension, methodName;
            if ( isWebGL2 ) {
                extension = gl;
                methodName = 'drawArraysInstanced';
            } else {
                extension = extensions.get( 'ANGLE_instanced_arrays' );
                methodName = 'drawArraysInstancedANGLE';
                if ( extension === null ) {
                    console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                    return;
                }
            }
            extension[ methodName ]( mode, start, count, primcount );
            info.update( count, mode, primcount );
        } //
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    function WebGLCapabilities( gl, extensions, parameters ) {
        var maxAnisotropy;

        function getMaxAnisotropy( ) {
            if ( maxAnisotropy !== undefined ) return maxAnisotropy;
            if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {
                var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
                maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
            } else {
                maxAnisotropy = 0;
            }
            return maxAnisotropy;
        }

        function getMaxPrecision( precision ) {
            if ( precision === 'highp' ) {
                if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 && gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if ( precision === 'mediump' ) {
                if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 && gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {
                    return 'mediump';
                }
            }
            return 'lowp';
        }
        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision( precision );
        if ( maxPrecision !== precision ) {
            console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
            precision = maxPrecision;
        }
        var drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        var maxTextures = gl.getParameter( 34930 );
        var maxVertexTextures = gl.getParameter( 35660 );
        var maxTextureSize = gl.getParameter( 3379 );
        var maxCubemapSize = gl.getParameter( 34076 );
        var maxAttributes = gl.getParameter( 34921 );
        var maxVertexUniforms = gl.getParameter( 36347 );
        var maxVaryings = gl.getParameter( 36348 );
        var maxFragmentUniforms = gl.getParameter( 36349 );
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;
        return {
            isWebGL2: isWebGL2,
            drawBuffers: drawBuffers,
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures,
            maxSamples: maxSamples
        };
    }

    function WebGLClipping( properties ) {
        var scope = this;
        var globalState = null,
            numGlobalPlanes = 0,
            localClippingEnabled = false,
            renderingShadows = false;
        var plane = new Plane( ),
            viewNormalMatrix = new Matrix3( ),
            uniform = {
                value: null,
                needsUpdate: false
            };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function( planes, enableLocalClipping, camera ) {
            var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
                // run another frame in order to reset the state:
                numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes( planes, camera, 0 );
            numGlobalPlanes = planes.length;
            return enabled;
        };
        this.beginShadows = function( ) {
            renderingShadows = true;
            projectPlanes( null );
        };
        this.endShadows = function( ) {
            renderingShadows = false;
            resetGlobalState( );
        };
        this.setState = function( material, camera, useCache ) {
            var planes = material.clippingPlanes,
                clipIntersection = material.clipIntersection,
                clipShadows = material.clipShadows;
            var materialProperties = properties.get( material );
            if ( !localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows ) { // there's no local clipping
                if ( renderingShadows ) { // there's no global clipping
                    projectPlanes( null );
                } else {
                    resetGlobalState( );
                }
            } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                    lGlobal = nGlobal * 4;
                var dstArray = materialProperties.clippingState || null;
                uniform.value = dstArray; // ensure unique state
                dstArray = projectPlanes( planes, camera, lGlobal, useCache );
                for ( var _i80 = 0; _i80 !== lGlobal; ++_i80 ) {
                    dstArray[ _i80 ] = globalState[ _i80 ];
                }
                materialProperties.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };

        function resetGlobalState( ) {
            if ( uniform.value !== globalState ) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }

        function projectPlanes( planes, camera, dstOffset, skipTransform ) {
            var nPlanes = planes !== null ? planes.length : 0;
            var dstArray = null;
            if ( nPlanes !== 0 ) {
                dstArray = uniform.value;
                if ( skipTransform !== true || dstArray === null ) {
                    var flatSize = dstOffset + nPlanes * 4,
                        viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix( viewMatrix );
                    if ( dstArray === null || dstArray.length < flatSize ) {
                        dstArray = new Float32Array( flatSize );
                    }
                    for ( var _i81 = 0, i4 = dstOffset; _i81 !== nPlanes; ++_i81, i4 += 4 ) {
                        plane.copy( planes[ _i81 ] ).applyMatrix4( viewMatrix, viewNormalMatrix );
                        plane.normal.toArray( dstArray, i4 );
                        dstArray[ i4 + 3 ] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            scope.numIntersection = 0;
            return dstArray;
        }
    }

    function WebGLCubeMaps( renderer ) {
        var cubemaps = new WeakMap( );

        function mapTextureMapping( texture, mapping ) {
            if ( mapping === EquirectangularReflectionMapping ) {
                texture.mapping = CubeReflectionMapping;
            } else if ( mapping === EquirectangularRefractionMapping ) {
                texture.mapping = CubeRefractionMapping;
            }
            return texture;
        }

        function get( texture ) {
            if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {
                var mapping = texture.mapping;
                if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {
                    if ( cubemaps.has( texture ) ) {
                        var cubemap = cubemaps.get( texture ).texture;
                        return mapTextureMapping( cubemap, texture.mapping );
                    } else {
                        var image = texture.image;
                        if ( image && image.height > 0 ) {
                            var renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
                            renderTarget.fromEquirectangularTexture( renderer, texture );
                            cubemaps.set( texture, renderTarget );
                            texture.addEventListener( 'dispose', onTextureDispose );
                            return mapTextureMapping( renderTarget.texture, texture.mapping );
                        } else { // image not yet ready. try the conversion next frame
                            return null;
                        }
                    }
                }
            }
            return texture;
        }

        function onTextureDispose( event ) {
            var texture = event.target;
            texture.removeEventListener( 'dispose', onTextureDispose );
            var cubemap = cubemaps.get( texture );
            if ( cubemap !== undefined ) {
                cubemaps[ "delete" ]( texture );
                cubemap.dispose( );
            }
        }

        function dispose( ) {
            cubemaps = new WeakMap( );
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    var OrthographicCamera = /*#__PURE__*/ function( _Camera2 ) {
        _inherits( OrthographicCamera, _Camera2 );
        var _super21 = _createSuper( OrthographicCamera );

        function OrthographicCamera( ) {
            var _this19;
            var left = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : -1;
            var right = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var top = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var bottom = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : -1;
            var near = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : 0.1;
            var far = arguments.length > 5 && arguments[ 5 ] !== undefined ? arguments[ 5 ] : 2000;
            _classCallCheck( this, OrthographicCamera );
            _this19 = _super21.call( this );
            _this19.isOrthographicCamera = true;
            _this19.type = 'OrthographicCamera';
            _this19.zoom = 1;
            _this19.view = null;
            _this19.left = left;
            _this19.right = right;
            _this19.top = top;
            _this19.bottom = bottom;
            _this19.near = near;
            _this19.far = far;
            _this19.updateProjectionMatrix( );
            return _this19;
        }
        _createClass( OrthographicCamera, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( OrthographicCamera.prototype ), "copy", this ).call( this, source, recursive );
                this.left = source.left;
                this.right = source.right;
                this.top = source.top;
                this.bottom = source.bottom;
                this.near = source.near;
                this.far = source.far;
                this.zoom = source.zoom;
                this.view = source.view === null ? null : Object.assign( {}, source.view );
                return this;
            }
        }, {
            key: "setViewOffset",
            value: function setViewOffset( fullWidth, fullHeight, x, y, width, height ) {
                if ( this.view === null ) {
                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };
                }
                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;
                this.updateProjectionMatrix( );
            }
        }, {
            key: "clearViewOffset",
            value: function clearViewOffset( ) {
                if ( this.view !== null ) {
                    this.view.enabled = false;
                }
                this.updateProjectionMatrix( );
            }
        }, {
            key: "updateProjectionMatrix",
            value: function updateProjectionMatrix( ) {
                var dx = ( this.right - this.left ) / ( 2 * this.zoom );
                var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
                var cx = ( this.right + this.left ) / 2;
                var cy = ( this.top + this.bottom ) / 2;
                var left = cx - dx;
                var right = cx + dx;
                var top = cy + dy;
                var bottom = cy - dy;
                if ( this.view !== null && this.view.enabled ) {
                    var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
                    var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;
                    left += scaleW * this.view.offsetX;
                    right = left + scaleW * this.view.width;
                    top -= scaleH * this.view.offsetY;
                    bottom = top - scaleH * this.view.height;
                }
                this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
                this.projectionMatrixInverse.copy( this.projectionMatrix ).invert( );
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var data = _get( _getPrototypeOf( OrthographicCamera.prototype ), "toJSON", this ).call( this, meta );
                data.object.zoom = this.zoom;
                data.object.left = this.left;
                data.object.right = this.right;
                data.object.top = this.top;
                data.object.bottom = this.bottom;
                data.object.near = this.near;
                data.object.far = this.far;
                if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
                return data;
            }
        } ] );
        return OrthographicCamera;
    }( Camera );
    var LOD_MIN = 4; // The standard deviations (radians) associated with the extra mips. These are
    // chosen to approximate a Trowbridge-Reitz distribution function times the
    // geometric shadowing function. These sigma values squared must match the
    // variance #defines in cube_uv_reflection_fragment.glsl.js.
    var EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ]; // The maximum length of the blur for loop. Smaller sigmas will use fewer
    // samples and exit early, but not recompile the shader.
    var MAX_SAMPLES = 20;
    var _flatCamera = /*@__PURE__*/ new OrthographicCamera( );
    var _clearColor = /*@__PURE__*/ new Color( );
    var _oldTarget = null; // Golden Ratio
    var PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
    var INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
    // same axis), used as axis directions evenly spread on a sphere.
    var _axisDirections = [ /*@__PURE__*/ new Vector3( 1, 1, 1 ), /*@__PURE__*/ new Vector3( -1, 1, 1 ), /*@__PURE__*/ new Vector3( 1, 1, -1 ), /*@__PURE__*/ new Vector3( -1, 1, -1 ), /*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ), /*@__PURE__*/ new Vector3( 0, PHI, -INV_PHI ), /*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ), /*@__PURE__*/ new Vector3( -INV_PHI, 0, PHI ), /*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ), /*@__PURE__*/ new Vector3( -PHI, INV_PHI, 0 ) ];
    /**
     * This class generates a Prefiltered, Mipmapped Radiance Environment Map
     * (PMREM) from a cubeMap environment texture. This allows different levels of
     * blur to be quickly accessed based on material roughness. It is packed into a
     * special CubeUV format that allows us to perform custom interpolation so that
     * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
     * chain, it only goes down to the LOD_MIN level (above), and then creates extra
     * even more filtered 'mips' at the same LOD_MIN resolution, associated with
     * higher roughness levels. In this way we maintain resolution to smoothly
     * interpolate diffuse lighting while limiting sampling computation.
     *
     * Paper: Fast, Accurate Image-Based Lighting
     * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
     */
    var PMREMGenerator = /*#__PURE__*/ function( ) {
        function PMREMGenerator( renderer ) {
            _classCallCheck( this, PMREMGenerator );
            this._renderer = renderer;
            this._pingPongRenderTarget = null;
            this._lodMax = 0;
            this._cubeSize = 0;
            this._lodPlanes = [ ];
            this._sizeLods = [ ];
            this._sigmas = [ ];
            this._blurMaterial = null;
            this._cubemapMaterial = null;
            this._equirectMaterial = null;
            this._compileMaterial( this._blurMaterial );
        }
        /**
         * Generates a PMREM from a supplied Scene, which can be faster than using an
         * image if networking bandwidth is low. Optional sigma specifies a blur radius
         * in radians to be applied to the scene before PMREM generation. Optional near
         * and far planes ensure the scene is rendered in its entirety (the cubeCamera
         * is placed at the origin).
         */
        _createClass( PMREMGenerator, [ {
            key: "fromScene",
            value: function fromScene( scene ) {
                var sigma = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                var near = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0.1;
                var far = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 100;
                _oldTarget = this._renderer.getRenderTarget( );
                this._setSize( 256 );
                var cubeUVRenderTarget = this._allocateTargets( );
                cubeUVRenderTarget.depthBuffer = true;
                this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
                if ( sigma > 0 ) {
                    this._blur( cubeUVRenderTarget, 0, 0, sigma );
                }
                this._applyPMREM( cubeUVRenderTarget );
                this._cleanup( cubeUVRenderTarget );
                return cubeUVRenderTarget;
            }
            /**
             * Generates a PMREM from an equirectangular texture, which can be either LDR
             * or HDR. The ideal input image size is 1k (1024 x 512),
             * as this matches best with the 256 x 256 cubemap output.
             */
        }, {
            key: "fromEquirectangular",
            value: function fromEquirectangular( equirectangular ) {
                var renderTarget = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : null;
                return this._fromTexture( equirectangular, renderTarget );
            }
            /**
             * Generates a PMREM from an cubemap texture, which can be either LDR
             * or HDR. The ideal input cube size is 256 x 256,
             * as this matches best with the 256 x 256 cubemap output.
             */
        }, {
            key: "fromCubemap",
            value: function fromCubemap( cubemap ) {
                var renderTarget = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : null;
                return this._fromTexture( cubemap, renderTarget );
            }
            /**
             * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
             * your texture's network fetch for increased concurrency.
             */
        }, {
            key: "compileCubemapShader",
            value: function compileCubemapShader( ) {
                if ( this._cubemapMaterial === null ) {
                    this._cubemapMaterial = _getCubemapMaterial( );
                    this._compileMaterial( this._cubemapMaterial );
                }
            }
            /**
             * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
             * your texture's network fetch for increased concurrency.
             */
        }, {
            key: "compileEquirectangularShader",
            value: function compileEquirectangularShader( ) {
                if ( this._equirectMaterial === null ) {
                    this._equirectMaterial = _getEquirectMaterial( );
                    this._compileMaterial( this._equirectMaterial );
                }
            }
            /**
             * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
             * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
             * one of them will cause any others to also become unusable.
             */
        }, {
            key: "dispose",
            value: function dispose( ) {
                this._dispose( );
                if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose( );
                if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose( );
            } // private interface
        }, {
            key: "_setSize",
            value: function _setSize( cubeSize ) {
                this._lodMax = Math.floor( Math.log2( cubeSize ) );
                this._cubeSize = Math.pow( 2, this._lodMax );
            }
        }, {
            key: "_dispose",
            value: function _dispose( ) {
                if ( this._blurMaterial !== null ) this._blurMaterial.dispose( );
                if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose( );
                for ( var _i82 = 0; _i82 < this._lodPlanes.length; _i82++ ) {
                    this._lodPlanes[ _i82 ].dispose( );
                }
            }
        }, {
            key: "_cleanup",
            value: function _cleanup( outputTarget ) {
                this._renderer.setRenderTarget( _oldTarget );
                outputTarget.scissorTest = false;
                _setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );
            }
        }, {
            key: "_fromTexture",
            value: function _fromTexture( texture, renderTarget ) {
                if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {
                    this._setSize( texture.image.length === 0 ? 16 : texture.image[ 0 ].width || texture.image[ 0 ].image.width );
                } else { // Equirectangular
                    this._setSize( texture.image.width / 4 );
                }
                _oldTarget = this._renderer.getRenderTarget( );
                var cubeUVRenderTarget = renderTarget || this._allocateTargets( );
                this._textureToCubeUV( texture, cubeUVRenderTarget );
                this._applyPMREM( cubeUVRenderTarget );
                this._cleanup( cubeUVRenderTarget );
                return cubeUVRenderTarget;
            }
        }, {
            key: "_allocateTargets",
            value: function _allocateTargets( ) {
                var width = 3 * Math.max( this._cubeSize, 16 * 7 );
                var height = 4 * this._cubeSize;
                var params = {
                    magFilter: LinearFilter,
                    minFilter: LinearFilter,
                    generateMipmaps: false,
                    type: HalfFloatType,
                    format: RGBAFormat,
                    encoding: LinearEncoding,
                    depthBuffer: false
                };
                var cubeUVRenderTarget = _createRenderTarget( width, height, params );
                if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {
                    if ( this._pingPongRenderTarget !== null ) {
                        this._dispose( );
                    }
                    this._pingPongRenderTarget = _createRenderTarget( width, height, params );
                    var _lodMax = this._lodMax;
                    var _createPlanes2 = _createPlanes( _lodMax );
                    this._sizeLods = _createPlanes2.sizeLods;
                    this._lodPlanes = _createPlanes2.lodPlanes;
                    this._sigmas = _createPlanes2.sigmas;
                    this._blurMaterial = _getBlurShader( _lodMax, width, height );
                }
                return cubeUVRenderTarget;
            }
        }, {
            key: "_compileMaterial",
            value: function _compileMaterial( material ) {
                var tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
                this._renderer.compile( tmpMesh, _flatCamera );
            }
        }, {
            key: "_sceneToCubeUV",
            value: function _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {
                var fov = 90;
                var aspect = 1;
                var cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
                var upSign = [ 1, -1, 1, 1, 1, 1 ];
                var forwardSign = [ 1, 1, 1, -1, -1, -1 ];
                var renderer = this._renderer;
                var originalAutoClear = renderer.autoClear;
                var toneMapping = renderer.toneMapping;
                renderer.getClearColor( _clearColor );
                renderer.toneMapping = NoToneMapping;
                renderer.autoClear = false;
                var backgroundMaterial = new MeshBasicMaterial( {
                    name: 'PMREM.Background',
                    side: BackSide,
                    depthWrite: false,
                    depthTest: false
                } );
                var backgroundBox = new Mesh( new BoxGeometry( ), backgroundMaterial );
                var useSolidColor = false;
                var background = scene.background;
                if ( background ) {
                    if ( background.isColor ) {
                        backgroundMaterial.color.copy( background );
                        scene.background = null;
                        useSolidColor = true;
                    }
                } else {
                    backgroundMaterial.color.copy( _clearColor );
                    useSolidColor = true;
                }
                for ( var _i83 = 0; _i83 < 6; _i83++ ) {
                    var col = _i83 % 3;
                    if ( col === 0 ) {
                        cubeCamera.up.set( 0, upSign[ _i83 ], 0 );
                        cubeCamera.lookAt( forwardSign[ _i83 ], 0, 0 );
                    } else if ( col === 1 ) {
                        cubeCamera.up.set( 0, 0, upSign[ _i83 ] );
                        cubeCamera.lookAt( 0, forwardSign[ _i83 ], 0 );
                    } else {
                        cubeCamera.up.set( 0, upSign[ _i83 ], 0 );
                        cubeCamera.lookAt( 0, 0, forwardSign[ _i83 ] );
                    }
                    var size = this._cubeSize;
                    _setViewport( cubeUVRenderTarget, col * size, _i83 > 2 ? size : 0, size, size );
                    renderer.setRenderTarget( cubeUVRenderTarget );
                    if ( useSolidColor ) {
                        renderer.render( backgroundBox, cubeCamera );
                    }
                    renderer.render( scene, cubeCamera );
                }
                backgroundBox.geometry.dispose( );
                backgroundBox.material.dispose( );
                renderer.toneMapping = toneMapping;
                renderer.autoClear = originalAutoClear;
                scene.background = background;
            }
        }, {
            key: "_textureToCubeUV",
            value: function _textureToCubeUV( texture, cubeUVRenderTarget ) {
                var renderer = this._renderer;
                var isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
                if ( isCubeTexture ) {
                    if ( this._cubemapMaterial === null ) {
                        this._cubemapMaterial = _getCubemapMaterial( );
                    }
                    this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
                } else {
                    if ( this._equirectMaterial === null ) {
                        this._equirectMaterial = _getEquirectMaterial( );
                    }
                }
                var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
                var mesh = new Mesh( this._lodPlanes[ 0 ], material );
                var uniforms = material.uniforms;
                uniforms[ 'envMap' ].value = texture;
                var size = this._cubeSize;
                _setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );
                renderer.setRenderTarget( cubeUVRenderTarget );
                renderer.render( mesh, _flatCamera );
            }
        }, {
            key: "_applyPMREM",
            value: function _applyPMREM( cubeUVRenderTarget ) {
                var renderer = this._renderer;
                var autoClear = renderer.autoClear;
                renderer.autoClear = false;
                for ( var _i84 = 1; _i84 < this._lodPlanes.length; _i84++ ) {
                    var sigma = Math.sqrt( this._sigmas[ _i84 ] * this._sigmas[ _i84 ] - this._sigmas[ _i84 - 1 ] * this._sigmas[ _i84 - 1 ] );
                    var poleAxis = _axisDirections[ ( _i84 - 1 ) % _axisDirections.length ];
                    this._blur( cubeUVRenderTarget, _i84 - 1, _i84, sigma, poleAxis );
                }
                renderer.autoClear = autoClear;
            }
            /**
             * This is a two-pass Gaussian blur for a cubemap. Normally this is done
             * vertically and horizontally, but this breaks down on a cube. Here we apply
             * the blur latitudinally (around the poles), and then longitudinally (towards
             * the poles) to approximate the orthogonally-separable blur. It is least
             * accurate at the poles, but still does a decent job.
             */
        }, {
            key: "_blur",
            value: function _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {
                var pingPongRenderTarget = this._pingPongRenderTarget;
                this._halfBlur( cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis );
                this._halfBlur( pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis );
            }
        }, {
            key: "_halfBlur",
            value: function _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {
                var renderer = this._renderer;
                var blurMaterial = this._blurMaterial;
                if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {
                    console.error( 'blur direction must be either latitudinal or longitudinal!' );
                } // Number of standard deviations at which to cut off the discrete approximation.
                var STANDARD_DEVIATIONS = 3;
                var blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
                var blurUniforms = blurMaterial.uniforms;
                var pixels = this._sizeLods[ lodIn ] - 1;
                var radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
                var sigmaPixels = sigmaRadians / radiansPerPixel;
                var samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;
                if ( samples > MAX_SAMPLES ) {
                    console.warn( "sigmaRadians, ".concat( sigmaRadians, ", is too large and will clip, as it requested " ).concat( samples, " samples when the maximum is set to " ).concat( MAX_SAMPLES ) );
                }
                var weights = [ ];
                var sum = 0;
                for ( var _i85 = 0; _i85 < MAX_SAMPLES; ++_i85 ) {
                    var _x6 = _i85 / sigmaPixels;
                    var weight = Math.exp( -_x6 * _x6 / 2 );
                    weights.push( weight );
                    if ( _i85 === 0 ) {
                        sum += weight;
                    } else if ( _i85 < samples ) {
                        sum += 2 * weight;
                    }
                }
                for ( var _i86 = 0; _i86 < weights.length; _i86++ ) {
                    weights[ _i86 ] = weights[ _i86 ] / sum;
                }
                blurUniforms[ 'envMap' ].value = targetIn.texture;
                blurUniforms[ 'samples' ].value = samples;
                blurUniforms[ 'weights' ].value = weights;
                blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';
                if ( poleAxis ) {
                    blurUniforms[ 'poleAxis' ].value = poleAxis;
                }
                var _lodMax = this._lodMax;
                blurUniforms[ 'dTheta' ].value = radiansPerPixel;
                blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;
                var outputSize = this._sizeLods[ lodOut ];
                var x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
                var y = 4 * ( this._cubeSize - outputSize );
                _setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
                renderer.setRenderTarget( targetOut );
                renderer.render( blurMesh, _flatCamera );
            }
        } ] );
        return PMREMGenerator;
    }( );

    function _createPlanes( lodMax ) {
        var lodPlanes = [ ];
        var sizeLods = [ ];
        var sigmas = [ ];
        var lod = lodMax;
        var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
        for ( var _i87 = 0; _i87 < totalLods; _i87++ ) {
            var sizeLod = Math.pow( 2, lod );
            sizeLods.push( sizeLod );
            var sigma = 1.0 / sizeLod;
            if ( _i87 > lodMax - LOD_MIN ) {
                sigma = EXTRA_LOD_SIGMA[ _i87 - lodMax + LOD_MIN - 1 ];
            } else if ( _i87 === 0 ) {
                sigma = 0;
            }
            sigmas.push( sigma );
            var texelSize = 1.0 / ( sizeLod - 2 );
            var min = -texelSize;
            var _max = 1 + texelSize;
            var uv1 = [ min, min, _max, min, _max, _max, min, min, _max, _max, min, _max ];
            var cubeFaces = 6;
            var vertices = 6;
            var positionSize = 3;
            var uvSize = 2;
            var faceIndexSize = 1;
            var position = new Float32Array( positionSize * vertices * cubeFaces );
            var uv = new Float32Array( uvSize * vertices * cubeFaces );
            var faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );
            for ( var face = 0; face < cubeFaces; face++ ) {
                var _x7 = face % 3 * 2 / 3 - 1;
                var y = face > 2 ? 0 : -1;
                var coordinates = [ _x7, y, 0, _x7 + 2 / 3, y, 0, _x7 + 2 / 3, y + 1, 0, _x7, y, 0, _x7 + 2 / 3, y + 1, 0, _x7, y + 1, 0 ];
                position.set( coordinates, positionSize * vertices * face );
                uv.set( uv1, uvSize * vertices * face );
                var fill = [ face, face, face, face, face, face ];
                faceIndex.set( fill, faceIndexSize * vertices * face );
            }
            var planes = new BufferGeometry( );
            planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
            planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
            planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
            lodPlanes.push( planes );
            if ( lod > LOD_MIN ) {
                lod--;
            }
        }
        return {
            lodPlanes: lodPlanes,
            sizeLods: sizeLods,
            sigmas: sigmas
        };
    }

    function _createRenderTarget( width, height, params ) {
        var cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
    }

    function _setViewport( target, x, y, width, height ) {
        target.viewport.set( x, y, width, height );
        target.scissor.set( x, y, width, height );
    }

    function _getBlurShader( lodMax, width, height ) {
        var weights = new Float32Array( MAX_SAMPLES );
        var poleAxis = new Vector3( 0, 1, 0 );
        var shaderMaterial = new ShaderMaterial( {
            name: 'SphericalGaussianBlur',
            defines: {
                'n': MAX_SAMPLES,
                'CUBEUV_TEXEL_WIDTH': 1.0 / width,
                'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
                'CUBEUV_MAX_MIP': "".concat( lodMax, ".0" )
            },
            uniforms: {
                'envMap': {
                    value: null
                },
                'samples': {
                    value: 1
                },
                'weights': {
                    value: weights
                },
                'latitudinal': {
                    value: false
                },
                'dTheta': {
                    value: 0
                },
                'mipInt': {
                    value: 0
                },
                'poleAxis': {
                    value: poleAxis
                }
            },
            vertexShader: _getCommonVertexShader( ),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        } );
        return shaderMaterial;
    }

    function _getEquirectMaterial( ) {
        return new ShaderMaterial( {
            name: 'EquirectangularToCubeUV',
            uniforms: {
                'envMap': {
                    value: null
                }
            },
            vertexShader: _getCommonVertexShader( ),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        } );
    }

    function _getCubemapMaterial( ) {
        return new ShaderMaterial( {
            name: 'CubemapToCubeUV',
            uniforms: {
                'envMap': {
                    value: null
                },
                'flipEnvMap': {
                    value: -1
                }
            },
            vertexShader: _getCommonVertexShader( ),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        } );
    }

    function _getCommonVertexShader( ) {
        return ( /* glsl */ "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" );
    }

    function WebGLCubeUVMaps( renderer ) {
        var cubeUVmaps = new WeakMap( );
        var pmremGenerator = null;

        function get( texture ) {
            if ( texture && texture.isTexture ) {
                var mapping = texture.mapping;
                var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
                var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping; // equirect/cube map to cubeUV conversion
                if ( isEquirectMap || isCubeMap ) {
                    if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {
                        texture.needsPMREMUpdate = false;
                        var renderTarget = cubeUVmaps.get( texture );
                        if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );
                        renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
                        cubeUVmaps.set( texture, renderTarget );
                        return renderTarget.texture;
                    } else {
                        if ( cubeUVmaps.has( texture ) ) {
                            return cubeUVmaps.get( texture ).texture;
                        } else {
                            var image = texture.image;
                            if ( isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete( image ) ) {
                                if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );
                                var _renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
                                cubeUVmaps.set( texture, _renderTarget );
                                texture.addEventListener( 'dispose', onTextureDispose );
                                return _renderTarget.texture;
                            } else { // image not yet ready. try the conversion next frame
                                return null;
                            }
                        }
                    }
                }
            }
            return texture;
        }

        function isCubeTextureComplete( image ) {
            var count = 0;
            var length = 6;
            for ( var _i88 = 0; _i88 < length; _i88++ ) {
                if ( image[ _i88 ] !== undefined ) count++;
            }
            return count === length;
        }

        function onTextureDispose( event ) {
            var texture = event.target;
            texture.removeEventListener( 'dispose', onTextureDispose );
            var cubemapUV = cubeUVmaps.get( texture );
            if ( cubemapUV !== undefined ) {
                cubeUVmaps[ "delete" ]( texture );
                cubemapUV.dispose( );
            }
        }

        function dispose( ) {
            cubeUVmaps = new WeakMap( );
            if ( pmremGenerator !== null ) {
                pmremGenerator.dispose( );
                pmremGenerator = null;
            }
        }
        return {
            get: get,
            dispose: dispose
        };
    }

    function WebGLExtensions( gl ) {
        var extensions = {};

        function getExtension( name ) {
            if ( extensions[ name ] !== undefined ) {
                return extensions[ name ];
            }
            var extension;
            switch ( name ) {
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                    break;
                default:
                    extension = gl.getExtension( name );
            }
            extensions[ name ] = extension;
            return extension;
        }
        return {
            has: function has( name ) {
                return getExtension( name ) !== null;
            },
            init: function init( capabilities ) {
                if ( capabilities.isWebGL2 ) {
                    getExtension( 'EXT_color_buffer_float' );
                } else {
                    getExtension( 'WEBGL_depth_texture' );
                    getExtension( 'OES_texture_float' );
                    getExtension( 'OES_texture_half_float' );
                    getExtension( 'OES_texture_half_float_linear' );
                    getExtension( 'OES_standard_derivatives' );
                    getExtension( 'OES_element_index_uint' );
                    getExtension( 'OES_vertex_array_object' );
                    getExtension( 'ANGLE_instanced_arrays' );
                }
                getExtension( 'OES_texture_float_linear' );
                getExtension( 'EXT_color_buffer_half_float' );
                getExtension( 'WEBGL_multisampled_render_to_texture' );
            },
            get: function get( name ) {
                var extension = getExtension( name );
                if ( extension === null ) {
                    console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
                }
                return extension;
            }
        };
    }

    function WebGLGeometries( gl, attributes, info, bindingStates ) {
        var geometries = {};
        var wireframeAttributes = new WeakMap( );

        function onGeometryDispose( event ) {
            var geometry = event.target;
            if ( geometry.index !== null ) {
                attributes.remove( geometry.index );
            }
            for ( var name in geometry.attributes ) {
                attributes.remove( geometry.attributes[ name ] );
            }
            geometry.removeEventListener( 'dispose', onGeometryDispose );
            delete geometries[ geometry.id ];
            var attribute = wireframeAttributes.get( geometry );
            if ( attribute ) {
                attributes.remove( attribute );
                wireframeAttributes[ "delete" ]( geometry );
            }
            bindingStates.releaseStatesOfGeometry( geometry );
            if ( geometry.isInstancedBufferGeometry === true ) {
                delete geometry._maxInstanceCount;
            } //
            info.memory.geometries--;
        }

        function get( object, geometry ) {
            if ( geometries[ geometry.id ] === true ) return geometry;
            geometry.addEventListener( 'dispose', onGeometryDispose );
            geometries[ geometry.id ] = true;
            info.memory.geometries++;
            return geometry;
        }

        function update( geometry ) {
            var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.
            for ( var name in geometryAttributes ) {
                attributes.update( geometryAttributes[ name ], 34962 );
            } // morph targets
            var morphAttributes = geometry.morphAttributes;
            for ( var _name3 in morphAttributes ) {
                var array = morphAttributes[ _name3 ];
                for ( var _i89 = 0, l = array.length; _i89 < l; _i89++ ) {
                    attributes.update( array[ _i89 ], 34962 );
                }
            }
        }

        function updateWireframeAttribute( geometry ) {
            var indices = [ ];
            var geometryIndex = geometry.index;
            var geometryPosition = geometry.attributes.position;
            var version = 0;
            if ( geometryIndex !== null ) {
                var array = geometryIndex.array;
                version = geometryIndex.version;
                for ( var _i90 = 0, l = array.length; _i90 < l; _i90 += 3 ) {
                    var _a8 = array[ _i90 + 0 ];
                    var _b8 = array[ _i90 + 1 ];
                    var _c8 = array[ _i90 + 2 ];
                    indices.push( _a8, _b8, _b8, _c8, _c8, _a8 );
                }
            } else {
                var _array = geometryPosition.array;
                version = geometryPosition.version;
                for ( var _i91 = 0, _l5 = _array.length / 3 - 1; _i91 < _l5; _i91 += 3 ) {
                    var _a9 = _i91 + 0;
                    var _b9 = _i91 + 1;
                    var _c9 = _i91 + 2;
                    indices.push( _a9, _b9, _b9, _c9, _c9, _a9 );
                }
            }
            var attribute = new( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
            attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
            //
            var previousAttribute = wireframeAttributes.get( geometry );
            if ( previousAttribute ) attributes.remove( previousAttribute ); //
            wireframeAttributes.set( geometry, attribute );
        }

        function getWireframeAttribute( geometry ) {
            var currentAttribute = wireframeAttributes.get( geometry );
            if ( currentAttribute ) {
                var geometryIndex = geometry.index;
                if ( geometryIndex !== null ) { // if the attribute is obsolete, create a new one
                    if ( currentAttribute.version < geometryIndex.version ) {
                        updateWireframeAttribute( geometry );
                    }
                }
            } else {
                updateWireframeAttribute( geometry );
            }
            return wireframeAttributes.get( geometry );
        }
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }

    function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;

        function setMode( value ) {
            mode = value;
        }
        var type, bytesPerElement;

        function setIndex( value ) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
        }

        function render( start, count ) {
            gl.drawElements( mode, count, type, start * bytesPerElement );
            info.update( count, mode, 1 );
        }

        function renderInstances( start, count, primcount ) {
            if ( primcount === 0 ) return;
            var extension, methodName;
            if ( isWebGL2 ) {
                extension = gl;
                methodName = 'drawElementsInstanced';
            } else {
                extension = extensions.get( 'ANGLE_instanced_arrays' );
                methodName = 'drawElementsInstancedANGLE';
                if ( extension === null ) {
                    console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                    return;
                }
            }
            extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );
            info.update( count, mode, primcount );
        } //
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    function WebGLInfo( gl ) {
        var memory = {
            geometries: 0,
            textures: 0
        };
        var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

        function update( count, mode, instanceCount ) {
            render.calls++;
            switch ( mode ) {
                case 4:
                    render.triangles += instanceCount * ( count / 3 );
                    break;
                case 1:
                    render.lines += instanceCount * ( count / 2 );
                    break;
                case 3:
                    render.lines += instanceCount * ( count - 1 );
                    break;
                case 2:
                    render.lines += instanceCount * count;
                    break;
                case 0:
                    render.points += instanceCount * count;
                    break;
                default:
                    console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
                    break;
            }
        }

        function reset( ) {
            render.frame++;
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
        }
        return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
        };
    }

    function numericalSort( a, b ) {
        return a[ 0 ] - b[ 0 ];
    }

    function absNumericalSort( a, b ) {
        return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );
    }

    function denormalize( morph, attribute ) {
        var denominator = 1;
        var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
        if ( array instanceof Int8Array ) denominator = 127;
        else if ( array instanceof Uint8Array ) denominator = 255;
        else if ( array instanceof Uint16Array ) denominator = 65535;
        else if ( array instanceof Int16Array ) denominator = 32767;
        else if ( array instanceof Int32Array ) denominator = 2147483647;
        else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );
        morph.divideScalar( denominator );
    }

    function WebGLMorphtargets( gl, capabilities, textures ) {
        var influencesList = {};
        var morphInfluences = new Float32Array( 8 );
        var morphTextures = new WeakMap( );
        var morph = new Vector4( );
        var workInfluences = [ ];
        for ( var _i92 = 0; _i92 < 8; _i92++ ) {
            workInfluences[ _i92 ] = [ _i92, 0 ];
        }

        function update( object, geometry, material, program ) {
            var objectInfluences = object.morphTargetInfluences;
            if ( capabilities.isWebGL2 === true ) { // instead of using attributes, the WebGL 2 code path encodes morph targets
                // into an array of data textures. Each layer represents a single morph target.
                var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
                var entry = morphTextures.get( geometry );
                if ( entry === undefined || entry.count !== morphTargetsCount ) {
                    var disposeTexture = function disposeTexture( ) {
                        texture.dispose( );
                        morphTextures[ "delete" ]( geometry );
                        geometry.removeEventListener( 'dispose', disposeTexture );
                    };
                    if ( entry !== undefined ) entry.texture.dispose( );
                    var hasMorphPosition = geometry.morphAttributes.position !== undefined;
                    var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
                    var hasMorphColors = geometry.morphAttributes.color !== undefined;
                    var morphTargets = geometry.morphAttributes.position || [ ];
                    var morphNormals = geometry.morphAttributes.normal || [ ];
                    var morphColors = geometry.morphAttributes.color || [ ];
                    var vertexDataCount = 0;
                    if ( hasMorphPosition === true ) vertexDataCount = 1;
                    if ( hasMorphNormals === true ) vertexDataCount = 2;
                    if ( hasMorphColors === true ) vertexDataCount = 3;
                    var _width2 = geometry.attributes.position.count * vertexDataCount;
                    var _height2 = 1;
                    if ( _width2 > capabilities.maxTextureSize ) {
                        _height2 = Math.ceil( _width2 / capabilities.maxTextureSize );
                        _width2 = capabilities.maxTextureSize;
                    }
                    var buffer = new Float32Array( _width2 * _height2 * 4 * morphTargetsCount );
                    var texture = new DataArrayTexture( buffer, _width2, _height2, morphTargetsCount );
                    texture.type = FloatType;
                    texture.needsUpdate = true; // fill buffer
                    var vertexDataStride = vertexDataCount * 4;
                    for ( var _i93 = 0; _i93 < morphTargetsCount; _i93++ ) {
                        var morphTarget = morphTargets[ _i93 ];
                        var morphNormal = morphNormals[ _i93 ];
                        var morphColor = morphColors[ _i93 ];
                        var offset = _width2 * _height2 * 4 * _i93;
                        for ( var j = 0; j < morphTarget.count; j++ ) {
                            var stride = j * vertexDataStride;
                            if ( hasMorphPosition === true ) {
                                morph.fromBufferAttribute( morphTarget, j );
                                if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );
                                buffer[ offset + stride + 0 ] = morph.x;
                                buffer[ offset + stride + 1 ] = morph.y;
                                buffer[ offset + stride + 2 ] = morph.z;
                                buffer[ offset + stride + 3 ] = 0;
                            }
                            if ( hasMorphNormals === true ) {
                                morph.fromBufferAttribute( morphNormal, j );
                                if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );
                                buffer[ offset + stride + 4 ] = morph.x;
                                buffer[ offset + stride + 5 ] = morph.y;
                                buffer[ offset + stride + 6 ] = morph.z;
                                buffer[ offset + stride + 7 ] = 0;
                            }
                            if ( hasMorphColors === true ) {
                                morph.fromBufferAttribute( morphColor, j );
                                if ( morphColor.normalized === true ) denormalize( morph, morphColor );
                                buffer[ offset + stride + 8 ] = morph.x;
                                buffer[ offset + stride + 9 ] = morph.y;
                                buffer[ offset + stride + 10 ] = morph.z;
                                buffer[ offset + stride + 11 ] = morphColor.itemSize === 4 ? morph.w : 1;
                            }
                        }
                    }
                    entry = {
                        count: morphTargetsCount,
                        texture: texture,
                        size: new Vector2( _width2, _height2 )
                    };
                    morphTextures.set( geometry, entry );
                    geometry.addEventListener( 'dispose', disposeTexture );
                } //
                var morphInfluencesSum = 0;
                for ( var _i94 = 0; _i94 < objectInfluences.length; _i94++ ) {
                    morphInfluencesSum += objectInfluences[ _i94 ];
                }
                var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                program.getUniforms( ).setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
                program.getUniforms( ).setValue( gl, 'morphTargetInfluences', objectInfluences );
                program.getUniforms( ).setValue( gl, 'morphTargetsTexture', entry.texture, textures );
                program.getUniforms( ).setValue( gl, 'morphTargetsTextureSize', entry.size );
            } else { // When object doesn't have morph target influences defined, we treat it as a 0-length array
                // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
                var length = objectInfluences === undefined ? 0 : objectInfluences.length;
                var influences = influencesList[ geometry.id ];
                if ( influences === undefined || influences.length !== length ) { // initialise list
                    influences = [ ];
                    for ( var _i95 = 0; _i95 < length; _i95++ ) {
                        influences[ _i95 ] = [ _i95, 0 ];
                    }
                    influencesList[ geometry.id ] = influences;
                } // Collect influences
                for ( var _i96 = 0; _i96 < length; _i96++ ) {
                    var influence = influences[ _i96 ];
                    influence[ 0 ] = _i96;
                    influence[ 1 ] = objectInfluences[ _i96 ];
                }
                influences.sort( absNumericalSort );
                for ( var _i97 = 0; _i97 < 8; _i97++ ) {
                    if ( _i97 < length && influences[ _i97 ][ 1 ] ) {
                        workInfluences[ _i97 ][ 0 ] = influences[ _i97 ][ 0 ];
                        workInfluences[ _i97 ][ 1 ] = influences[ _i97 ][ 1 ];
                    } else {
                        workInfluences[ _i97 ][ 0 ] = Number.MAX_SAFE_INTEGER;
                        workInfluences[ _i97 ][ 1 ] = 0;
                    }
                }
                workInfluences.sort( numericalSort );
                var _morphTargets = geometry.morphAttributes.position;
                var _morphNormals = geometry.morphAttributes.normal;
                var _morphInfluencesSum = 0;
                for ( var _i98 = 0; _i98 < 8; _i98++ ) {
                    var _influence = workInfluences[ _i98 ];
                    var index = _influence[ 0 ];
                    var _value3 = _influence[ 1 ];
                    if ( index !== Number.MAX_SAFE_INTEGER && _value3 ) {
                        if ( _morphTargets && geometry.getAttribute( 'morphTarget' + _i98 ) !== _morphTargets[ index ] ) {
                            geometry.setAttribute( 'morphTarget' + _i98, _morphTargets[ index ] );
                        }
                        if ( _morphNormals && geometry.getAttribute( 'morphNormal' + _i98 ) !== _morphNormals[ index ] ) {
                            geometry.setAttribute( 'morphNormal' + _i98, _morphNormals[ index ] );
                        }
                        morphInfluences[ _i98 ] = _value3;
                        _morphInfluencesSum += _value3;
                    } else {
                        if ( _morphTargets && geometry.hasAttribute( 'morphTarget' + _i98 ) === true ) {
                            geometry.deleteAttribute( 'morphTarget' + _i98 );
                        }
                        if ( _morphNormals && geometry.hasAttribute( 'morphNormal' + _i98 ) === true ) {
                            geometry.deleteAttribute( 'morphNormal' + _i98 );
                        }
                        morphInfluences[ _i98 ] = 0;
                    }
                } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
                // This allows us to switch between absolute morphs and relative morphs without changing shader code
                // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
                var _morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - _morphInfluencesSum;
                program.getUniforms( ).setValue( gl, 'morphTargetBaseInfluence', _morphBaseInfluence );
                program.getUniforms( ).setValue( gl, 'morphTargetInfluences', morphInfluences );
            }
        }
        return {
            update: update
        };
    }

    function WebGLObjects( gl, geometries, attributes, info ) {
        var updateMap = new WeakMap( );

        function update( object ) {
            var frame = info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get( object, geometry ); // Update once per frame
            if ( updateMap.get( buffergeometry ) !== frame ) {
                geometries.update( buffergeometry );
                updateMap.set( buffergeometry, frame );
            }
            if ( object.isInstancedMesh ) {
                if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {
                    object.addEventListener( 'dispose', onInstancedMeshDispose );
                }
                attributes.update( object.instanceMatrix, 34962 );
                if ( object.instanceColor !== null ) {
                    attributes.update( object.instanceColor, 34962 );
                }
            }
            return buffergeometry;
        }

        function dispose( ) {
            updateMap = new WeakMap( );
        }

        function onInstancedMeshDispose( event ) {
            var instancedMesh = event.target;
            instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );
            attributes.remove( instancedMesh.instanceMatrix );
            if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );
        }
        return {
            update: update,
            dispose: dispose
        };
    }
    /**
     * Uniforms of a program.
     * Those form a tree structure with a special top-level container for the root,
     * which you get by calling 'new WebGLUniforms( gl, program )'.
     *
     *
     * Properties of inner nodes including the top-level container:
     *
     * .seq - array of nested uniforms
     * .map - nested uniforms by name
     *
     *
     * Methods of all nodes except the top-level container:
     *
     * .setValue( gl, value, [textures] )
     *
     * 		uploads a uniform value(s)
     *  	the 'textures' parameter is needed for sampler uniforms
     *
     *
     * Static methods of the top-level container (textures factorizations):
     *
     * .upload( gl, seq, values, textures )
     *
     * 		sets uniforms in 'seq' to 'values[id].value'
     *
     * .seqWithValue( seq, values ) : filteredSeq
     *
     * 		filters 'seq' entries with corresponding entry in values
     *
     *
     * Methods of the top-level container (textures factorizations):
     *
     * .setValue( gl, name, value, textures )
     *
     * 		sets uniform with  name 'name' to 'value'
     *
     * .setOptional( gl, obj, prop )
     *
     * 		like .set for an optional property of the object
     *
     */
    var emptyTexture = /*@__PURE__*/ new Texture( );
    var emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture( );
    var empty3dTexture = /*@__PURE__*/ new Data3DTexture( );
    var emptyCubeTexture = /*@__PURE__*/ new CubeTexture( ); // --- Utilities ---
    // Array Caches (provide typed arrays for temporary by size)
    var arrayCacheF32 = [ ];
    var arrayCacheI32 = [ ]; // Float32Array caches used for uploading Matrix uniforms
    var mat4array = new Float32Array( 16 );
    var mat3array = new Float32Array( 9 );
    var mat2array = new Float32Array( 4 ); // Flattening for arrays of vectors and matrices
    function flatten( array, nBlocks, blockSize ) {
        var firstElem = array[ 0 ];
        if ( firstElem <= 0 || firstElem > 0 ) return array; // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983
        var n = nBlocks * blockSize;
        var r = arrayCacheF32[ n ];
        if ( r === undefined ) {
            r = new Float32Array( n );
            arrayCacheF32[ n ] = r;
        }
        if ( nBlocks !== 0 ) {
            firstElem.toArray( r, 0 );
            for ( var _i99 = 1, offset = 0; _i99 !== nBlocks; ++_i99 ) {
                offset += blockSize;
                array[ _i99 ].toArray( r, offset );
            }
        }
        return r;
    }

    function arraysEqual( a, b ) {
        if ( a.length !== b.length ) return false;
        for ( var _i100 = 0, l = a.length; _i100 < l; _i100++ ) {
            if ( a[ _i100 ] !== b[ _i100 ] ) return false;
        }
        return true;
    }

    function copyArray( a, b ) {
        for ( var _i101 = 0, l = b.length; _i101 < l; _i101++ ) {
            a[ _i101 ] = b[ _i101 ];
        }
    } // Texture unit allocation
    function allocTexUnits( textures, n ) {
        var r = arrayCacheI32[ n ];
        if ( r === undefined ) {
            r = new Int32Array( n );
            arrayCacheI32[ n ] = r;
        }
        for ( var _i102 = 0; _i102 !== n; ++_i102 ) {
            r[ _i102 ] = textures.allocateTextureUnit( );
        }
        return r;
    } // --- Setters ---
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    // Single scalar
    function setValueV1f( gl, v ) {
        var cache = this.cache;
        if ( cache[ 0 ] === v ) return;
        gl.uniform1f( this.addr, v );
        cache[ 0 ] = v;
    } // Single float vector (from flat array or THREE.VectorN)
    function setValueV2f( gl, v ) {
        var cache = this.cache;
        if ( v.x !== undefined ) {
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {
                gl.uniform2f( this.addr, v.x, v.y );
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
            }
        } else {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniform2fv( this.addr, v );
            copyArray( cache, v );
        }
    }

    function setValueV3f( gl, v ) {
        var cache = this.cache;
        if ( v.x !== undefined ) {
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {
                gl.uniform3f( this.addr, v.x, v.y, v.z );
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
                cache[ 2 ] = v.z;
            }
        } else if ( v.r !== undefined ) {
            if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {
                gl.uniform3f( this.addr, v.r, v.g, v.b );
                cache[ 0 ] = v.r;
                cache[ 1 ] = v.g;
                cache[ 2 ] = v.b;
            }
        } else {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniform3fv( this.addr, v );
            copyArray( cache, v );
        }
    }

    function setValueV4f( gl, v ) {
        var cache = this.cache;
        if ( v.x !== undefined ) {
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {
                gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
                cache[ 2 ] = v.z;
                cache[ 3 ] = v.w;
            }
        } else {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniform4fv( this.addr, v );
            copyArray( cache, v );
        }
    } // Single matrix (from flat array or THREE.MatrixN)
    function setValueM2( gl, v ) {
        var cache = this.cache;
        var elements = v.elements;
        if ( elements === undefined ) {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniformMatrix2fv( this.addr, false, v );
            copyArray( cache, v );
        } else {
            if ( arraysEqual( cache, elements ) ) return;
            mat2array.set( elements );
            gl.uniformMatrix2fv( this.addr, false, mat2array );
            copyArray( cache, elements );
        }
    }

    function setValueM3( gl, v ) {
        var cache = this.cache;
        var elements = v.elements;
        if ( elements === undefined ) {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniformMatrix3fv( this.addr, false, v );
            copyArray( cache, v );
        } else {
            if ( arraysEqual( cache, elements ) ) return;
            mat3array.set( elements );
            gl.uniformMatrix3fv( this.addr, false, mat3array );
            copyArray( cache, elements );
        }
    }

    function setValueM4( gl, v ) {
        var cache = this.cache;
        var elements = v.elements;
        if ( elements === undefined ) {
            if ( arraysEqual( cache, v ) ) return;
            gl.uniformMatrix4fv( this.addr, false, v );
            copyArray( cache, v );
        } else {
            if ( arraysEqual( cache, elements ) ) return;
            mat4array.set( elements );
            gl.uniformMatrix4fv( this.addr, false, mat4array );
            copyArray( cache, elements );
        }
    } // Single integer / boolean
    function setValueV1i( gl, v ) {
        var cache = this.cache;
        if ( cache[ 0 ] === v ) return;
        gl.uniform1i( this.addr, v );
        cache[ 0 ] = v;
    } // Single integer / boolean vector (from flat array)
    function setValueV2i( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform2iv( this.addr, v );
        copyArray( cache, v );
    }

    function setValueV3i( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform3iv( this.addr, v );
        copyArray( cache, v );
    }

    function setValueV4i( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform4iv( this.addr, v );
        copyArray( cache, v );
    } // Single unsigned integer
    function setValueV1ui( gl, v ) {
        var cache = this.cache;
        if ( cache[ 0 ] === v ) return;
        gl.uniform1ui( this.addr, v );
        cache[ 0 ] = v;
    } // Single unsigned integer vector (from flat array)
    function setValueV2ui( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform2uiv( this.addr, v );
        copyArray( cache, v );
    }

    function setValueV3ui( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform3uiv( this.addr, v );
        copyArray( cache, v );
    }

    function setValueV4ui( gl, v ) {
        var cache = this.cache;
        if ( arraysEqual( cache, v ) ) return;
        gl.uniform4uiv( this.addr, v );
        copyArray( cache, v );
    } // Single texture (2D / Cube)
    function setValueT1( gl, v, textures ) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit( );
        if ( cache[ 0 ] !== unit ) {
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
        }
        textures.setTexture2D( v || emptyTexture, unit );
    }

    function setValueT3D1( gl, v, textures ) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit( );
        if ( cache[ 0 ] !== unit ) {
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
        }
        textures.setTexture3D( v || empty3dTexture, unit );
    }

    function setValueT6( gl, v, textures ) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit( );
        if ( cache[ 0 ] !== unit ) {
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
        }
        textures.setTextureCube( v || emptyCubeTexture, unit );
    }

    function setValueT2DArray1( gl, v, textures ) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit( );
        if ( cache[ 0 ] !== unit ) {
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
        }
        textures.setTexture2DArray( v || emptyArrayTexture, unit );
    } // Helper to pick the right setter for the singular case
    function getSingularSetter( type ) {
        switch ( type ) {
            case 0x1406:
                return setValueV1f; // FLOAT
            case 0x8b50:
                return setValueV2f; // _VEC2
            case 0x8b51:
                return setValueV3f; // _VEC3
            case 0x8b52:
                return setValueV4f; // _VEC4
            case 0x8b5a:
                return setValueM2; // _MAT2
            case 0x8b5b:
                return setValueM3; // _MAT3
            case 0x8b5c:
                return setValueM4; // _MAT4
            case 0x1404:
            case 0x8b56:
                return setValueV1i; // INT, BOOL
            case 0x8b53:
            case 0x8b57:
                return setValueV2i; // _VEC2
            case 0x8b54:
            case 0x8b58:
                return setValueV3i; // _VEC3
            case 0x8b55:
            case 0x8b59:
                return setValueV4i; // _VEC4
            case 0x1405:
                return setValueV1ui; // UINT
            case 0x8dc6:
                return setValueV2ui; // _VEC2
            case 0x8dc7:
                return setValueV3ui; // _VEC3
            case 0x8dc8:
                return setValueV4ui; // _VEC4
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1;
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                return setValueT3D1;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6;
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                return setValueT2DArray1;
        }
    } // Array of scalars
    function setValueV1fArray( gl, v ) {
        gl.uniform1fv( this.addr, v );
    } // Array of vectors (from flat array or array of THREE.VectorN)
    function setValueV2fArray( gl, v ) {
        var data = flatten( v, this.size, 2 );
        gl.uniform2fv( this.addr, data );
    }

    function setValueV3fArray( gl, v ) {
        var data = flatten( v, this.size, 3 );
        gl.uniform3fv( this.addr, data );
    }

    function setValueV4fArray( gl, v ) {
        var data = flatten( v, this.size, 4 );
        gl.uniform4fv( this.addr, data );
    } // Array of matrices (from flat array or array of THREE.MatrixN)
    function setValueM2Array( gl, v ) {
        var data = flatten( v, this.size, 4 );
        gl.uniformMatrix2fv( this.addr, false, data );
    }

    function setValueM3Array( gl, v ) {
        var data = flatten( v, this.size, 9 );
        gl.uniformMatrix3fv( this.addr, false, data );
    }

    function setValueM4Array( gl, v ) {
        var data = flatten( v, this.size, 16 );
        gl.uniformMatrix4fv( this.addr, false, data );
    } // Array of integer / boolean
    function setValueV1iArray( gl, v ) {
        gl.uniform1iv( this.addr, v );
    } // Array of integer / boolean vectors (from flat array)
    function setValueV2iArray( gl, v ) {
        gl.uniform2iv( this.addr, v );
    }

    function setValueV3iArray( gl, v ) {
        gl.uniform3iv( this.addr, v );
    }

    function setValueV4iArray( gl, v ) {
        gl.uniform4iv( this.addr, v );
    } // Array of unsigned integer
    function setValueV1uiArray( gl, v ) {
        gl.uniform1uiv( this.addr, v );
    } // Array of unsigned integer vectors (from flat array)
    function setValueV2uiArray( gl, v ) {
        gl.uniform2uiv( this.addr, v );
    }

    function setValueV3uiArray( gl, v ) {
        gl.uniform3uiv( this.addr, v );
    }

    function setValueV4uiArray( gl, v ) {
        gl.uniform4uiv( this.addr, v );
    } // Array of textures (2D / 3D / Cube / 2DArray)
    function setValueT1Array( gl, v, textures ) {
        var n = v.length;
        var units = allocTexUnits( textures, n );
        gl.uniform1iv( this.addr, units );
        for ( var _i103 = 0; _i103 !== n; ++_i103 ) {
            textures.setTexture2D( v[ _i103 ] || emptyTexture, units[ _i103 ] );
        }
    }

    function setValueT3DArray( gl, v, textures ) {
        var n = v.length;
        var units = allocTexUnits( textures, n );
        gl.uniform1iv( this.addr, units );
        for ( var _i104 = 0; _i104 !== n; ++_i104 ) {
            textures.setTexture3D( v[ _i104 ] || empty3dTexture, units[ _i104 ] );
        }
    }

    function setValueT6Array( gl, v, textures ) {
        var n = v.length;
        var units = allocTexUnits( textures, n );
        gl.uniform1iv( this.addr, units );
        for ( var _i105 = 0; _i105 !== n; ++_i105 ) {
            textures.setTextureCube( v[ _i105 ] || emptyCubeTexture, units[ _i105 ] );
        }
    }

    function setValueT2DArrayArray( gl, v, textures ) {
        var n = v.length;
        var units = allocTexUnits( textures, n );
        gl.uniform1iv( this.addr, units );
        for ( var _i106 = 0; _i106 !== n; ++_i106 ) {
            textures.setTexture2DArray( v[ _i106 ] || emptyArrayTexture, units[ _i106 ] );
        }
    } // Helper to pick the right setter for a pure (bottom-level) array
    function getPureArraySetter( type ) {
        switch ( type ) {
            case 0x1406:
                return setValueV1fArray; // FLOAT
            case 0x8b50:
                return setValueV2fArray; // _VEC2
            case 0x8b51:
                return setValueV3fArray; // _VEC3
            case 0x8b52:
                return setValueV4fArray; // _VEC4
            case 0x8b5a:
                return setValueM2Array; // _MAT2
            case 0x8b5b:
                return setValueM3Array; // _MAT3
            case 0x8b5c:
                return setValueM4Array; // _MAT4
            case 0x1404:
            case 0x8b56:
                return setValueV1iArray; // INT, BOOL
            case 0x8b53:
            case 0x8b57:
                return setValueV2iArray; // _VEC2
            case 0x8b54:
            case 0x8b58:
                return setValueV3iArray; // _VEC3
            case 0x8b55:
            case 0x8b59:
                return setValueV4iArray; // _VEC4
            case 0x1405:
                return setValueV1uiArray; // UINT
            case 0x8dc6:
                return setValueV2uiArray; // _VEC2
            case 0x8dc7:
                return setValueV3uiArray; // _VEC3
            case 0x8dc8:
                return setValueV4uiArray; // _VEC4
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1Array;
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                return setValueT3DArray;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6Array;
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                return setValueT2DArrayArray;
        }
    } // --- Uniform Classes ---
    var SingleUniform = /*#__PURE__*/ _createClass( function SingleUniform( id, activeInfo, addr ) {
        _classCallCheck( this, SingleUniform );
        this.id = id;
        this.addr = addr;
        this.cache = [ ];
        this.setValue = getSingularSetter( activeInfo.type ); // this.path = activeInfo.name; // DEBUG
    } );
    var PureArrayUniform = /*#__PURE__*/ _createClass( function PureArrayUniform( id, activeInfo, addr ) {
        _classCallCheck( this, PureArrayUniform );
        this.id = id;
        this.addr = addr;
        this.cache = [ ];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter( activeInfo.type ); // this.path = activeInfo.name; // DEBUG
    } );
    var StructuredUniform = /*#__PURE__*/ function( ) {
        function StructuredUniform( id ) {
            _classCallCheck( this, StructuredUniform );
            this.id = id;
            this.seq = [ ];
            this.map = {};
        }
        _createClass( StructuredUniform, [ {
            key: "setValue",
            value: function setValue( gl, value, textures ) {
                var seq = this.seq;
                for ( var _i107 = 0, n = seq.length; _i107 !== n; ++_i107 ) {
                    var u = seq[ _i107 ];
                    u.setValue( gl, value[ u.id ], textures );
                }
            }
        } ] );
        return StructuredUniform;
    }( ); // --- Top-level ---
    // Parser - builds up the property tree from the path strings
    var RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.
    function addUniform( container, uniformObject ) {
        container.seq.push( uniformObject );
        container.map[ uniformObject.id ] = uniformObject;
    }

    function parseUniform( activeInfo, addr, container ) {
        var path = activeInfo.name,
            pathLength = path.length; // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;
        while ( true ) {
            var match = RePathPart.exec( path ),
                matchEnd = RePathPart.lastIndex;
            var id = match[ 1 ];
            var idIsIndex = match[ 2 ] === ']',
                subscript = match[ 3 ];
            if ( idIsIndex ) id = id | 0; // convert to integer
            if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) { // bare name or "pure" bottom-level array "[0]" suffix
                addUniform( container, subscript === undefined ? new SingleUniform( id, activeInfo, addr ) : new PureArrayUniform( id, activeInfo, addr ) );
                break;
            } else { // step into inner node / create it in case it doesn't exist
                var map = container.map;
                var next = map[ id ];
                if ( next === undefined ) {
                    next = new StructuredUniform( id );
                    addUniform( container, next );
                }
                container = next;
            }
        }
    } // Root Container
    var WebGLUniforms = /*#__PURE__*/ function( ) {
        function WebGLUniforms( gl, program ) {
            _classCallCheck( this, WebGLUniforms );
            this.seq = [ ];
            this.map = {};
            var n = gl.getProgramParameter( program, 35718 );
            for ( var _i108 = 0; _i108 < n; ++_i108 ) {
                var info = gl.getActiveUniform( program, _i108 ),
                    addr = gl.getUniformLocation( program, info.name );
                parseUniform( info, addr, this );
            }
        }
        _createClass( WebGLUniforms, [ {
            key: "setValue",
            value: function setValue( gl, name, value, textures ) {
                var u = this.map[ name ];
                if ( u !== undefined ) u.setValue( gl, value, textures );
            }
        }, {
            key: "setOptional",
            value: function setOptional( gl, object, name ) {
                var v = object[ name ];
                if ( v !== undefined ) this.setValue( gl, name, v );
            }
        } ], [ {
            key: "upload",
            value: function upload( gl, seq, values, textures ) {
                for ( var _i109 = 0, n = seq.length; _i109 !== n; ++_i109 ) {
                    var u = seq[ _i109 ],
                        v = values[ u.id ];
                    if ( v.needsUpdate !== false ) { // note: always updating when .needsUpdate is undefined
                        u.setValue( gl, v.value, textures );
                    }
                }
            }
        }, {
            key: "seqWithValue",
            value: function seqWithValue( seq, values ) {
                var r = [ ];
                for ( var _i110 = 0, n = seq.length; _i110 !== n; ++_i110 ) {
                    var u = seq[ _i110 ];
                    if ( u.id in values ) r.push( u );
                }
                return r;
            }
        } ] );
        return WebGLUniforms;
    }( );

    function WebGLShader( gl, type, string ) {
        var shader = gl.createShader( type );
        gl.shaderSource( shader, string );
        gl.compileShader( shader );
        return shader;
    }
    var programIdCount = 0;

    function handleSource( string, errorLine ) {
        var lines = string.split( '\n' );
        var lines2 = [ ];
        var from = Math.max( errorLine - 6, 0 );
        var to = Math.min( errorLine + 6, lines.length );
        for ( var _i111 = from; _i111 < to; _i111++ ) {
            var line = _i111 + 1;
            lines2.push( "".concat( line === errorLine ? '>' : ' ', " " ).concat( line, ": " ).concat( lines[ _i111 ] ) );
        }
        return lines2.join( '\n' );
    }

    function getEncodingComponents( encoding ) {
        switch ( encoding ) {
            case LinearEncoding:
                return [ 'Linear', '( value )' ];
            case sRGBEncoding:
                return [ 'sRGB', '( value )' ];
            default:
                console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
                return [ 'Linear', '( value )' ];
        }
    }

    function getShaderErrors( gl, shader, type ) {
        var status = gl.getShaderParameter( shader, 35713 );
        var errors = gl.getShaderInfoLog( shader ).trim( );
        if ( status && errors === '' ) return '';
        var errorMatches = /ERROR: 0:(\d+)/.exec( errors );
        if ( errorMatches ) { // --enable-privileged-webgl-extension
            // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
            var errorLine = parseInt( errorMatches[ 1 ] );
            return type.toUpperCase( ) + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );
        } else {
            return errors;
        }
    }

    function getTexelEncodingFunction( functionName, encoding ) {
        var components = getEncodingComponents( encoding );
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';
    }

    function getToneMappingFunction( functionName, toneMapping ) {
        var toneMappingName;
        switch ( toneMapping ) {
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            case ACESFilmicToneMapping:
                toneMappingName = 'ACESFilmic';
                break;
            case CustomToneMapping:
                toneMappingName = 'Custom';
                break;
            default:
                console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
                toneMappingName = 'Linear';
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }

    function generateExtensions( parameters ) {
        var chunks = [ parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', ( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', ( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : '' ];
        return chunks.filter( filterEmptyLine ).join( '\n' );
    }

    function generateDefines( defines ) {
        var chunks = [ ];
        for ( var name in defines ) {
            var _value4 = defines[ name ];
            if ( _value4 === false ) continue;
            chunks.push( '#define ' + name + ' ' + _value4 );
        }
        return chunks.join( '\n' );
    }

    function fetchAttributeLocations( gl, program ) {
        var attributes = {};
        var n = gl.getProgramParameter( program, 35721 );
        for ( var _i112 = 0; _i112 < n; _i112++ ) {
            var info = gl.getActiveAttrib( program, _i112 );
            var name = info.name;
            var locationSize = 1;
            if ( info.type === 35674 ) locationSize = 2;
            if ( info.type === 35675 ) locationSize = 3;
            if ( info.type === 35676 ) locationSize = 4; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
            attributes[ name ] = {
                type: info.type,
                location: gl.getAttribLocation( program, name ),
                locationSize: locationSize
            };
        }
        return attributes;
    }

    function filterEmptyLine( string ) {
        return string !== '';
    }

    function replaceLightNums( string, parameters ) {
        return string.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights ).replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights ).replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights ).replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights ).replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights ).replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows ).replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows ).replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );
    }

    function replaceClippingPlaneNums( string, parameters ) {
        return string.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes ).replace( /UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection );
    } // Resolve Includes
    var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function resolveIncludes( string ) {
        return string.replace( includePattern, includeReplacer );
    }

    function includeReplacer( match, include ) {
        var string = ShaderChunk[ include ];
        if ( string === undefined ) {
            throw new Error( 'Can not resolve #include <' + include + '>' );
        }
        return resolveIncludes( string );
    } // Unroll Loops
    var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function unrollLoops( string ) {
        return string.replace( unrollLoopPattern, loopReplacer ).replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );
    }

    function deprecatedLoopReplacer( match, start, end, snippet ) {
        console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
        return loopReplacer( match, start, end, snippet );
    }

    function loopReplacer( match, start, end, snippet ) {
        var string = '';
        for ( var _i113 = parseInt( start ); _i113 < parseInt( end ); _i113++ ) {
            string += snippet.replace( /\[\s*i\s*\]/g, '[ ' + _i113 + ' ]' ).replace( /UNROLLED_LOOP_INDEX/g, _i113 );
        }
        return string;
    } //
    function generatePrecision( parameters ) {
        var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
        if ( parameters.precision === 'highp' ) {
            precisionstring += '\n#define HIGH_PRECISION';
        } else if ( parameters.precision === 'mediump' ) {
            precisionstring += '\n#define MEDIUM_PRECISION';
        } else if ( parameters.precision === 'lowp' ) {
            precisionstring += '\n#define LOW_PRECISION';
        }
        return precisionstring;
    }

    function generateShadowMapTypeDefine( parameters ) {
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if ( parameters.shadowMapType === PCFShadowMap ) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        } else if ( parameters.shadowMapType === VSMShadowMap ) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
        }
        return shadowMapTypeDefine;
    }

    function generateEnvMapTypeDefine( parameters ) {
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        if ( parameters.envMap ) {
            switch ( parameters.envMapMode ) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
                case CubeUVReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
            }
        }
        return envMapTypeDefine;
    }

    function generateEnvMapModeDefine( parameters ) {
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        if ( parameters.envMap ) {
            switch ( parameters.envMapMode ) {
                case CubeRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
        }
        return envMapModeDefine;
    }

    function generateEnvMapBlendingDefine( parameters ) {
        var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
        if ( parameters.envMap ) {
            switch ( parameters.combine ) {
                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        return envMapBlendingDefine;
    }

    function generateCubeUVSize( parameters ) {
        var imageHeight = parameters.envMapCubeUVHeight;
        if ( imageHeight === null ) return null;
        var maxMip = Math.log2( imageHeight ) - 2;
        var texelHeight = 1.0 / imageHeight;
        var texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );
        return {
            texelWidth: texelWidth,
            texelHeight: texelHeight,
            maxMip: maxMip
        };
    }

    function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) { // TODO Send this event to Three.js DevTools
        // console.log( 'WebGLProgram', cacheKey );
        var gl = renderer.getContext( );
        var defines = parameters.defines;
        var vertexShader = parameters.vertexShader;
        var fragmentShader = parameters.fragmentShader;
        var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
        var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
        var envMapModeDefine = generateEnvMapModeDefine( parameters );
        var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
        var envMapCubeUVSize = generateCubeUVSize( parameters );
        var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );
        var customDefines = generateDefines( defines );
        var program = gl.createProgram( );
        var prefixVertex, prefixFragment;
        var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
        if ( parameters.isRawShaderMaterial ) {
            prefixVertex = [ customDefines ].filter( filterEmptyLine ).join( '\n' );
            if ( prefixVertex.length > 0 ) {
                prefixVertex += '\n';
            }
            prefixFragment = [ customExtensions, customDefines ].filter( filterEmptyLine ).join( '\n' );
            if ( prefixFragment.length > 0 ) {
                prefixFragment += '\n';
            }
        } else {
            prefixVertex = [ generatePrecision( parameters ), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors && parameters.isWebGL2 ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n' ].filter( filterEmptyLine ).join( '\n' );
            prefixFragment = [ customExtensions, generatePrecision( parameters ), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
                parameters.toneMapping !== NoToneMapping ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
                getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'
            ].filter( filterEmptyLine ).join( '\n' );
        }
        vertexShader = resolveIncludes( vertexShader );
        vertexShader = replaceLightNums( vertexShader, parameters );
        vertexShader = replaceClippingPlaneNums( vertexShader, parameters );
        fragmentShader = resolveIncludes( fragmentShader );
        fragmentShader = replaceLightNums( fragmentShader, parameters );
        fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );
        vertexShader = unrollLoops( vertexShader );
        fragmentShader = unrollLoops( fragmentShader );
        if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) { // GLSL 3.0 conversion for built-in materials and ShaderMaterial
            versionString = '#version 300 es\n';
            prefixVertex = [ 'precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture' ].join( '\n' ) + '\n' + prefixVertex;
            prefixFragment = [ '#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad' ].join( '\n' ) + '\n' + prefixFragment;
        }
        var vertexGlsl = versionString + prefixVertex + vertexShader;
        var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
        // console.log( '*FRAGMENT*', fragmentGlsl );
        var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
        var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );
        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader ); // Force a particular attribute to index 0.
        if ( parameters.index0AttributeName !== undefined ) {
            gl.bindAttribLocation( program, 0, parameters.index0AttributeName );
        } else if ( parameters.morphTargets === true ) { // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );
        }
        gl.linkProgram( program ); // check for link errors
        if ( renderer.debug.checkShaderErrors ) {
            var programLog = gl.getProgramInfoLog( program ).trim( );
            var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim( );
            var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim( );
            var runnable = true;
            var haveDiagnostics = true;
            if ( gl.getProgramParameter( program, 35714 ) === false ) {
                runnable = false;
                var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
                var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );
                console.error( 'THREE.WebGLProgram: Shader Error ' + gl.getError( ) + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors );
            } else if ( programLog !== '' ) {
                console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );
            } else if ( vertexLog === '' || fragmentLog === '' ) {
                haveDiagnostics = false;
            }
            if ( haveDiagnostics ) {
                this.diagnostics = {
                    runnable: runnable,
                    programLog: programLog,
                    vertexShader: {
                        log: vertexLog,
                        prefix: prefixVertex
                    },
                    fragmentShader: {
                        log: fragmentLog,
                        prefix: prefixFragment
                    }
                };
            }
        } // Clean up
        // Crashes in iOS9 and iOS10. #18402
        // gl.detachShader( program, glVertexShader );
        // gl.detachShader( program, glFragmentShader );
        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader ); // set up caching for uniform locations
        var cachedUniforms;
        this.getUniforms = function( ) {
            if ( cachedUniforms === undefined ) {
                cachedUniforms = new WebGLUniforms( gl, program );
            }
            return cachedUniforms;
        }; // set up caching for attribute locations
        var cachedAttributes;
        this.getAttributes = function( ) {
            if ( cachedAttributes === undefined ) {
                cachedAttributes = fetchAttributeLocations( gl, program );
            }
            return cachedAttributes;
        }; // free resource
        this.destroy = function( ) {
            bindingStates.releaseStatesOfProgram( this );
            gl.deleteProgram( program );
            this.program = undefined;
        }; //
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    }
    var _id = 0;
    var WebGLShaderCache = /*#__PURE__*/ function( ) {
        function WebGLShaderCache( ) {
            _classCallCheck( this, WebGLShaderCache );
            this.shaderCache = new Map( );
            this.materialCache = new Map( );
        }
        _createClass( WebGLShaderCache, [ {
            key: "update",
            value: function update( material ) {
                var vertexShader = material.vertexShader;
                var fragmentShader = material.fragmentShader;
                var vertexShaderStage = this._getShaderStage( vertexShader );
                var fragmentShaderStage = this._getShaderStage( fragmentShader );
                var materialShaders = this._getShaderCacheForMaterial( material );
                if ( materialShaders.has( vertexShaderStage ) === false ) {
                    materialShaders.add( vertexShaderStage );
                    vertexShaderStage.usedTimes++;
                }
                if ( materialShaders.has( fragmentShaderStage ) === false ) {
                    materialShaders.add( fragmentShaderStage );
                    fragmentShaderStage.usedTimes++;
                }
                return this;
            }
        }, {
            key: "remove",
            value: function remove( material ) {
                var materialShaders = this.materialCache.get( material );
                var _iterator = _createForOfIteratorHelper( materialShaders ),
                    _step;
                try {
                    for ( _iterator.s( ); !( _step = _iterator.n( ) ).done; ) {
                        var shaderStage = _step.value;
                        shaderStage.usedTimes--;
                        if ( shaderStage.usedTimes === 0 ) this.shaderCache[ "delete" ]( shaderStage.code );
                    }
                } catch ( err ) {
                    _iterator.e( err );
                } finally {
                    _iterator.f( );
                }
                this.materialCache[ "delete" ]( material );
                return this;
            }
        }, {
            key: "getVertexShaderID",
            value: function getVertexShaderID( material ) {
                return this._getShaderStage( material.vertexShader ).id;
            }
        }, {
            key: "getFragmentShaderID",
            value: function getFragmentShaderID( material ) {
                return this._getShaderStage( material.fragmentShader ).id;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.shaderCache.clear( );
                this.materialCache.clear( );
            }
        }, {
            key: "_getShaderCacheForMaterial",
            value: function _getShaderCacheForMaterial( material ) {
                var cache = this.materialCache;
                if ( cache.has( material ) === false ) {
                    cache.set( material, new Set( ) );
                }
                return cache.get( material );
            }
        }, {
            key: "_getShaderStage",
            value: function _getShaderStage( code ) {
                var cache = this.shaderCache;
                if ( cache.has( code ) === false ) {
                    var stage = new WebGLShaderStage( code );
                    cache.set( code, stage );
                }
                return cache.get( code );
            }
        } ] );
        return WebGLShaderCache;
    }( );
    var WebGLShaderStage = /*#__PURE__*/ _createClass( function WebGLShaderStage( code ) {
        _classCallCheck( this, WebGLShaderStage );
        this.id = _id++;
        this.code = code;
        this.usedTimes = 0;
    } );

    function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {
        var _programLayers = new Layers( );
        var _customShaders = new WebGLShaderCache( );
        var programs = [ ];
        var isWebGL2 = capabilities.isWebGL2;
        var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        var vertexTextures = capabilities.vertexTextures;
        var precision = capabilities.precision;
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
        };

        function getParameters( material, lights, shadows, scene, object ) {
            var fog = scene.fog;
            var geometry = object.geometry;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
            var envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
            var shaderID = shaderIDs[ material.type ]; // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)
            if ( material.precision !== null ) {
                precision = capabilities.getMaxPrecision( material.precision );
                if ( precision !== material.precision ) {
                    console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
                }
            } //
            var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
            var morphTextureStride = 0;
            if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
            if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
            if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3; //
            var vertexShader, fragmentShader;
            var customVertexShaderID, customFragmentShaderID;
            if ( shaderID ) {
                var shader = ShaderLib[ shaderID ];
                vertexShader = shader.vertexShader;
                fragmentShader = shader.fragmentShader;
            } else {
                vertexShader = material.vertexShader;
                fragmentShader = material.fragmentShader;
                _customShaders.update( material );
                customVertexShaderID = _customShaders.getVertexShaderID( material );
                customFragmentShaderID = _customShaders.getFragmentShaderID( material );
            }
            var currentRenderTarget = renderer.getRenderTarget( );
            var useAlphaTest = material.alphaTest > 0;
            var useClearcoat = material.clearcoat > 0;
            var useIridescence = material.iridescence > 0;
            var parameters = {
                isWebGL2: isWebGL2,
                shaderID: shaderID,
                shaderName: material.type,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                defines: material.defines,
                customVertexShaderID: customVertexShaderID,
                customFragmentShaderID: customFragmentShaderID,
                isRawShaderMaterial: material.isRawShaderMaterial === true,
                glslVersion: material.glslVersion,
                precision: precision,
                instancing: object.isInstancedMesh === true,
                instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
                supportsVertexTextures: vertexTextures,
                outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
                map: !!material.map,
                matcap: !!material.matcap,
                envMap: !!envMap,
                envMapMode: envMap && envMap.mapping,
                envMapCubeUVHeight: envMapCubeUVHeight,
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
                clearcoat: useClearcoat,
                clearcoatMap: useClearcoat && !!material.clearcoatMap,
                clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
                clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
                iridescence: useIridescence,
                iridescenceMap: useIridescence && !!material.iridescenceMap,
                iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                specularIntensityMap: !!material.specularIntensityMap,
                specularColorMap: !!material.specularColorMap,
                opaque: material.transparent === false && material.blending === NormalBlending,
                alphaMap: !!material.alphaMap,
                alphaTest: useAlphaTest,
                gradientMap: !!material.gradientMap,
                sheen: material.sheen > 0,
                sheenColorMap: !!material.sheenColorMap,
                sheenRoughnessMap: !!material.sheenRoughnessMap,
                transmission: material.transmission > 0,
                transmissionMap: !!material.transmissionMap,
                thicknessMap: !!material.thicknessMap,
                combine: material.combine,
                vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
                vertexColors: material.vertexColors,
                vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
                vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
                uvsVertexOnly: !( !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap ) && !!material.displacementMap,
                fog: !!fog,
                useFog: material.fog === true,
                fogExp2: fog && fog.isFogExp2,
                flatShading: !!material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: logarithmicDepthBuffer,
                skinning: object.isSkinnedMesh === true,
                morphTargets: geometry.morphAttributes.position !== undefined,
                morphNormals: geometry.morphAttributes.normal !== undefined,
                morphColors: geometry.morphAttributes.color !== undefined,
                morphTargetsCount: morphTargetsCount,
                morphTextureStride: morphTextureStride,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numDirLightShadows: lights.directionalShadowMap.length,
                numPointLightShadows: lights.pointShadowMap.length,
                numSpotLightShadows: lights.spotShadowMap.length,
                numClippingPlanes: clipping.numPlanes,
                numClipIntersection: clipping.numIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                useDepthPacking: !!material.depthPacking,
                depthPacking: material.depthPacking || 0,
                index0AttributeName: material.index0AttributeName,
                extensionDerivatives: material.extensions && material.extensions.derivatives,
                extensionFragDepth: material.extensions && material.extensions.fragDepth,
                extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
                extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
                rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
                rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),
                customProgramCacheKey: material.customProgramCacheKey( )
            };
            return parameters;
        }

        function getProgramCacheKey( parameters ) {
            var array = [ ];
            if ( parameters.shaderID ) {
                array.push( parameters.shaderID );
            } else {
                array.push( parameters.customVertexShaderID );
                array.push( parameters.customFragmentShaderID );
            }
            if ( parameters.defines !== undefined ) {
                for ( var name in parameters.defines ) {
                    array.push( name );
                    array.push( parameters.defines[ name ] );
                }
            }
            if ( parameters.isRawShaderMaterial === false ) {
                getProgramCacheKeyParameters( array, parameters );
                getProgramCacheKeyBooleans( array, parameters );
                array.push( renderer.outputEncoding );
            }
            array.push( parameters.customProgramCacheKey );
            return array.join( );
        }

        function getProgramCacheKeyParameters( array, parameters ) {
            array.push( parameters.precision );
            array.push( parameters.outputEncoding );
            array.push( parameters.envMapMode );
            array.push( parameters.envMapCubeUVHeight );
            array.push( parameters.combine );
            array.push( parameters.vertexUvs );
            array.push( parameters.fogExp2 );
            array.push( parameters.sizeAttenuation );
            array.push( parameters.morphTargetsCount );
            array.push( parameters.morphAttributeCount );
            array.push( parameters.numDirLights );
            array.push( parameters.numPointLights );
            array.push( parameters.numSpotLights );
            array.push( parameters.numHemiLights );
            array.push( parameters.numRectAreaLights );
            array.push( parameters.numDirLightShadows );
            array.push( parameters.numPointLightShadows );
            array.push( parameters.numSpotLightShadows );
            array.push( parameters.shadowMapType );
            array.push( parameters.toneMapping );
            array.push( parameters.numClippingPlanes );
            array.push( parameters.numClipIntersection );
            array.push( parameters.depthPacking );
        }

        function getProgramCacheKeyBooleans( array, parameters ) {
            _programLayers.disableAll( );
            if ( parameters.isWebGL2 ) _programLayers.enable( 0 );
            if ( parameters.supportsVertexTextures ) _programLayers.enable( 1 );
            if ( parameters.instancing ) _programLayers.enable( 2 );
            if ( parameters.instancingColor ) _programLayers.enable( 3 );
            if ( parameters.map ) _programLayers.enable( 4 );
            if ( parameters.matcap ) _programLayers.enable( 5 );
            if ( parameters.envMap ) _programLayers.enable( 6 );
            if ( parameters.lightMap ) _programLayers.enable( 7 );
            if ( parameters.aoMap ) _programLayers.enable( 8 );
            if ( parameters.emissiveMap ) _programLayers.enable( 9 );
            if ( parameters.bumpMap ) _programLayers.enable( 10 );
            if ( parameters.normalMap ) _programLayers.enable( 11 );
            if ( parameters.objectSpaceNormalMap ) _programLayers.enable( 12 );
            if ( parameters.tangentSpaceNormalMap ) _programLayers.enable( 13 );
            if ( parameters.clearcoat ) _programLayers.enable( 14 );
            if ( parameters.clearcoatMap ) _programLayers.enable( 15 );
            if ( parameters.clearcoatRoughnessMap ) _programLayers.enable( 16 );
            if ( parameters.clearcoatNormalMap ) _programLayers.enable( 17 );
            if ( parameters.iridescence ) _programLayers.enable( 18 );
            if ( parameters.iridescenceMap ) _programLayers.enable( 19 );
            if ( parameters.iridescenceThicknessMap ) _programLayers.enable( 20 );
            if ( parameters.displacementMap ) _programLayers.enable( 21 );
            if ( parameters.specularMap ) _programLayers.enable( 22 );
            if ( parameters.roughnessMap ) _programLayers.enable( 23 );
            if ( parameters.metalnessMap ) _programLayers.enable( 24 );
            if ( parameters.gradientMap ) _programLayers.enable( 25 );
            if ( parameters.alphaMap ) _programLayers.enable( 26 );
            if ( parameters.alphaTest ) _programLayers.enable( 27 );
            if ( parameters.vertexColors ) _programLayers.enable( 28 );
            if ( parameters.vertexAlphas ) _programLayers.enable( 29 );
            if ( parameters.vertexUvs ) _programLayers.enable( 30 );
            if ( parameters.vertexTangents ) _programLayers.enable( 31 );
            if ( parameters.uvsVertexOnly ) _programLayers.enable( 32 );
            if ( parameters.fog ) _programLayers.enable( 33 );
            array.push( _programLayers.mask );
            _programLayers.disableAll( );
            if ( parameters.useFog ) _programLayers.enable( 0 );
            if ( parameters.flatShading ) _programLayers.enable( 1 );
            if ( parameters.logarithmicDepthBuffer ) _programLayers.enable( 2 );
            if ( parameters.skinning ) _programLayers.enable( 3 );
            if ( parameters.morphTargets ) _programLayers.enable( 4 );
            if ( parameters.morphNormals ) _programLayers.enable( 5 );
            if ( parameters.morphColors ) _programLayers.enable( 6 );
            if ( parameters.premultipliedAlpha ) _programLayers.enable( 7 );
            if ( parameters.shadowMapEnabled ) _programLayers.enable( 8 );
            if ( parameters.physicallyCorrectLights ) _programLayers.enable( 9 );
            if ( parameters.doubleSided ) _programLayers.enable( 10 );
            if ( parameters.flipSided ) _programLayers.enable( 11 );
            if ( parameters.useDepthPacking ) _programLayers.enable( 12 );
            if ( parameters.dithering ) _programLayers.enable( 13 );
            if ( parameters.specularIntensityMap ) _programLayers.enable( 14 );
            if ( parameters.specularColorMap ) _programLayers.enable( 15 );
            if ( parameters.transmission ) _programLayers.enable( 16 );
            if ( parameters.transmissionMap ) _programLayers.enable( 17 );
            if ( parameters.thicknessMap ) _programLayers.enable( 18 );
            if ( parameters.sheen ) _programLayers.enable( 19 );
            if ( parameters.sheenColorMap ) _programLayers.enable( 20 );
            if ( parameters.sheenRoughnessMap ) _programLayers.enable( 21 );
            if ( parameters.decodeVideoTexture ) _programLayers.enable( 22 );
            if ( parameters.opaque ) _programLayers.enable( 23 );
            array.push( _programLayers.mask );
        }

        function getUniforms( material ) {
            var shaderID = shaderIDs[ material.type ];
            var uniforms;
            if ( shaderID ) {
                var shader = ShaderLib[ shaderID ];
                uniforms = UniformsUtils.clone( shader.uniforms );
            } else {
                uniforms = material.uniforms;
            }
            return uniforms;
        }

        function acquireProgram( parameters, cacheKey ) {
            var program; // Check if code has been already compiled
            for ( var p = 0, pl = programs.length; p < pl; p++ ) {
                var preexistingProgram = programs[ p ];
                if ( preexistingProgram.cacheKey === cacheKey ) {
                    program = preexistingProgram;
                    ++program.usedTimes;
                    break;
                }
            }
            if ( program === undefined ) {
                program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
                programs.push( program );
            }
            return program;
        }

        function releaseProgram( program ) {
            if ( --program.usedTimes === 0 ) { // Remove from unordered set
                var _i114 = programs.indexOf( program );
                programs[ _i114 ] = programs[ programs.length - 1 ];
                programs.pop( ); // Free WebGL resources
                program.destroy( );
            }
        }

        function releaseShaderCache( material ) {
            _customShaders.remove( material );
        }

        function dispose( ) {
            _customShaders.dispose( );
        }
        return {
            getParameters: getParameters,
            getProgramCacheKey: getProgramCacheKey,
            getUniforms: getUniforms,
            acquireProgram: acquireProgram,
            releaseProgram: releaseProgram,
            releaseShaderCache: releaseShaderCache, // Exposed for resource monitoring & error feedback via renderer.info:
            programs: programs,
            dispose: dispose
        };
    }

    function WebGLProperties( ) {
        var properties = new WeakMap( );

        function get( object ) {
            var map = properties.get( object );
            if ( map === undefined ) {
                map = {};
                properties.set( object, map );
            }
            return map;
        }

        function remove( object ) {
            properties[ "delete" ]( object );
        }

        function update( object, key, value ) {
            properties.get( object )[ key ] = value;
        }

        function dispose( ) {
            properties = new WeakMap( );
        }
        return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
        };
    }

    function painterSortStable( a, b ) {
        if ( a.groupOrder !== b.groupOrder ) {
            return a.groupOrder - b.groupOrder;
        } else if ( a.renderOrder !== b.renderOrder ) {
            return a.renderOrder - b.renderOrder;
        } else if ( a.material.id !== b.material.id ) {
            return a.material.id - b.material.id;
        } else if ( a.z !== b.z ) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }

    function reversePainterSortStable( a, b ) {
        if ( a.groupOrder !== b.groupOrder ) {
            return a.groupOrder - b.groupOrder;
        } else if ( a.renderOrder !== b.renderOrder ) {
            return a.renderOrder - b.renderOrder;
        } else if ( a.z !== b.z ) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }

    function WebGLRenderList( ) {
        var renderItems = [ ];
        var renderItemsIndex = 0;
        var opaque = [ ];
        var transmissive = [ ];
        var transparent = [ ];

        function init( ) {
            renderItemsIndex = 0;
            opaque.length = 0;
            transmissive.length = 0;
            transparent.length = 0;
        }

        function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {
            var renderItem = renderItems[ renderItemsIndex ];
            if ( renderItem === undefined ) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    groupOrder: groupOrder,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                renderItems[ renderItemsIndex ] = renderItem;
            } else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.groupOrder = groupOrder;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            renderItemsIndex++;
            return renderItem;
        }

        function push( object, geometry, material, groupOrder, z, group ) {
            var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
            if ( material.transmission > 0.0 ) {
                transmissive.push( renderItem );
            } else if ( material.transparent === true ) {
                transparent.push( renderItem );
            } else {
                opaque.push( renderItem );
            }
        }

        function unshift( object, geometry, material, groupOrder, z, group ) {
            var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
            if ( material.transmission > 0.0 ) {
                transmissive.unshift( renderItem );
            } else if ( material.transparent === true ) {
                transparent.unshift( renderItem );
            } else {
                opaque.unshift( renderItem );
            }
        }

        function sort( customOpaqueSort, customTransparentSort ) {
            if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
            if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
            if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );
        }

        function finish( ) { // Clear references from inactive renderItems in the list
            for ( var _i115 = renderItemsIndex, il = renderItems.length; _i115 < il; _i115++ ) {
                var renderItem = renderItems[ _i115 ];
                if ( renderItem.id === null ) break;
                renderItem.id = null;
                renderItem.object = null;
                renderItem.geometry = null;
                renderItem.material = null;
                renderItem.group = null;
            }
        }
        return {
            opaque: opaque,
            transmissive: transmissive,
            transparent: transparent,
            init: init,
            push: push,
            unshift: unshift,
            finish: finish,
            sort: sort
        };
    }

    function WebGLRenderLists( ) {
        var lists = new WeakMap( );

        function get( scene, renderCallDepth ) {
            var list;
            if ( lists.has( scene ) === false ) {
                list = new WebGLRenderList( );
                lists.set( scene, [ list ] );
            } else {
                if ( renderCallDepth >= lists.get( scene ).length ) {
                    list = new WebGLRenderList( );
                    lists.get( scene ).push( list );
                } else {
                    list = lists.get( scene )[ renderCallDepth ];
                }
            }
            return list;
        }

        function dispose( ) {
            lists = new WeakMap( );
        }
        return {
            get: get,
            dispose: dispose
        };
    }

    function UniformsCache( ) {
        var lights = {};
        return {
            get: function get( light ) {
                if ( lights[ light.id ] !== undefined ) {
                    return lights[ light.id ];
                }
                var uniforms;
                switch ( light.type ) {
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3( ),
                            color: new Color( )
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3( ),
                            direction: new Vector3( ),
                            color: new Color( ),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3( ),
                            color: new Color( ),
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3( ),
                            skyColor: new Color( ),
                            groundColor: new Color( )
                        };
                        break;
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color( ),
                            position: new Vector3( ),
                            halfWidth: new Vector3( ),
                            halfHeight: new Vector3( )
                        };
                        break;
                }
                lights[ light.id ] = uniforms;
                return uniforms;
            }
        };
    }

    function ShadowUniformsCache( ) {
        var lights = {};
        return {
            get: function get( light ) {
                if ( lights[ light.id ] !== undefined ) {
                    return lights[ light.id ];
                }
                var uniforms;
                switch ( light.type ) {
                    case 'DirectionalLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2( )
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2( )
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2( ),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break; // TODO (abelnation): set RectAreaLight shadow uniforms
                }
                lights[ light.id ] = uniforms;
                return uniforms;
            }
        };
    }
    var nextVersion = 0;

    function shadowCastingLightsFirst( lightA, lightB ) {
        return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );
    }

    function WebGLLights( extensions, capabilities ) {
        var cache = new UniformsCache( );
        var shadowCache = ShadowUniformsCache( );
        var state = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [ 0, 0, 0 ],
            probe: [ ],
            directional: [ ],
            directionalShadow: [ ],
            directionalShadowMap: [ ],
            directionalShadowMatrix: [ ],
            spot: [ ],
            spotShadow: [ ],
            spotShadowMap: [ ],
            spotShadowMatrix: [ ],
            rectArea: [ ],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [ ],
            pointShadow: [ ],
            pointShadowMap: [ ],
            pointShadowMatrix: [ ],
            hemi: [ ]
        };
        for ( var _i116 = 0; _i116 < 9; _i116++ ) {
            state.probe.push( new Vector3( ) );
        }
        var vector3 = new Vector3( );
        var matrix4 = new Matrix4( );
        var matrix42 = new Matrix4( );

        function setup( lights, physicallyCorrectLights ) {
            var r = 0,
                g = 0,
                b = 0;
            for ( var _i117 = 0; _i117 < 9; _i117++ ) {
                state.probe[ _i117 ].set( 0, 0, 0 );
            }
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var numDirectionalShadows = 0;
            var numPointShadows = 0;
            var numSpotShadows = 0;
            lights.sort( shadowCastingLightsFirst ); // artist-friendly light intensity scaling factor
            var scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
            for ( var _i118 = 0, l = lights.length; _i118 < l; _i118++ ) {
                var light = lights[ _i118 ];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if ( light.isAmbientLight ) {
                    r += color.r * intensity * scaleFactor;
                    g += color.g * intensity * scaleFactor;
                    b += color.b * intensity * scaleFactor;
                } else if ( light.isLightProbe ) {
                    for ( var j = 0; j < 9; j++ ) {
                        state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );
                    }
                } else if ( light.isDirectionalLight ) {
                    var uniforms = cache.get( light );
                    uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
                    if ( light.castShadow ) {
                        var shadow = light.shadow;
                        var shadowUniforms = shadowCache.get( light );
                        shadowUniforms.shadowBias = shadow.bias;
                        shadowUniforms.shadowNormalBias = shadow.normalBias;
                        shadowUniforms.shadowRadius = shadow.radius;
                        shadowUniforms.shadowMapSize = shadow.mapSize;
                        state.directionalShadow[ directionalLength ] = shadowUniforms;
                        state.directionalShadowMap[ directionalLength ] = shadowMap;
                        state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
                        numDirectionalShadows++;
                    }
                    state.directional[ directionalLength ] = uniforms;
                    directionalLength++;
                } else if ( light.isSpotLight ) {
                    var _uniforms = cache.get( light );
                    _uniforms.position.setFromMatrixPosition( light.matrixWorld );
                    _uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
                    _uniforms.distance = distance;
                    _uniforms.coneCos = Math.cos( light.angle );
                    _uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
                    _uniforms.decay = light.decay;
                    if ( light.castShadow ) {
                        var _shadow = light.shadow;
                        var _shadowUniforms = shadowCache.get( light );
                        _shadowUniforms.shadowBias = _shadow.bias;
                        _shadowUniforms.shadowNormalBias = _shadow.normalBias;
                        _shadowUniforms.shadowRadius = _shadow.radius;
                        _shadowUniforms.shadowMapSize = _shadow.mapSize;
                        state.spotShadow[ spotLength ] = _shadowUniforms;
                        state.spotShadowMap[ spotLength ] = shadowMap;
                        state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
                        numSpotShadows++;
                    }
                    state.spot[ spotLength ] = _uniforms;
                    spotLength++;
                } else if ( light.isRectAreaLight ) {
                    var _uniforms2 = cache.get( light ); // (a) intensity is the total visible light emitted
                    //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                    // (b) intensity is the brightness of the light
                    _uniforms2.color.copy( color ).multiplyScalar( intensity );
                    _uniforms2.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
                    _uniforms2.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
                    state.rectArea[ rectAreaLength ] = _uniforms2;
                    rectAreaLength++;
                } else if ( light.isPointLight ) {
                    var _uniforms3 = cache.get( light );
                    _uniforms3.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
                    _uniforms3.distance = light.distance;
                    _uniforms3.decay = light.decay;
                    if ( light.castShadow ) {
                        var _shadow2 = light.shadow;
                        var _shadowUniforms2 = shadowCache.get( light );
                        _shadowUniforms2.shadowBias = _shadow2.bias;
                        _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
                        _shadowUniforms2.shadowRadius = _shadow2.radius;
                        _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
                        _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
                        _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
                        state.pointShadow[ pointLength ] = _shadowUniforms2;
                        state.pointShadowMap[ pointLength ] = shadowMap;
                        state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
                        numPointShadows++;
                    }
                    state.point[ pointLength ] = _uniforms3;
                    pointLength++;
                } else if ( light.isHemisphereLight ) {
                    var _uniforms4 = cache.get( light );
                    _uniforms4.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
                    _uniforms4.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );
                    state.hemi[ hemiLength ] = _uniforms4;
                    hemiLength++;
                }
            }
            if ( rectAreaLength > 0 ) {
                if ( capabilities.isWebGL2 ) { // WebGL 2
                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                } else { // WebGL 1
                    if ( extensions.has( 'OES_texture_float_linear' ) === true ) {
                        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                    } else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {
                        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
                    } else {
                        console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );
                    }
                }
            }
            state.ambient[ 0 ] = r;
            state.ambient[ 1 ] = g;
            state.ambient[ 2 ] = b;
            var hash = state.hash;
            if ( hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows ) {
                state.directional.length = directionalLength;
                state.spot.length = spotLength;
                state.rectArea.length = rectAreaLength;
                state.point.length = pointLength;
                state.hemi.length = hemiLength;
                state.directionalShadow.length = numDirectionalShadows;
                state.directionalShadowMap.length = numDirectionalShadows;
                state.pointShadow.length = numPointShadows;
                state.pointShadowMap.length = numPointShadows;
                state.spotShadow.length = numSpotShadows;
                state.spotShadowMap.length = numSpotShadows;
                state.directionalShadowMatrix.length = numDirectionalShadows;
                state.pointShadowMatrix.length = numPointShadows;
                state.spotShadowMatrix.length = numSpotShadows;
                hash.directionalLength = directionalLength;
                hash.pointLength = pointLength;
                hash.spotLength = spotLength;
                hash.rectAreaLength = rectAreaLength;
                hash.hemiLength = hemiLength;
                hash.numDirectionalShadows = numDirectionalShadows;
                hash.numPointShadows = numPointShadows;
                hash.numSpotShadows = numSpotShadows;
                state.version = nextVersion++;
            }
        }

        function setupView( lights, camera ) {
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for ( var _i119 = 0, l = lights.length; _i119 < l; _i119++ ) {
                var light = lights[ _i119 ];
                if ( light.isDirectionalLight ) {
                    var uniforms = state.directional[ directionalLength ];
                    uniforms.direction.setFromMatrixPosition( light.matrixWorld );
                    vector3.setFromMatrixPosition( light.target.matrixWorld );
                    uniforms.direction.sub( vector3 );
                    uniforms.direction.transformDirection( viewMatrix );
                    directionalLength++;
                } else if ( light.isSpotLight ) {
                    var _uniforms5 = state.spot[ spotLength ];
                    _uniforms5.position.setFromMatrixPosition( light.matrixWorld );
                    _uniforms5.position.applyMatrix4( viewMatrix );
                    _uniforms5.direction.setFromMatrixPosition( light.matrixWorld );
                    vector3.setFromMatrixPosition( light.target.matrixWorld );
                    _uniforms5.direction.sub( vector3 );
                    _uniforms5.direction.transformDirection( viewMatrix );
                    spotLength++;
                } else if ( light.isRectAreaLight ) {
                    var _uniforms6 = state.rectArea[ rectAreaLength ];
                    _uniforms6.position.setFromMatrixPosition( light.matrixWorld );
                    _uniforms6.position.applyMatrix4( viewMatrix ); // extract local rotation of light to derive width/height half vectors
                    matrix42.identity( );
                    matrix4.copy( light.matrixWorld );
                    matrix4.premultiply( viewMatrix );
                    matrix42.extractRotation( matrix4 );
                    _uniforms6.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
                    _uniforms6.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
                    _uniforms6.halfWidth.applyMatrix4( matrix42 );
                    _uniforms6.halfHeight.applyMatrix4( matrix42 );
                    rectAreaLength++;
                } else if ( light.isPointLight ) {
                    var _uniforms7 = state.point[ pointLength ];
                    _uniforms7.position.setFromMatrixPosition( light.matrixWorld );
                    _uniforms7.position.applyMatrix4( viewMatrix );
                    pointLength++;
                } else if ( light.isHemisphereLight ) {
                    var _uniforms8 = state.hemi[ hemiLength ];
                    _uniforms8.direction.setFromMatrixPosition( light.matrixWorld );
                    _uniforms8.direction.transformDirection( viewMatrix );
                    hemiLength++;
                }
            }
        }
        return {
            setup: setup,
            setupView: setupView,
            state: state
        };
    }

    function WebGLRenderState( extensions, capabilities ) {
        var lights = new WebGLLights( extensions, capabilities );
        var lightsArray = [ ];
        var shadowsArray = [ ];

        function init( ) {
            lightsArray.length = 0;
            shadowsArray.length = 0;
        }

        function pushLight( light ) {
            lightsArray.push( light );
        }

        function pushShadow( shadowLight ) {
            shadowsArray.push( shadowLight );
        }

        function setupLights( physicallyCorrectLights ) {
            lights.setup( lightsArray, physicallyCorrectLights );
        }

        function setupLightsView( camera ) {
            lights.setupView( lightsArray, camera );
        }
        var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
            lights: lights
        };
        return {
            init: init,
            state: state,
            setupLights: setupLights,
            setupLightsView: setupLightsView,
            pushLight: pushLight,
            pushShadow: pushShadow
        };
    }

    function WebGLRenderStates( extensions, capabilities ) {
        var renderStates = new WeakMap( );

        function get( scene ) {
            var renderCallDepth = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var renderState;
            if ( renderStates.has( scene ) === false ) {
                renderState = new WebGLRenderState( extensions, capabilities );
                renderStates.set( scene, [ renderState ] );
            } else {
                if ( renderCallDepth >= renderStates.get( scene ).length ) {
                    renderState = new WebGLRenderState( extensions, capabilities );
                    renderStates.get( scene ).push( renderState );
                } else {
                    renderState = renderStates.get( scene )[ renderCallDepth ];
                }
            }
            return renderState;
        }

        function dispose( ) {
            renderStates = new WeakMap( );
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    var MeshDepthMaterial = /*#__PURE__*/ function( _Material$3 ) {
        _inherits( MeshDepthMaterial, _Material$3 );
        var _super22 = _createSuper( MeshDepthMaterial );

        function MeshDepthMaterial( parameters ) {
            var _this20;
            _classCallCheck( this, MeshDepthMaterial );
            _this20 = _super22.call( this );
            _this20.isMeshDepthMaterial = true;
            _this20.type = 'MeshDepthMaterial';
            _this20.depthPacking = BasicDepthPacking;
            _this20.map = null;
            _this20.alphaMap = null;
            _this20.displacementMap = null;
            _this20.displacementScale = 1;
            _this20.displacementBias = 0;
            _this20.wireframe = false;
            _this20.wireframeLinewidth = 1;
            _this20.setValues( parameters );
            return _this20;
        }
        _createClass( MeshDepthMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( MeshDepthMaterial.prototype ), "copy", this ).call( this, source );
                this.depthPacking = source.depthPacking;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                return this;
            }
        } ] );
        return MeshDepthMaterial;
    }( Material$1 );
    var MeshDistanceMaterial = /*#__PURE__*/ function( _Material$4 ) {
        _inherits( MeshDistanceMaterial, _Material$4 );
        var _super23 = _createSuper( MeshDistanceMaterial );

        function MeshDistanceMaterial( parameters ) {
            var _this21;
            _classCallCheck( this, MeshDistanceMaterial );
            _this21 = _super23.call( this );
            _this21.isMeshDistanceMaterial = true;
            _this21.type = 'MeshDistanceMaterial';
            _this21.referencePosition = new Vector3( );
            _this21.nearDistance = 1;
            _this21.farDistance = 1000;
            _this21.map = null;
            _this21.alphaMap = null;
            _this21.displacementMap = null;
            _this21.displacementScale = 1;
            _this21.displacementBias = 0;
            _this21.setValues( parameters );
            return _this21;
        }
        _createClass( MeshDistanceMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( MeshDistanceMaterial.prototype ), "copy", this ).call( this, source );
                this.referencePosition.copy( source.referencePosition );
                this.nearDistance = source.nearDistance;
                this.farDistance = source.farDistance;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                return this;
            }
        } ] );
        return MeshDistanceMaterial;
    }( Material$1 );
    var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
    var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

    function WebGLShadowMap( _renderer, _objects, _capabilities ) {
        var _frustum = new Frustum( );
        var _shadowMapSize = new Vector2( ),
            _viewportSize = new Vector2( ),
            _viewport = new Vector4( ),
            _depthMaterial = new MeshDepthMaterial( {
                depthPacking: RGBADepthPacking
            } ),
            _distanceMaterial = new MeshDistanceMaterial( ),
            _materialCache = {},
            _maxTextureSize = _capabilities.maxTextureSize;
        var shadowSide = {
            0: BackSide,
            1: FrontSide,
            2: DoubleSide
        };
        var shadowMaterialVertical = new ShaderMaterial( {
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Vector2( )
                },
                radius: {
                    value: 4.0
                }
            },
            vertexShader: vertex,
            fragmentShader: fragment
        } );
        var shadowMaterialHorizontal = shadowMaterialVertical.clone( );
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        var fullScreenTri = new BufferGeometry( );
        fullScreenTri.setAttribute( 'position', new BufferAttribute( new Float32Array( [ -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5 ] ), 3 ) );
        var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function( lights, scene, camera ) {
            if ( scope.enabled === false ) return;
            if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
            if ( lights.length === 0 ) return;
            var currentRenderTarget = _renderer.getRenderTarget( );
            var activeCubeFace = _renderer.getActiveCubeFace( );
            var activeMipmapLevel = _renderer.getActiveMipmapLevel( );
            var _state = _renderer.state; // Set GL state for depth map.
            _state.setBlending( NoBlending );
            _state.buffers.color.setClear( 1, 1, 1, 1 );
            _state.buffers.depth.setTest( true );
            _state.setScissorTest( false ); // render depth map
            for ( var _i120 = 0, il = lights.length; _i120 < il; _i120++ ) {
                var light = lights[ _i120 ];
                var shadow = light.shadow;
                if ( shadow === undefined ) {
                    console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
                    continue;
                }
                if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;
                _shadowMapSize.copy( shadow.mapSize );
                var shadowFrameExtents = shadow.getFrameExtents( );
                _shadowMapSize.multiply( shadowFrameExtents );
                _viewportSize.copy( shadow.mapSize );
                if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {
                    if ( _shadowMapSize.x > _maxTextureSize ) {
                        _viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
                        _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                        shadow.mapSize.x = _viewportSize.x;
                    }
                    if ( _shadowMapSize.y > _maxTextureSize ) {
                        _viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
                        _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                        shadow.mapSize.y = _viewportSize.y;
                    }
                }
                if ( shadow.map === null ) {
                    var pars = this.type !== VSMShadowMap ? {
                        minFilter: NearestFilter,
                        magFilter: NearestFilter
                    } : {};
                    shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
                    shadow.map.texture.name = light.name + '.shadowMap';
                    shadow.camera.updateProjectionMatrix( );
                }
                _renderer.setRenderTarget( shadow.map );
                _renderer.clear( );
                var viewportCount = shadow.getViewportCount( );
                for ( var vp = 0; vp < viewportCount; vp++ ) {
                    var viewport = shadow.getViewport( vp );
                    _viewport.set( _viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w );
                    _state.viewport( _viewport );
                    shadow.updateMatrices( light, vp );
                    _frustum = shadow.getFrustum( );
                    renderObject( scene, camera, shadow.camera, light, this.type );
                } // do blur pass for VSM
                if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {
                    VSMPass( shadow, camera );
                }
                shadow.needsUpdate = false;
            }
            scope.needsUpdate = false;
            _renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );
        };

        function VSMPass( shadow, camera ) {
            var geometry = _objects.update( fullScreenMesh );
            if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {
                shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
                shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
                shadowMaterialVertical.needsUpdate = true;
                shadowMaterialHorizontal.needsUpdate = true;
            }
            if ( shadow.mapPass === null ) {
                shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );
            } // vertical pass
            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialVertical.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget( shadow.mapPass );
            _renderer.clear( );
            _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null ); // horizontal pass
            shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
            shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget( shadow.map );
            _renderer.clear( );
            _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );
        }

        function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {
            var result = null;
            var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
            if ( customMaterial !== undefined ) {
                result = customMaterial;
            } else {
                result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
            }
            if ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 ) { // in this case we need a unique material instance reflecting the
                // appropriate state
                var keyA = result.uuid,
                    keyB = material.uuid;
                var materialsForVariant = _materialCache[ keyA ];
                if ( materialsForVariant === undefined ) {
                    materialsForVariant = {};
                    _materialCache[ keyA ] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[ keyB ];
                if ( cachedMaterial === undefined ) {
                    cachedMaterial = result.clone( );
                    materialsForVariant[ keyB ] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            if ( type === VSMShadowMap ) {
                result.side = material.shadowSide !== null ? material.shadowSide : material.side;
            } else {
                result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[ material.side ];
            }
            result.alphaMap = material.alphaMap;
            result.alphaTest = material.alphaTest;
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.displacementMap = material.displacementMap;
            result.displacementScale = material.displacementScale;
            result.displacementBias = material.displacementBias;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {
                result.referencePosition.setFromMatrixPosition( light.matrixWorld );
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }

        function renderObject( object, camera, shadowCamera, light, type ) {
            if ( object.visible === false ) return;
            var visible = object.layers.test( camera.layers );
            if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
                if ( ( object.castShadow || object.receiveShadow && type === VSMShadowMap ) && ( !object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
                    object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
                    var geometry = _objects.update( object );
                    var material = object.material;
                    if ( Array.isArray( material ) ) {
                        var groups = geometry.groups;
                        for ( var k = 0, kl = groups.length; k < kl; k++ ) {
                            var group = groups[ k ];
                            var groupMaterial = material[ group.materialIndex ];
                            if ( groupMaterial && groupMaterial.visible ) {
                                var depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );
                                _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
                            }
                        }
                    } else if ( material.visible ) {
                        var _depthMaterial2 = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );
                        _renderer.renderBufferDirect( shadowCamera, null, geometry, _depthMaterial2, object, null );
                    }
                }
            }
            var children = object.children;
            for ( var _i121 = 0, l = children.length; _i121 < l; _i121++ ) {
                renderObject( children[ _i121 ], camera, shadowCamera, light, type );
            }
        }
    }

    function WebGLState( gl, extensions, capabilities ) {
        var _equationToGL, _factorToGL;
        var isWebGL2 = capabilities.isWebGL2;

        function ColorBuffer( ) {
            var locked = false;
            var color = new Vector4( );
            var currentColorMask = null;
            var currentColorClear = new Vector4( 0, 0, 0, 0 );
            return {
                setMask: function setMask( colorMask ) {
                    if ( currentColorMask !== colorMask && !locked ) {
                        gl.colorMask( colorMask, colorMask, colorMask, colorMask );
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function setLocked( lock ) {
                    locked = lock;
                },
                setClear: function setClear( r, g, b, a, premultipliedAlpha ) {
                    if ( premultipliedAlpha === true ) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set( r, g, b, a );
                    if ( currentColorClear.equals( color ) === false ) {
                        gl.clearColor( r, g, b, a );
                        currentColorClear.copy( color );
                    }
                },
                reset: function reset( ) {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set( -1, 0, 0, 0 ); // set to invalid state
                }
            };
        }

        function DepthBuffer( ) {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function setTest( depthTest ) {
                    if ( depthTest ) {
                        enable( 2929 );
                    } else {
                        disable( 2929 );
                    }
                },
                setMask: function setMask( depthMask ) {
                    if ( currentDepthMask !== depthMask && !locked ) {
                        gl.depthMask( depthMask );
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function setFunc( depthFunc ) {
                    if ( currentDepthFunc !== depthFunc ) {
                        if ( depthFunc ) {
                            switch ( depthFunc ) {
                                case NeverDepth:
                                    gl.depthFunc( 512 );
                                    break;
                                case AlwaysDepth:
                                    gl.depthFunc( 519 );
                                    break;
                                case LessDepth:
                                    gl.depthFunc( 513 );
                                    break;
                                case LessEqualDepth:
                                    gl.depthFunc( 515 );
                                    break;
                                case EqualDepth:
                                    gl.depthFunc( 514 );
                                    break;
                                case GreaterEqualDepth:
                                    gl.depthFunc( 518 );
                                    break;
                                case GreaterDepth:
                                    gl.depthFunc( 516 );
                                    break;
                                case NotEqualDepth:
                                    gl.depthFunc( 517 );
                                    break;
                                default:
                                    gl.depthFunc( 515 );
                            }
                        } else {
                            gl.depthFunc( 515 );
                        }
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function setLocked( lock ) {
                    locked = lock;
                },
                setClear: function setClear( depth ) {
                    if ( currentDepthClear !== depth ) {
                        gl.clearDepth( depth );
                        currentDepthClear = depth;
                    }
                },
                reset: function reset( ) {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }

        function StencilBuffer( ) {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function setTest( stencilTest ) {
                    if ( !locked ) {
                        if ( stencilTest ) {
                            enable( 2960 );
                        } else {
                            disable( 2960 );
                        }
                    }
                },
                setMask: function setMask( stencilMask ) {
                    if ( currentStencilMask !== stencilMask && !locked ) {
                        gl.stencilMask( stencilMask );
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function setFunc( stencilFunc, stencilRef, stencilMask ) {
                    if ( currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask ) {
                        gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function setOp( stencilFail, stencilZFail, stencilZPass ) {
                    if ( currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass ) {
                        gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function setLocked( lock ) {
                    locked = lock;
                },
                setClear: function setClear( stencil ) {
                    if ( currentStencilClear !== stencil ) {
                        gl.clearStencil( stencil );
                        currentStencilClear = stencil;
                    }
                },
                reset: function reset( ) {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        } //
        var colorBuffer = new ColorBuffer( );
        var depthBuffer = new DepthBuffer( );
        var stencilBuffer = new StencilBuffer( );
        var enabledCapabilities = {};
        var currentBoundFramebuffers = {};
        var currentDrawbuffers = new WeakMap( );
        var defaultDrawbuffers = [ ];
        var currentProgram = null;
        var currentBlendingEnabled = false;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var maxTextures = gl.getParameter( 35661 );
        var lineWidthAvailable = false;
        var version = 0;
        var glVersion = gl.getParameter( 7938 );
        if ( glVersion.indexOf( 'WebGL' ) !== -1 ) {
            version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
            lineWidthAvailable = version >= 1.0;
        } else if ( glVersion.indexOf( 'OpenGL ES' ) !== -1 ) {
            version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
            lineWidthAvailable = version >= 2.0;
        }
        var currentTextureSlot = null;
        var currentBoundTextures = {};
        var scissorParam = gl.getParameter( 3088 );
        var viewportParam = gl.getParameter( 2978 );
        var currentScissor = new Vector4( ).fromArray( scissorParam );
        var currentViewport = new Vector4( ).fromArray( viewportParam );

        function createTexture( type, target, count ) {
            var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture( );
            gl.bindTexture( type, texture );
            gl.texParameteri( type, 10241, 9728 );
            gl.texParameteri( type, 10240, 9728 );
            for ( var _i122 = 0; _i122 < count; _i122++ ) {
                gl.texImage2D( target + _i122, 0, 6408, 1, 1, 0, 6408, 5121, data );
            }
            return texture;
        }
        var emptyTextures = {};
        emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
        emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 ); // init
        colorBuffer.setClear( 0, 0, 0, 1 );
        depthBuffer.setClear( 1 );
        stencilBuffer.setClear( 0 );
        enable( 2929 );
        depthBuffer.setFunc( LessEqualDepth );
        setFlipSided( false );
        setCullFace( CullFaceBack );
        enable( 2884 );
        setBlending( NoBlending ); //
        function enable( id ) {
            if ( enabledCapabilities[ id ] !== true ) {
                gl.enable( id );
                enabledCapabilities[ id ] = true;
            }
        }

        function disable( id ) {
            if ( enabledCapabilities[ id ] !== false ) {
                gl.disable( id );
                enabledCapabilities[ id ] = false;
            }
        }

        function bindFramebuffer( target, framebuffer ) {
            if ( currentBoundFramebuffers[ target ] !== framebuffer ) {
                gl.bindFramebuffer( target, framebuffer );
                currentBoundFramebuffers[ target ] = framebuffer;
                if ( isWebGL2 ) { // 36009 is equivalent to 36160
                    if ( target === 36009 ) {
                        currentBoundFramebuffers[ 36160 ] = framebuffer;
                    }
                    if ( target === 36160 ) {
                        currentBoundFramebuffers[ 36009 ] = framebuffer;
                    }
                }
                return true;
            }
            return false;
        }

        function drawBuffers( renderTarget, framebuffer ) {
            var drawBuffers = defaultDrawbuffers;
            var needsUpdate = false;
            if ( renderTarget ) {
                drawBuffers = currentDrawbuffers.get( framebuffer );
                if ( drawBuffers === undefined ) {
                    drawBuffers = [ ];
                    currentDrawbuffers.set( framebuffer, drawBuffers );
                }
                if ( renderTarget.isWebGLMultipleRenderTargets ) {
                    var textures = renderTarget.texture;
                    if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {
                        for ( var _i123 = 0, il = textures.length; _i123 < il; _i123++ ) {
                            drawBuffers[ _i123 ] = 36064 + _i123;
                        }
                        drawBuffers.length = textures.length;
                        needsUpdate = true;
                    }
                } else {
                    if ( drawBuffers[ 0 ] !== 36064 ) {
                        drawBuffers[ 0 ] = 36064;
                        needsUpdate = true;
                    }
                }
            } else {
                if ( drawBuffers[ 0 ] !== 1029 ) {
                    drawBuffers[ 0 ] = 1029;
                    needsUpdate = true;
                }
            }
            if ( needsUpdate ) {
                if ( capabilities.isWebGL2 ) {
                    gl.drawBuffers( drawBuffers );
                } else {
                    extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );
                }
            }
        }

        function useProgram( program ) {
            if ( currentProgram !== program ) {
                gl.useProgram( program );
                currentProgram = program;
                return true;
            }
            return false;
        }
        var equationToGL = ( _equationToGL = {}, _defineProperty( _equationToGL, AddEquation, 32774 ), _defineProperty( _equationToGL, SubtractEquation, 32778 ), _defineProperty( _equationToGL, ReverseSubtractEquation, 32779 ), _equationToGL );
        if ( isWebGL2 ) {
            equationToGL[ MinEquation ] = 32775;
            equationToGL[ MaxEquation ] = 32776;
        } else {
            var extension = extensions.get( 'EXT_blend_minmax' );
            if ( extension !== null ) {
                equationToGL[ MinEquation ] = extension.MIN_EXT;
                equationToGL[ MaxEquation ] = extension.MAX_EXT;
            }
        }
        var factorToGL = ( _factorToGL = {}, _defineProperty( _factorToGL, ZeroFactor, 0 ), _defineProperty( _factorToGL, OneFactor, 1 ), _defineProperty( _factorToGL, SrcColorFactor, 768 ), _defineProperty( _factorToGL, SrcAlphaFactor, 770 ), _defineProperty( _factorToGL, SrcAlphaSaturateFactor, 776 ), _defineProperty( _factorToGL, DstColorFactor, 774 ), _defineProperty( _factorToGL, DstAlphaFactor, 772 ), _defineProperty( _factorToGL, OneMinusSrcColorFactor, 769 ), _defineProperty( _factorToGL, OneMinusSrcAlphaFactor, 771 ), _defineProperty( _factorToGL, OneMinusDstColorFactor, 775 ), _defineProperty( _factorToGL, OneMinusDstAlphaFactor, 773 ), _factorToGL );

        function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
            if ( blending === NoBlending ) {
                if ( currentBlendingEnabled === true ) {
                    disable( 3042 );
                    currentBlendingEnabled = false;
                }
                return;
            }
            if ( currentBlendingEnabled === false ) {
                enable( 3042 );
                currentBlendingEnabled = true;
            }
            if ( blending !== CustomBlending ) {
                if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
                    if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {
                        gl.blendEquation( 32774 );
                        currentBlendEquation = AddEquation;
                        currentBlendEquationAlpha = AddEquation;
                    }
                    if ( premultipliedAlpha ) {
                        switch ( blending ) {
                            case NormalBlending:
                                gl.blendFuncSeparate( 1, 771, 1, 771 );
                                break;
                            case AdditiveBlending:
                                gl.blendFunc( 1, 1 );
                                break;
                            case SubtractiveBlending:
                                gl.blendFuncSeparate( 0, 769, 0, 1 );
                                break;
                            case MultiplyBlending:
                                gl.blendFuncSeparate( 0, 768, 0, 770 );
                                break;
                            default:
                                console.error( 'THREE.WebGLState: Invalid blending: ', blending );
                                break;
                        }
                    } else {
                        switch ( blending ) {
                            case NormalBlending:
                                gl.blendFuncSeparate( 770, 771, 1, 771 );
                                break;
                            case AdditiveBlending:
                                gl.blendFunc( 770, 1 );
                                break;
                            case SubtractiveBlending:
                                gl.blendFuncSeparate( 0, 769, 0, 1 );
                                break;
                            case MultiplyBlending:
                                gl.blendFunc( 0, 768 );
                                break;
                            default:
                                console.error( 'THREE.WebGLState: Invalid blending: ', blending );
                                break;
                        }
                    }
                    currentBlendSrc = null;
                    currentBlendDst = null;
                    currentBlendSrcAlpha = null;
                    currentBlendDstAlpha = null;
                    currentBlending = blending;
                    currentPremultipledAlpha = premultipliedAlpha;
                }
                return;
            } // custom blending
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
                gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
            }
            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
                gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
            }
            currentBlending = blending;
            currentPremultipledAlpha = null;
        }

        function setMaterial( material, frontFaceCW ) {
            material.side === DoubleSide ? disable( 2884 ) : enable( 2884 );
            var flipSided = material.side === BackSide;
            if ( frontFaceCW ) flipSided = !flipSided;
            setFlipSided( flipSided );
            material.blending === NormalBlending && material.transparent === false ? setBlending( NoBlending ) : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
            depthBuffer.setFunc( material.depthFunc );
            depthBuffer.setTest( material.depthTest );
            depthBuffer.setMask( material.depthWrite );
            colorBuffer.setMask( material.colorWrite );
            var stencilWrite = material.stencilWrite;
            stencilBuffer.setTest( stencilWrite );
            if ( stencilWrite ) {
                stencilBuffer.setMask( material.stencilWriteMask );
                stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
                stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );
            }
            setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
            material.alphaToCoverage === true ? enable( 32926 ) : disable( 32926 );
        } //
        function setFlipSided( flipSided ) {
            if ( currentFlipSided !== flipSided ) {
                if ( flipSided ) {
                    gl.frontFace( 2304 );
                } else {
                    gl.frontFace( 2305 );
                }
                currentFlipSided = flipSided;
            }
        }

        function setCullFace( cullFace ) {
            if ( cullFace !== CullFaceNone ) {
                enable( 2884 );
                if ( cullFace !== currentCullFace ) {
                    if ( cullFace === CullFaceBack ) {
                        gl.cullFace( 1029 );
                    } else if ( cullFace === CullFaceFront ) {
                        gl.cullFace( 1028 );
                    } else {
                        gl.cullFace( 1032 );
                    }
                }
            } else {
                disable( 2884 );
            }
            currentCullFace = cullFace;
        }

        function setLineWidth( width ) {
            if ( width !== currentLineWidth ) {
                if ( lineWidthAvailable ) gl.lineWidth( width );
                currentLineWidth = width;
            }
        }

        function setPolygonOffset( polygonOffset, factor, units ) {
            if ( polygonOffset ) {
                enable( 32823 );
                if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
                    gl.polygonOffset( factor, units );
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else {
                disable( 32823 );
            }
        }

        function setScissorTest( scissorTest ) {
            if ( scissorTest ) {
                enable( 3089 );
            } else {
                disable( 3089 );
            }
        } // texture
        function activeTexture( webglSlot ) {
            if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;
            if ( currentTextureSlot !== webglSlot ) {
                gl.activeTexture( webglSlot );
                currentTextureSlot = webglSlot;
            }
        }

        function bindTexture( webglType, webglTexture ) {
            if ( currentTextureSlot === null ) {
                activeTexture( );
            }
            var boundTexture = currentBoundTextures[ currentTextureSlot ];
            if ( boundTexture === undefined ) {
                boundTexture = {
                    type: undefined,
                    texture: undefined
                };
                currentBoundTextures[ currentTextureSlot ] = boundTexture;
            }
            if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
                gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }

        function unbindTexture( ) {
            var boundTexture = currentBoundTextures[ currentTextureSlot ];
            if ( boundTexture !== undefined && boundTexture.type !== undefined ) {
                gl.bindTexture( boundTexture.type, null );
                boundTexture.type = undefined;
                boundTexture.texture = undefined;
            }
        }

        function compressedTexImage2D( ) {
            try {
                gl.compressedTexImage2D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texSubImage2D( ) {
            try {
                gl.texSubImage2D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texSubImage3D( ) {
            try {
                gl.texSubImage3D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function compressedTexSubImage2D( ) {
            try {
                gl.compressedTexSubImage2D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texStorage2D( ) {
            try {
                gl.texStorage2D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texStorage3D( ) {
            try {
                gl.texStorage3D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texImage2D( ) {
            try {
                gl.texImage2D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        }

        function texImage3D( ) {
            try {
                gl.texImage3D.apply( gl, arguments );
            } catch ( error ) {
                console.error( 'THREE.WebGLState:', error );
            }
        } //
        function scissor( scissor ) {
            if ( currentScissor.equals( scissor ) === false ) {
                gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
                currentScissor.copy( scissor );
            }
        }

        function viewport( viewport ) {
            if ( currentViewport.equals( viewport ) === false ) {
                gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
                currentViewport.copy( viewport );
            }
        } //
        function reset( ) { // reset state
            gl.disable( 3042 );
            gl.disable( 2884 );
            gl.disable( 2929 );
            gl.disable( 32823 );
            gl.disable( 3089 );
            gl.disable( 2960 );
            gl.disable( 32926 );
            gl.blendEquation( 32774 );
            gl.blendFunc( 1, 0 );
            gl.blendFuncSeparate( 1, 0, 1, 0 );
            gl.colorMask( true, true, true, true );
            gl.clearColor( 0, 0, 0, 0 );
            gl.depthMask( true );
            gl.depthFunc( 513 );
            gl.clearDepth( 1 );
            gl.stencilMask( 0xffffffff );
            gl.stencilFunc( 519, 0, 0xffffffff );
            gl.stencilOp( 7680, 7680, 7680 );
            gl.clearStencil( 0 );
            gl.cullFace( 1029 );
            gl.frontFace( 2305 );
            gl.polygonOffset( 0, 0 );
            gl.activeTexture( 33984 );
            gl.bindFramebuffer( 36160, null );
            if ( isWebGL2 === true ) {
                gl.bindFramebuffer( 36009, null );
                gl.bindFramebuffer( 36008, null );
            }
            gl.useProgram( null );
            gl.lineWidth( 1 );
            gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height ); // reset internals
            enabledCapabilities = {};
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentBoundFramebuffers = {};
            currentDrawbuffers = new WeakMap( );
            defaultDrawbuffers = [ ];
            currentProgram = null;
            currentBlendingEnabled = false;
            currentBlending = null;
            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentPremultipledAlpha = false;
            currentFlipSided = null;
            currentCullFace = null;
            currentLineWidth = null;
            currentPolygonOffsetFactor = null;
            currentPolygonOffsetUnits = null;
            currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
            currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );
            colorBuffer.reset( );
            depthBuffer.reset( );
            stencilBuffer.reset( );
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            enable: enable,
            disable: disable,
            bindFramebuffer: bindFramebuffer,
            drawBuffers: drawBuffers,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            unbindTexture: unbindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            texImage3D: texImage3D,
            texStorage2D: texStorage2D,
            texStorage3D: texStorage3D,
            texSubImage2D: texSubImage2D,
            texSubImage3D: texSubImage3D,
            compressedTexSubImage2D: compressedTexSubImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {
        var _wrappingToGL, _filterToGL;
        var isWebGL2 = capabilities.isWebGL2;
        var maxTextures = capabilities.maxTextures;
        var maxCubemapSize = capabilities.maxCubemapSize;
        var maxTextureSize = capabilities.maxTextureSize;
        var maxSamples = capabilities.maxSamples;
        var multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
        var supportsInvalidateFramebuffer = /OculusBrowser/g.test( navigator.userAgent );
        var _videoTextures = new WeakMap( );
        var _canvas;
        var _sources = new WeakMap( ); // maps WebglTexture objects to instances of Source
        // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
        // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
        // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
        var useOffscreenCanvas = false;
        try {
            useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' // eslint-disable-next-line compat/compat
                &&
                new OffscreenCanvas( 1, 1 ).getContext( '2d' ) !== null;
        } catch ( err ) { // Ignore any errors
        }

        function createCanvas( width, height ) { // Use OffscreenCanvas when available. Specially needed in web workers
            return useOffscreenCanvas ? // eslint-disable-next-line compat/compat
                new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );
        }

        function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {
            var scale = 1; // handle case if texture exceeds max size
            if ( image.width > maxSize || image.height > maxSize ) {
                scale = maxSize / Math.max( image.width, image.height );
            } // only perform resize if necessary
            if ( scale < 1 || needsPowerOfTwo === true ) { // only perform resize for certain image types
                if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) {
                    var floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
                    var _width3 = floor( scale * image.width );
                    var _height3 = floor( scale * image.height );
                    if ( _canvas === undefined ) _canvas = createCanvas( _width3, _height3 ); // cube textures can't reuse the same canvas
                    var canvas = needsNewCanvas ? createCanvas( _width3, _height3 ) : _canvas;
                    canvas.width = _width3;
                    canvas.height = _height3;
                    var context = canvas.getContext( '2d' );
                    context.drawImage( image, 0, 0, _width3, _height3 );
                    console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + _width3 + 'x' + _height3 + ').' );
                    return canvas;
                } else {
                    if ( 'data' in image ) {
                        console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
                    }
                    return image;
                }
            }
            return image;
        }

        function isPowerOfTwo$1( image ) {
            return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );
        }

        function textureNeedsPowerOfTwo( texture ) {
            if ( isWebGL2 ) return false;
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }

        function textureNeedsGenerateMipmaps( texture, supportsMips ) {
            return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }

        function generateMipmap( target ) {
            _gl.generateMipmap( target );
        }

        function getInternalFormat( internalFormatName, glFormat, glType, encoding ) {
            var isVideoTexture = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : false;
            if ( isWebGL2 === false ) return glFormat;
            if ( internalFormatName !== null ) {
                if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];
                console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );
            }
            var internalFormat = glFormat;
            if ( glFormat === 6403 ) {
                if ( glType === 5126 ) internalFormat = 33326;
                if ( glType === 5131 ) internalFormat = 33325;
                if ( glType === 5121 ) internalFormat = 33321;
            }
            if ( glFormat === 33319 ) {
                if ( glType === 5126 ) internalFormat = 33328;
                if ( glType === 5131 ) internalFormat = 33327;
                if ( glType === 5121 ) internalFormat = 33323;
            }
            if ( glFormat === 6408 ) {
                if ( glType === 5126 ) internalFormat = 34836;
                if ( glType === 5131 ) internalFormat = 34842;
                if ( glType === 5121 ) internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
                if ( glType === 32819 ) internalFormat = 32854;
                if ( glType === 32820 ) internalFormat = 32855;
            }
            if ( internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836 ) {
                extensions.get( 'EXT_color_buffer_float' );
            }
            return internalFormat;
        }

        function getMipLevels( texture, image, supportsMips ) {
            if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
                return Math.log2( Math.max( image.width, image.height ) ) + 1;
            } else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) { // user-defined mipmaps
                return texture.mipmaps.length;
            } else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {
                return image.mipmaps.length;
            } else { // texture without mipmaps (only base level)
                return 1;
            }
        } // Fallback filters for non-power-of-2 textures
        function filterFallback( f ) {
            if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {
                return 9728;
            }
            return 9729;
        } //
        function onTextureDispose( event ) {
            var texture = event.target;
            texture.removeEventListener( 'dispose', onTextureDispose );
            deallocateTexture( texture );
            if ( texture.isVideoTexture ) {
                _videoTextures[ "delete" ]( texture );
            }
        }

        function onRenderTargetDispose( event ) {
            var renderTarget = event.target;
            renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
            deallocateRenderTarget( renderTarget );
        } //
        function deallocateTexture( texture ) {
            var textureProperties = properties.get( texture );
            if ( textureProperties.__webglInit === undefined ) return; // check if it's necessary to remove the WebGLTexture object
            var source = texture.source;
            var webglTextures = _sources.get( source );
            if ( webglTextures ) {
                var webglTexture = webglTextures[ textureProperties.__cacheKey ];
                webglTexture.usedTimes--; // the WebGLTexture object is not used anymore, remove it
                if ( webglTexture.usedTimes === 0 ) {
                    deleteTexture( texture );
                } // remove the weak map entry if no WebGLTexture uses the source anymore
                if ( Object.keys( webglTextures ).length === 0 ) {
                    _sources[ "delete" ]( source );
                }
            }
            properties.remove( texture );
        }

        function deleteTexture( texture ) {
            var textureProperties = properties.get( texture );
            _gl.deleteTexture( textureProperties.__webglTexture );
            var source = texture.source;
            var webglTextures = _sources.get( source );
            delete webglTextures[ textureProperties.__cacheKey ];
            info.memory.textures--;
        }

        function deallocateRenderTarget( renderTarget ) {
            var texture = renderTarget.texture;
            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( texture );
            if ( textureProperties.__webglTexture !== undefined ) {
                _gl.deleteTexture( textureProperties.__webglTexture );
                info.memory.textures--;
            }
            if ( renderTarget.depthTexture ) {
                renderTarget.depthTexture.dispose( );
            }
            if ( renderTarget.isWebGLCubeRenderTarget ) {
                for ( var _i124 = 0; _i124 < 6; _i124++ ) {
                    _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ _i124 ] );
                    if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ _i124 ] );
                }
            } else {
                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
                if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
                if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
                if ( renderTargetProperties.__webglColorRenderbuffer ) {
                    for ( var _i125 = 0; _i125 < renderTargetProperties.__webglColorRenderbuffer.length; _i125++ ) {
                        if ( renderTargetProperties.__webglColorRenderbuffer[ _i125 ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ _i125 ] );
                    }
                }
                if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );
            }
            if ( renderTarget.isWebGLMultipleRenderTargets ) {
                for ( var _i126 = 0, il = texture.length; _i126 < il; _i126++ ) {
                    var attachmentProperties = properties.get( texture[ _i126 ] );
                    if ( attachmentProperties.__webglTexture ) {
                        _gl.deleteTexture( attachmentProperties.__webglTexture );
                        info.memory.textures--;
                    }
                    properties.remove( texture[ _i126 ] );
                }
            }
            properties.remove( texture );
            properties.remove( renderTarget );
        } //
        var textureUnits = 0;

        function resetTextureUnits( ) {
            textureUnits = 0;
        }

        function allocateTextureUnit( ) {
            var textureUnit = textureUnits;
            if ( textureUnit >= maxTextures ) {
                console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );
            }
            textureUnits += 1;
            return textureUnit;
        }

        function getTextureCacheKey( texture ) {
            var array = [ ];
            array.push( texture.wrapS );
            array.push( texture.wrapT );
            array.push( texture.magFilter );
            array.push( texture.minFilter );
            array.push( texture.anisotropy );
            array.push( texture.internalFormat );
            array.push( texture.format );
            array.push( texture.type );
            array.push( texture.generateMipmaps );
            array.push( texture.premultiplyAlpha );
            array.push( texture.flipY );
            array.push( texture.unpackAlignment );
            array.push( texture.encoding );
            return array.join( );
        } //
        function setTexture2D( texture, slot ) {
            var textureProperties = properties.get( texture );
            if ( texture.isVideoTexture ) updateVideoTexture( texture );
            if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {
                var image = texture.image;
                if ( image === null ) {
                    console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );
                } else if ( image.complete === false ) {
                    console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );
                } else {
                    uploadTexture( textureProperties, texture, slot );
                    return;
                }
            }
            state.activeTexture( 33984 + slot );
            state.bindTexture( 3553, textureProperties.__webglTexture );
        }

        function setTexture2DArray( texture, slot ) {
            var textureProperties = properties.get( texture );
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
                uploadTexture( textureProperties, texture, slot );
                return;
            }
            state.activeTexture( 33984 + slot );
            state.bindTexture( 35866, textureProperties.__webglTexture );
        }

        function setTexture3D( texture, slot ) {
            var textureProperties = properties.get( texture );
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
                uploadTexture( textureProperties, texture, slot );
                return;
            }
            state.activeTexture( 33984 + slot );
            state.bindTexture( 32879, textureProperties.__webglTexture );
        }

        function setTextureCube( texture, slot ) {
            var textureProperties = properties.get( texture );
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
                uploadCubeTexture( textureProperties, texture, slot );
                return;
            }
            state.activeTexture( 33984 + slot );
            state.bindTexture( 34067, textureProperties.__webglTexture );
        }
        var wrappingToGL = ( _wrappingToGL = {}, _defineProperty( _wrappingToGL, RepeatWrapping, 10497 ), _defineProperty( _wrappingToGL, ClampToEdgeWrapping, 33071 ), _defineProperty( _wrappingToGL, MirroredRepeatWrapping, 33648 ), _wrappingToGL );
        var filterToGL = ( _filterToGL = {}, _defineProperty( _filterToGL, NearestFilter, 9728 ), _defineProperty( _filterToGL, NearestMipmapNearestFilter, 9984 ), _defineProperty( _filterToGL, NearestMipmapLinearFilter, 9986 ), _defineProperty( _filterToGL, LinearFilter, 9729 ), _defineProperty( _filterToGL, LinearMipmapNearestFilter, 9985 ), _defineProperty( _filterToGL, LinearMipmapLinearFilter, 9987 ), _filterToGL );

        function setTextureParameters( textureType, texture, supportsMips ) {
            if ( supportsMips ) {
                _gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
                _gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );
                if ( textureType === 32879 || textureType === 35866 ) {
                    _gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );
                }
                _gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
                _gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );
            } else {
                _gl.texParameteri( textureType, 10242, 33071 );
                _gl.texParameteri( textureType, 10243, 33071 );
                if ( textureType === 32879 || textureType === 35866 ) {
                    _gl.texParameteri( textureType, 32882, 33071 );
                }
                if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
                    console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );
                }
                _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
                _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );
                if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
                    console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );
                }
            }
            if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {
                var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
                if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
                if ( isWebGL2 === false && texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) return; // verify extension for WebGL 1 only
                if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
                    _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy( ) ) );
                    properties.get( texture ).__currentAnisotropy = texture.anisotropy;
                }
            }
        }

        function initTexture( textureProperties, texture ) {
            var forceUpload = false;
            if ( textureProperties.__webglInit === undefined ) {
                textureProperties.__webglInit = true;
                texture.addEventListener( 'dispose', onTextureDispose );
            } // create Source <-> WebGLTextures mapping if necessary
            var source = texture.source;
            var webglTextures = _sources.get( source );
            if ( webglTextures === undefined ) {
                webglTextures = {};
                _sources.set( source, webglTextures );
            } // check if there is already a WebGLTexture object for the given texture parameters
            var textureCacheKey = getTextureCacheKey( texture );
            if ( textureCacheKey !== textureProperties.__cacheKey ) { // if not, create a new instance of WebGLTexture
                if ( webglTextures[ textureCacheKey ] === undefined ) { // create new entry
                    webglTextures[ textureCacheKey ] = {
                        texture: _gl.createTexture( ),
                        usedTimes: 0
                    };
                    info.memory.textures++; // when a new instance of WebGLTexture was created, a texture upload is required
                    // even if the image contents are identical
                    forceUpload = true;
                }
                webglTextures[ textureCacheKey ].usedTimes++; // every time the texture cache key changes, it's necessary to check if an instance of
                // WebGLTexture can be deleted in order to avoid a memory leak.
                var webglTexture = webglTextures[ textureProperties.__cacheKey ];
                if ( webglTexture !== undefined ) {
                    webglTextures[ textureProperties.__cacheKey ].usedTimes--;
                    if ( webglTexture.usedTimes === 0 ) {
                        deleteTexture( texture );
                    }
                } // store references to cache key and WebGLTexture object
                textureProperties.__cacheKey = textureCacheKey;
                textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;
            }
            return forceUpload;
        }

        function uploadTexture( textureProperties, texture, slot ) {
            var textureType = 3553;
            if ( texture.isDataArrayTexture ) textureType = 35866;
            if ( texture.isData3DTexture ) textureType = 32879;
            var forceUpload = initTexture( textureProperties, texture );
            var source = texture.source;
            state.activeTexture( 33984 + slot );
            state.bindTexture( textureType, textureProperties.__webglTexture );
            if ( source.version !== source.__currentVersion || forceUpload === true ) {
                _gl.pixelStorei( 37440, texture.flipY );
                _gl.pixelStorei( 37441, texture.premultiplyAlpha );
                _gl.pixelStorei( 3317, texture.unpackAlignment );
                _gl.pixelStorei( 37443, 0 );
                var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
                var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
                image = verifyColorSpace( texture, image );
                var supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
                    glFormat = utils.convert( texture.format, texture.encoding );
                var glType = utils.convert( texture.type ),
                    glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );
                setTextureParameters( textureType, texture, supportsMips );
                var mipmap;
                var mipmaps = texture.mipmaps;
                var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
                var allocateMemory = source.__currentVersion === undefined || forceUpload === true;
                var levels = getMipLevels( texture, image, supportsMips );
                if ( texture.isDepthTexture ) { // populate depth texture with dummy data
                    glInternalFormat = 6402;
                    if ( isWebGL2 ) {
                        if ( texture.type === FloatType ) {
                            glInternalFormat = 36012;
                        } else if ( texture.type === UnsignedIntType ) {
                            glInternalFormat = 33190;
                        } else if ( texture.type === UnsignedInt248Type ) {
                            glInternalFormat = 35056;
                        } else {
                            glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
                        }
                    } else {
                        if ( texture.type === FloatType ) {
                            console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );
                        }
                    } // validation checks for WebGL 1
                    if ( texture.format === DepthFormat && glInternalFormat === 6402 ) { // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
                            console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
                            texture.type = UnsignedIntType;
                            glType = utils.convert( texture.type );
                        }
                    }
                    if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) { // Depth stencil textures need the DEPTH_STENCIL internal format
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        if ( texture.type !== UnsignedInt248Type ) {
                            console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
                            texture.type = UnsignedInt248Type;
                            glType = utils.convert( texture.type );
                        }
                    } //
                    if ( allocateMemory ) {
                        if ( useTexStorage ) {
                            state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );
                        } else {
                            state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );
                        }
                    }
                } else if ( texture.isDataTexture ) { // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels
                    if ( mipmaps.length > 0 && supportsMips ) {
                        if ( useTexStorage && allocateMemory ) {
                            state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );
                        }
                        for ( var _i127 = 0, il = mipmaps.length; _i127 < il; _i127++ ) {
                            mipmap = mipmaps[ _i127 ];
                            if ( useTexStorage ) {
                                state.texSubImage2D( 3553, _i127, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );
                            } else {
                                state.texImage2D( 3553, _i127, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
                            }
                        }
                        texture.generateMipmaps = false;
                    } else {
                        if ( useTexStorage ) {
                            if ( allocateMemory ) {
                                state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );
                            }
                            state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );
                        } else {
                            state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
                        }
                    }
                } else if ( texture.isCompressedTexture ) {
                    if ( useTexStorage && allocateMemory ) {
                        state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );
                    }
                    for ( var _i128 = 0, _il9 = mipmaps.length; _i128 < _il9; _i128++ ) {
                        mipmap = mipmaps[ _i128 ];
                        if ( texture.format !== RGBAFormat ) {
                            if ( glFormat !== null ) {
                                if ( useTexStorage ) {
                                    state.compressedTexSubImage2D( 3553, _i128, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );
                                } else {
                                    state.compressedTexImage2D( 3553, _i128, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
                                }
                            } else {
                                console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
                            }
                        } else {
                            if ( useTexStorage ) {
                                state.texSubImage2D( 3553, _i128, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );
                            } else {
                                state.texImage2D( 3553, _i128, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
                            }
                        }
                    }
                } else if ( texture.isDataArrayTexture ) {
                    if ( useTexStorage ) {
                        if ( allocateMemory ) {
                            state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );
                        }
                        state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );
                    } else {
                        state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
                    }
                } else if ( texture.isData3DTexture ) {
                    if ( useTexStorage ) {
                        if ( allocateMemory ) {
                            state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );
                        }
                        state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );
                    } else {
                        state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
                    }
                } else if ( texture.isFramebufferTexture ) {
                    if ( allocateMemory ) {
                        if ( useTexStorage ) {
                            state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );
                        } else {
                            var _width4 = image.width,
                                _height4 = image.height;
                            for ( var _i129 = 0; _i129 < levels; _i129++ ) {
                                state.texImage2D( 3553, _i129, glInternalFormat, _width4, _height4, 0, glFormat, glType, null );
                                _width4 >>= 1;
                                _height4 >>= 1;
                            }
                        }
                    }
                } else { // regular Texture (image, video, canvas)
                    // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels
                    if ( mipmaps.length > 0 && supportsMips ) {
                        if ( useTexStorage && allocateMemory ) {
                            state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );
                        }
                        for ( var _i130 = 0, _il10 = mipmaps.length; _i130 < _il10; _i130++ ) {
                            mipmap = mipmaps[ _i130 ];
                            if ( useTexStorage ) {
                                state.texSubImage2D( 3553, _i130, 0, 0, glFormat, glType, mipmap );
                            } else {
                                state.texImage2D( 3553, _i130, glInternalFormat, glFormat, glType, mipmap );
                            }
                        }
                        texture.generateMipmaps = false;
                    } else {
                        if ( useTexStorage ) {
                            if ( allocateMemory ) {
                                state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );
                            }
                            state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );
                        } else {
                            state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
                        }
                    }
                }
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
                    generateMipmap( textureType );
                }
                source.__currentVersion = source.version;
                if ( texture.onUpdate ) texture.onUpdate( texture );
            }
            textureProperties.__version = texture.version;
        }

        function uploadCubeTexture( textureProperties, texture, slot ) {
            if ( texture.image.length !== 6 ) return;
            var forceUpload = initTexture( textureProperties, texture );
            var source = texture.source;
            state.activeTexture( 33984 + slot );
            state.bindTexture( 34067, textureProperties.__webglTexture );
            if ( source.version !== source.__currentVersion || forceUpload === true ) {
                _gl.pixelStorei( 37440, texture.flipY );
                _gl.pixelStorei( 37441, texture.premultiplyAlpha );
                _gl.pixelStorei( 3317, texture.unpackAlignment );
                _gl.pixelStorei( 37443, 0 );
                var isCompressed = texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture;
                var isDataTexture = texture.image[ 0 ] && texture.image[ 0 ].isDataTexture;
                var cubeImage = [ ];
                for ( var _i131 = 0; _i131 < 6; _i131++ ) {
                    if ( !isCompressed && !isDataTexture ) {
                        cubeImage[ _i131 ] = resizeImage( texture.image[ _i131 ], false, true, maxCubemapSize );
                    } else {
                        cubeImage[ _i131 ] = isDataTexture ? texture.image[ _i131 ].image : texture.image[ _i131 ];
                    }
                    cubeImage[ _i131 ] = verifyColorSpace( texture, cubeImage[ _i131 ] );
                }
                var image = cubeImage[ 0 ],
                    supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
                    glFormat = utils.convert( texture.format, texture.encoding ),
                    glType = utils.convert( texture.type ),
                    glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
                var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
                var allocateMemory = source.__currentVersion === undefined || forceUpload === true;
                var levels = getMipLevels( texture, image, supportsMips );
                setTextureParameters( 34067, texture, supportsMips );
                var mipmaps;
                if ( isCompressed ) {
                    if ( useTexStorage && allocateMemory ) {
                        state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );
                    }
                    for ( var _i132 = 0; _i132 < 6; _i132++ ) {
                        mipmaps = cubeImage[ _i132 ].mipmaps;
                        for ( var j = 0; j < mipmaps.length; j++ ) {
                            var mipmap = mipmaps[ j ];
                            if ( texture.format !== RGBAFormat ) {
                                if ( glFormat !== null ) {
                                    if ( useTexStorage ) {
                                        state.compressedTexSubImage2D( 34069 + _i132, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );
                                    } else {
                                        state.compressedTexImage2D( 34069 + _i132, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
                                    }
                                } else {
                                    console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
                                }
                            } else {
                                if ( useTexStorage ) {
                                    state.texSubImage2D( 34069 + _i132, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );
                                } else {
                                    state.texImage2D( 34069 + _i132, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
                                }
                            }
                        }
                    }
                } else {
                    mipmaps = texture.mipmaps;
                    if ( useTexStorage && allocateMemory ) { // TODO: Uniformly handle mipmap definitions
                        // Normal textures and compressed cube textures define base level + mips with their mipmap array
                        // Uncompressed cube textures use their mipmap array only for mips (no base level)
                        if ( mipmaps.length > 0 ) levels++;
                        state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );
                    }
                    for ( var _i133 = 0; _i133 < 6; _i133++ ) {
                        if ( isDataTexture ) {
                            if ( useTexStorage ) {
                                state.texSubImage2D( 34069 + _i133, 0, 0, 0, cubeImage[ _i133 ].width, cubeImage[ _i133 ].height, glFormat, glType, cubeImage[ _i133 ].data );
                            } else {
                                state.texImage2D( 34069 + _i133, 0, glInternalFormat, cubeImage[ _i133 ].width, cubeImage[ _i133 ].height, 0, glFormat, glType, cubeImage[ _i133 ].data );
                            }
                            for ( var _j3 = 0; _j3 < mipmaps.length; _j3++ ) {
                                var _mipmap = mipmaps[ _j3 ];
                                var mipmapImage = _mipmap.image[ _i133 ].image;
                                if ( useTexStorage ) {
                                    state.texSubImage2D( 34069 + _i133, _j3 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );
                                } else {
                                    state.texImage2D( 34069 + _i133, _j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );
                                }
                            }
                        } else {
                            if ( useTexStorage ) {
                                state.texSubImage2D( 34069 + _i133, 0, 0, 0, glFormat, glType, cubeImage[ _i133 ] );
                            } else {
                                state.texImage2D( 34069 + _i133, 0, glInternalFormat, glFormat, glType, cubeImage[ _i133 ] );
                            }
                            for ( var _j4 = 0; _j4 < mipmaps.length; _j4++ ) {
                                var _mipmap2 = mipmaps[ _j4 ];
                                if ( useTexStorage ) {
                                    state.texSubImage2D( 34069 + _i133, _j4 + 1, 0, 0, glFormat, glType, _mipmap2.image[ _i133 ] );
                                } else {
                                    state.texImage2D( 34069 + _i133, _j4 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[ _i133 ] );
                                }
                            }
                        }
                    }
                }
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { // We assume images for cube map have the same size.
                    generateMipmap( 34067 );
                }
                source.__currentVersion = source.version;
                if ( texture.onUpdate ) texture.onUpdate( texture );
            }
            textureProperties.__version = texture.version;
        } // Render targets
        // Setup storage for target texture and bind it to correct framebuffer
        function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {
            var glFormat = utils.convert( texture.format, texture.encoding );
            var glType = utils.convert( texture.type );
            var glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
            var renderTargetProperties = properties.get( renderTarget );
            if ( !renderTargetProperties.__hasExternalTextures ) {
                if ( textureTarget === 32879 || textureTarget === 35866 ) {
                    state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );
                } else {
                    state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
                }
            }
            state.bindFramebuffer( 36160, framebuffer );
            if ( useMultisampledRTT( renderTarget ) ) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );
            } else {
                _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
            }
            state.bindFramebuffer( 36160, null );
        } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {
            _gl.bindRenderbuffer( 36161, renderbuffer );
            if ( renderTarget.depthBuffer && !renderTarget.stencilBuffer ) {
                var glInternalFormat = 33189;
                if ( isMultisample || useMultisampledRTT( renderTarget ) ) {
                    var depthTexture = renderTarget.depthTexture;
                    if ( depthTexture && depthTexture.isDepthTexture ) {
                        if ( depthTexture.type === FloatType ) {
                            glInternalFormat = 36012;
                        } else if ( depthTexture.type === UnsignedIntType ) {
                            glInternalFormat = 33190;
                        }
                    }
                    var samples = getRenderTargetSamples( renderTarget );
                    if ( useMultisampledRTT( renderTarget ) ) {
                        multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
                    } else {
                        _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
                    }
                } else {
                    _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );
                }
                _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );
            } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
                var _samples = getRenderTargetSamples( renderTarget );
                if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {
                    _gl.renderbufferStorageMultisample( 36161, _samples, 35056, renderTarget.width, renderTarget.height );
                } else if ( useMultisampledRTT( renderTarget ) ) {
                    multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, _samples, 35056, renderTarget.width, renderTarget.height );
                } else {
                    _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );
                }
                _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );
            } else {
                var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];
                for ( var _i134 = 0; _i134 < textures.length; _i134++ ) {
                    var texture = textures[ _i134 ];
                    var glFormat = utils.convert( texture.format, texture.encoding );
                    var glType = utils.convert( texture.type );
                    var _glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
                    var _samples2 = getRenderTargetSamples( renderTarget );
                    if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {
                        _gl.renderbufferStorageMultisample( 36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height );
                    } else if ( useMultisampledRTT( renderTarget ) ) {
                        multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height );
                    } else {
                        _gl.renderbufferStorage( 36161, _glInternalFormat, renderTarget.width, renderTarget.height );
                    }
                }
            }
            _gl.bindRenderbuffer( 36161, null );
        } // Setup resources for a Depth Texture for a FBO (needs an extension)
        function setupDepthTexture( framebuffer, renderTarget ) {
            var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
            if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );
            state.bindFramebuffer( 36160, framebuffer );
            if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
                throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );
            } // upload an empty depth texture with framebuffer size
            if ( !properties.get( renderTarget.depthTexture ).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height ) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D( renderTarget.depthTexture, 0 );
            var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
            var samples = getRenderTargetSamples( renderTarget );
            if ( renderTarget.depthTexture.format === DepthFormat ) {
                if ( useMultisampledRTT( renderTarget ) ) {
                    multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );
                } else {
                    _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );
                }
            } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
                if ( useMultisampledRTT( renderTarget ) ) {
                    multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );
                } else {
                    _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );
                }
            } else {
                throw new Error( 'Unknown depthTexture format' );
            }
        } // Setup GL resources for a non-texture depth buffer
        function setupDepthRenderbuffer( renderTarget ) {
            var renderTargetProperties = properties.get( renderTarget );
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            if ( renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer ) {
                if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );
                setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
            } else {
                if ( isCube ) {
                    renderTargetProperties.__webglDepthbuffer = [ ];
                    for ( var _i135 = 0; _i135 < 6; _i135++ ) {
                        state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ _i135 ] );
                        renderTargetProperties.__webglDepthbuffer[ _i135 ] = _gl.createRenderbuffer( );
                        setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ _i135 ], renderTarget, false );
                    }
                } else {
                    state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer( );
                    setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );
                }
            }
            state.bindFramebuffer( 36160, null );
        } // rebind framebuffer with external textures
        function rebindTextures( renderTarget, colorTexture, depthTexture ) {
            var renderTargetProperties = properties.get( renderTarget );
            if ( colorTexture !== undefined ) {
                setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );
            }
            if ( depthTexture !== undefined ) {
                setupDepthRenderbuffer( renderTarget );
            }
        } // Set up GL resources for the render target
        function setupRenderTarget( renderTarget ) {
            var texture = renderTarget.texture;
            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( texture );
            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
            if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {
                if ( textureProperties.__webglTexture === undefined ) {
                    textureProperties.__webglTexture = _gl.createTexture( );
                }
                textureProperties.__version = texture.version;
                info.memory.textures++;
            }
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
            var supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2; // Setup framebuffer
            if ( isCube ) {
                renderTargetProperties.__webglFramebuffer = [ ];
                for ( var _i136 = 0; _i136 < 6; _i136++ ) {
                    renderTargetProperties.__webglFramebuffer[ _i136 ] = _gl.createFramebuffer( );
                }
            } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer( );
                if ( isMultipleRenderTargets ) {
                    if ( capabilities.drawBuffers ) {
                        var textures = renderTarget.texture;
                        for ( var _i137 = 0, il = textures.length; _i137 < il; _i137++ ) {
                            var attachmentProperties = properties.get( textures[ _i137 ] );
                            if ( attachmentProperties.__webglTexture === undefined ) {
                                attachmentProperties.__webglTexture = _gl.createTexture( );
                                info.memory.textures++;
                            }
                        }
                    } else {
                        console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );
                    }
                }
                if ( isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT( renderTarget ) === false ) {
                    var _textures = isMultipleRenderTargets ? texture : [ texture ];
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer( );
                    renderTargetProperties.__webglColorRenderbuffer = [ ];
                    state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
                    for ( var _i138 = 0; _i138 < _textures.length; _i138++ ) {
                        var _texture = _textures[ _i138 ];
                        renderTargetProperties.__webglColorRenderbuffer[ _i138 ] = _gl.createRenderbuffer( );
                        _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer[ _i138 ] );
                        var glFormat = utils.convert( _texture.format, _texture.encoding );
                        var glType = utils.convert( _texture.type );
                        var glInternalFormat = getInternalFormat( _texture.internalFormat, glFormat, glType, _texture.encoding );
                        var samples = getRenderTargetSamples( renderTarget );
                        _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
                        _gl.framebufferRenderbuffer( 36160, 36064 + _i138, 36161, renderTargetProperties.__webglColorRenderbuffer[ _i138 ] );
                    }
                    _gl.bindRenderbuffer( 36161, null );
                    if ( renderTarget.depthBuffer ) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer( );
                        setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );
                    }
                    state.bindFramebuffer( 36160, null );
                }
            } // Setup color buffer
            if ( isCube ) {
                state.bindTexture( 34067, textureProperties.__webglTexture );
                setTextureParameters( 34067, texture, supportsMips );
                for ( var _i139 = 0; _i139 < 6; _i139++ ) {
                    setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ _i139 ], renderTarget, texture, 36064, 34069 + _i139 );
                }
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
                    generateMipmap( 34067 );
                }
                state.unbindTexture( );
            } else if ( isMultipleRenderTargets ) {
                var _textures2 = renderTarget.texture;
                for ( var _i140 = 0, _il11 = _textures2.length; _i140 < _il11; _i140++ ) {
                    var attachment = _textures2[ _i140 ];
                    var _attachmentProperties = properties.get( attachment );
                    state.bindTexture( 3553, _attachmentProperties.__webglTexture );
                    setTextureParameters( 3553, attachment, supportsMips );
                    setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + _i140, 3553 );
                    if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {
                        generateMipmap( 3553 );
                    }
                }
                state.unbindTexture( );
            } else {
                var glTextureType = 3553;
                if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {
                    if ( isWebGL2 ) {
                        glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
                    } else {
                        console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );
                    }
                }
                state.bindTexture( glTextureType, textureProperties.__webglTexture );
                setTextureParameters( glTextureType, texture, supportsMips );
                setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
                    generateMipmap( glTextureType );
                }
                state.unbindTexture( );
            } // Setup depth and stencil buffers
            if ( renderTarget.depthBuffer ) {
                setupDepthRenderbuffer( renderTarget );
            }
        }

        function updateRenderTargetMipmap( renderTarget ) {
            var supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;
            var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];
            for ( var _i141 = 0, il = textures.length; _i141 < il; _i141++ ) {
                var texture = textures[ _i141 ];
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
                    var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                    var webglTexture = properties.get( texture ).__webglTexture;
                    state.bindTexture( target, webglTexture );
                    generateMipmap( target );
                    state.unbindTexture( );
                }
            }
        }

        function updateMultisampleRenderTarget( renderTarget ) {
            if ( isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT( renderTarget ) === false ) {
                var textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
                var _width5 = renderTarget.width;
                var _height5 = renderTarget.height;
                var mask = 16384;
                var invalidationArray = [ ];
                var depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
                var renderTargetProperties = properties.get( renderTarget );
                var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true; // If MRT we need to remove FBO attachments
                if ( isMultipleRenderTargets ) {
                    for ( var _i142 = 0; _i142 < textures.length; _i142++ ) {
                        state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
                        _gl.framebufferRenderbuffer( 36160, 36064 + _i142, 36161, null );
                        state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
                        _gl.framebufferTexture2D( 36009, 36064 + _i142, 3553, null, 0 );
                    }
                }
                state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
                state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );
                for ( var _i143 = 0; _i143 < textures.length; _i143++ ) {
                    invalidationArray.push( 36064 + _i143 );
                    if ( renderTarget.depthBuffer ) {
                        invalidationArray.push( depthStyle );
                    }
                    var ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;
                    if ( ignoreDepthValues === false ) {
                        if ( renderTarget.depthBuffer ) mask |= 256;
                        if ( renderTarget.stencilBuffer ) mask |= 1024;
                    }
                    if ( isMultipleRenderTargets ) {
                        _gl.framebufferRenderbuffer( 36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[ _i143 ] );
                    }
                    if ( ignoreDepthValues === true ) {
                        _gl.invalidateFramebuffer( 36008, [ depthStyle ] );
                        _gl.invalidateFramebuffer( 36009, [ depthStyle ] );
                    }
                    if ( isMultipleRenderTargets ) {
                        var webglTexture = properties.get( textures[ _i143 ] ).__webglTexture;
                        _gl.framebufferTexture2D( 36009, 36064, 3553, webglTexture, 0 );
                    }
                    _gl.blitFramebuffer( 0, 0, _width5, _height5, 0, 0, _width5, _height5, mask, 9728 );
                    if ( supportsInvalidateFramebuffer ) {
                        _gl.invalidateFramebuffer( 36008, invalidationArray );
                    }
                }
                state.bindFramebuffer( 36008, null );
                state.bindFramebuffer( 36009, null ); // If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
                if ( isMultipleRenderTargets ) {
                    for ( var _i144 = 0; _i144 < textures.length; _i144++ ) {
                        state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
                        _gl.framebufferRenderbuffer( 36160, 36064 + _i144, 36161, renderTargetProperties.__webglColorRenderbuffer[ _i144 ] );
                        var _webglTexture = properties.get( textures[ _i144 ] ).__webglTexture;
                        state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
                        _gl.framebufferTexture2D( 36009, 36064 + _i144, 3553, _webglTexture, 0 );
                    }
                }
                state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );
            }
        }

        function getRenderTargetSamples( renderTarget ) {
            return Math.min( maxSamples, renderTarget.samples );
        }

        function useMultisampledRTT( renderTarget ) {
            var renderTargetProperties = properties.get( renderTarget );
            return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;
        }

        function updateVideoTexture( texture ) {
            var frame = info.render.frame; // Check the last frame we updated the VideoTexture
            if ( _videoTextures.get( texture ) !== frame ) {
                _videoTextures.set( texture, frame );
                texture.update( );
            }
        }

        function verifyColorSpace( texture, image ) {
            var encoding = texture.encoding;
            var format = texture.format;
            var type = texture.type;
            if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;
            if ( encoding !== LinearEncoding ) { // sRGB
                if ( encoding === sRGBEncoding ) {
                    if ( isWebGL2 === false ) { // in WebGL 1, try to use EXT_sRGB extension and unsized formats
                        if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {
                            texture.format = _SRGBAFormat; // it's not possible to generate mips in WebGL 1 with this extension
                            texture.minFilter = LinearFilter;
                            texture.generateMipmaps = false;
                        } else { // slow fallback (CPU decode)
                            image = ImageUtils.sRGBToLinear( image );
                        }
                    } else { // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
                        if ( format !== RGBAFormat || type !== UnsignedByteType ) {
                            console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );
                        }
                    }
                } else {
                    console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );
                }
            }
            return image;
        } //
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.rebindTextures = rebindTextures;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.setupDepthRenderbuffer = setupDepthRenderbuffer;
        this.setupFrameBufferTexture = setupFrameBufferTexture;
        this.useMultisampledRTT = useMultisampledRTT;
    }

    function WebGLUtils( gl, extensions, capabilities ) {
        var isWebGL2 = capabilities.isWebGL2;

        function convert( p ) {
            var encoding = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : null;
            var extension;
            if ( p === UnsignedByteType ) return 5121;
            if ( p === UnsignedShort4444Type ) return 32819;
            if ( p === UnsignedShort5551Type ) return 32820;
            if ( p === ByteType ) return 5120;
            if ( p === ShortType ) return 5122;
            if ( p === UnsignedShortType ) return 5123;
            if ( p === IntType ) return 5124;
            if ( p === UnsignedIntType ) return 5125;
            if ( p === FloatType ) return 5126;
            if ( p === HalfFloatType ) {
                if ( isWebGL2 ) return 5131;
                extension = extensions.get( 'OES_texture_half_float' );
                if ( extension !== null ) {
                    return extension.HALF_FLOAT_OES;
                } else {
                    return null;
                }
            }
            if ( p === AlphaFormat ) return 6406;
            if ( p === RGBAFormat ) return 6408;
            if ( p === LuminanceFormat ) return 6409;
            if ( p === LuminanceAlphaFormat ) return 6410;
            if ( p === DepthFormat ) return 6402;
            if ( p === DepthStencilFormat ) return 34041;
            if ( p === RedFormat ) return 6403;
            if ( p === RGBFormat ) {
                console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
                return 6408;
            } // WebGL 1 sRGB fallback
            if ( p === _SRGBAFormat ) {
                extension = extensions.get( 'EXT_sRGB' );
                if ( extension !== null ) {
                    return extension.SRGB_ALPHA_EXT;
                } else {
                    return null;
                }
            } // WebGL2 formats.
            if ( p === RedIntegerFormat ) return 36244;
            if ( p === RGFormat ) return 33319;
            if ( p === RGIntegerFormat ) return 33320;
            if ( p === RGBAIntegerFormat ) return 36249; // S3TC
            if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
                if ( encoding === sRGBEncoding ) {
                    extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );
                    if ( extension !== null ) {
                        if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    } else {
                        return null;
                    }
                } else {
                    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
                    if ( extension !== null ) {
                        if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    } else {
                        return null;
                    }
                }
            } // PVRTC
            if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
                extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
                if ( extension !== null ) {
                    if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else {
                    return null;
                }
            } // ETC1
            if ( p === RGB_ETC1_Format ) {
                extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
                if ( extension !== null ) {
                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
                } else {
                    return null;
                }
            } // ETC2
            if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {
                extension = extensions.get( 'WEBGL_compressed_texture_etc' );
                if ( extension !== null ) {
                    if ( p === RGB_ETC2_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                    if ( p === RGBA_ETC2_EAC_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
                } else {
                    return null;
                }
            } // ASTC
            if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {
                extension = extensions.get( 'WEBGL_compressed_texture_astc' );
                if ( extension !== null ) {
                    if ( p === RGBA_ASTC_4x4_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if ( p === RGBA_ASTC_5x4_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if ( p === RGBA_ASTC_5x5_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if ( p === RGBA_ASTC_6x5_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if ( p === RGBA_ASTC_6x6_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if ( p === RGBA_ASTC_8x5_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if ( p === RGBA_ASTC_8x6_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if ( p === RGBA_ASTC_8x8_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if ( p === RGBA_ASTC_10x5_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if ( p === RGBA_ASTC_10x6_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if ( p === RGBA_ASTC_10x8_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if ( p === RGBA_ASTC_10x10_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if ( p === RGBA_ASTC_12x10_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if ( p === RGBA_ASTC_12x12_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
                } else {
                    return null;
                }
            } // BPTC
            if ( p === RGBA_BPTC_Format ) {
                extension = extensions.get( 'EXT_texture_compression_bptc' );
                if ( extension !== null ) {
                    if ( p === RGBA_BPTC_Format ) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                } else {
                    return null;
                }
            } //
            if ( p === UnsignedInt248Type ) {
                if ( isWebGL2 ) return 34042;
                extension = extensions.get( 'WEBGL_depth_texture' );
                if ( extension !== null ) {
                    return extension.UNSIGNED_INT_24_8_WEBGL;
                } else {
                    return null;
                }
            } // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
            return gl[ p ] !== undefined ? gl[ p ] : null;
        }
        return {
            convert: convert
        };
    }
    var ArrayCamera = /*#__PURE__*/ function( _PerspectiveCamera ) {
        _inherits( ArrayCamera, _PerspectiveCamera );
        var _super24 = _createSuper( ArrayCamera );

        function ArrayCamera( ) {
            var _this22;
            var array = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
            _classCallCheck( this, ArrayCamera );
            _this22 = _super24.call( this );
            _this22.isArrayCamera = true;
            _this22.cameras = array;
            return _this22;
        }
        return _createClass( ArrayCamera );
    }( PerspectiveCamera );
    var Group$1 = /*#__PURE__*/ function( _Object3D4 ) {
        _inherits( Group$1, _Object3D4 );
        var _super25 = _createSuper( Group$1 );

        function Group$1( ) {
            var _this23;
            _classCallCheck( this, Group$1 );
            _this23 = _super25.call( this );
            _this23.isGroup = true;
            _this23.type = 'Group';
            return _this23;
        }
        return _createClass( Group$1 );
    }( Object3D );
    var _moveEvent = {
        type: 'move'
    };
    var WebXRController = /*#__PURE__*/ function( ) {
        function WebXRController( ) {
            _classCallCheck( this, WebXRController );
            this._targetRay = null;
            this._grip = null;
            this._hand = null;
        }
        _createClass( WebXRController, [ {
            key: "getHandSpace",
            value: function getHandSpace( ) {
                if ( this._hand === null ) {
                    this._hand = new Group$1( );
                    this._hand.matrixAutoUpdate = false;
                    this._hand.visible = false;
                    this._hand.joints = {};
                    this._hand.inputState = {
                        pinching: false
                    };
                }
                return this._hand;
            }
        }, {
            key: "getTargetRaySpace",
            value: function getTargetRaySpace( ) {
                if ( this._targetRay === null ) {
                    this._targetRay = new Group$1( );
                    this._targetRay.matrixAutoUpdate = false;
                    this._targetRay.visible = false;
                    this._targetRay.hasLinearVelocity = false;
                    this._targetRay.linearVelocity = new Vector3( );
                    this._targetRay.hasAngularVelocity = false;
                    this._targetRay.angularVelocity = new Vector3( );
                }
                return this._targetRay;
            }
        }, {
            key: "getGripSpace",
            value: function getGripSpace( ) {
                if ( this._grip === null ) {
                    this._grip = new Group$1( );
                    this._grip.matrixAutoUpdate = false;
                    this._grip.visible = false;
                    this._grip.hasLinearVelocity = false;
                    this._grip.linearVelocity = new Vector3( );
                    this._grip.hasAngularVelocity = false;
                    this._grip.angularVelocity = new Vector3( );
                }
                return this._grip;
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent( event ) {
                if ( this._targetRay !== null ) {
                    this._targetRay.dispatchEvent( event );
                }
                if ( this._grip !== null ) {
                    this._grip.dispatchEvent( event );
                }
                if ( this._hand !== null ) {
                    this._hand.dispatchEvent( event );
                }
                return this;
            }
        }, {
            key: "disconnect",
            value: function disconnect( inputSource ) {
                this.dispatchEvent( {
                    type: 'disconnected',
                    data: inputSource
                } );
                if ( this._targetRay !== null ) {
                    this._targetRay.visible = false;
                }
                if ( this._grip !== null ) {
                    this._grip.visible = false;
                }
                if ( this._hand !== null ) {
                    this._hand.visible = false;
                }
                return this;
            }
        }, {
            key: "update",
            value: function update( inputSource, frame, referenceSpace ) {
                var inputPose = null;
                var gripPose = null;
                var handPose = null;
                var targetRay = this._targetRay;
                var grip = this._grip;
                var hand = this._hand;
                if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {
                    if ( hand && inputSource.hand ) {
                        handPose = true;
                        var _iterator2 = _createForOfIteratorHelper( inputSource.hand.values( ) ),
                            _step2;
                        try {
                            for ( _iterator2.s( ); !( _step2 = _iterator2.n( ) ).done; ) {
                                var inputjoint = _step2.value; // Update the joints groups with the XRJoint poses
                                var jointPose = frame.getJointPose( inputjoint, referenceSpace );
                                if ( hand.joints[ inputjoint.jointName ] === undefined ) { // The transform of this joint will be updated with the joint pose on each frame
                                    var _joint = new Group$1( );
                                    _joint.matrixAutoUpdate = false;
                                    _joint.visible = false;
                                    hand.joints[ inputjoint.jointName ] = _joint; // ??
                                    hand.add( _joint );
                                }
                                var joint = hand.joints[ inputjoint.jointName ];
                                if ( jointPose !== null ) {
                                    joint.matrix.fromArray( jointPose.transform.matrix );
                                    joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
                                    joint.jointRadius = jointPose.radius;
                                }
                                joint.visible = jointPose !== null;
                            } // Custom events
                            // Check pinchz
                        } catch ( err ) {
                            _iterator2.e( err );
                        } finally {
                            _iterator2.f( );
                        }
                        var indexTip = hand.joints[ 'index-finger-tip' ];
                        var thumbTip = hand.joints[ 'thumb-tip' ];
                        var distance = indexTip.position.distanceTo( thumbTip.position );
                        var distanceToPinch = 0.02;
                        var threshold = 0.005;
                        if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {
                            hand.inputState.pinching = false;
                            this.dispatchEvent( {
                                type: 'pinchend',
                                handedness: inputSource.handedness,
                                target: this
                            } );
                        } else if ( !hand.inputState.pinching && distance <= distanceToPinch - threshold ) {
                            hand.inputState.pinching = true;
                            this.dispatchEvent( {
                                type: 'pinchstart',
                                handedness: inputSource.handedness,
                                target: this
                            } );
                        }
                    } else {
                        if ( grip !== null && inputSource.gripSpace ) {
                            gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );
                            if ( gripPose !== null ) {
                                grip.matrix.fromArray( gripPose.transform.matrix );
                                grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
                                if ( gripPose.linearVelocity ) {
                                    grip.hasLinearVelocity = true;
                                    grip.linearVelocity.copy( gripPose.linearVelocity );
                                } else {
                                    grip.hasLinearVelocity = false;
                                }
                                if ( gripPose.angularVelocity ) {
                                    grip.hasAngularVelocity = true;
                                    grip.angularVelocity.copy( gripPose.angularVelocity );
                                } else {
                                    grip.hasAngularVelocity = false;
                                }
                            }
                        }
                    }
                    if ( targetRay !== null ) {
                        inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace ); // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
                        if ( inputPose === null && gripPose !== null ) {
                            inputPose = gripPose;
                        }
                        if ( inputPose !== null ) {
                            targetRay.matrix.fromArray( inputPose.transform.matrix );
                            targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
                            if ( inputPose.linearVelocity ) {
                                targetRay.hasLinearVelocity = true;
                                targetRay.linearVelocity.copy( inputPose.linearVelocity );
                            } else {
                                targetRay.hasLinearVelocity = false;
                            }
                            if ( inputPose.angularVelocity ) {
                                targetRay.hasAngularVelocity = true;
                                targetRay.angularVelocity.copy( inputPose.angularVelocity );
                            } else {
                                targetRay.hasAngularVelocity = false;
                            }
                            this.dispatchEvent( _moveEvent );
                        }
                    }
                }
                if ( targetRay !== null ) {
                    targetRay.visible = inputPose !== null;
                }
                if ( grip !== null ) {
                    grip.visible = gripPose !== null;
                }
                if ( hand !== null ) {
                    hand.visible = handPose !== null;
                }
                return this;
            }
        } ] );
        return WebXRController;
    }( );
    var DepthTexture = /*#__PURE__*/ function( _Texture4 ) {
        _inherits( DepthTexture, _Texture4 );
        var _super26 = _createSuper( DepthTexture );

        function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
            var _this24;
            _classCallCheck( this, DepthTexture );
            format = format !== undefined ? format : DepthFormat;
            if ( format !== DepthFormat && format !== DepthStencilFormat ) {
                throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );
            }
            if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
            if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
            _this24 = _super26.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
            _this24.isDepthTexture = true;
            _this24.image = {
                width: width,
                height: height
            };
            _this24.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
            _this24.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
            _this24.flipY = false;
            _this24.generateMipmaps = false;
            return _this24;
        }
        return _createClass( DepthTexture );
    }( Texture );
    var WebXRManager = /*#__PURE__*/ function( _EventDispatcher6 ) {
        _inherits( WebXRManager, _EventDispatcher6 );
        var _super27 = _createSuper( WebXRManager );

        function WebXRManager( renderer, gl ) {
            var _this25;
            _classCallCheck( this, WebXRManager );
            _this25 = _super27.call( this );
            var scope = _assertThisInitialized( _this25 );
            var session = null;
            var framebufferScaleFactor = 1.0;
            var referenceSpace = null;
            var referenceSpaceType = 'local-floor';
            var customReferenceSpace = null;
            var pose = null;
            var glBinding = null;
            var glProjLayer = null;
            var glBaseLayer = null;
            var xrFrame = null;
            var attributes = gl.getContextAttributes( );
            var initialRenderTarget = null;
            var newRenderTarget = null;
            var controllers = [ ];
            var controllerInputSources = [ ]; //
            var cameraL = new PerspectiveCamera( );
            cameraL.layers.enable( 1 );
            cameraL.viewport = new Vector4( );
            var cameraR = new PerspectiveCamera( );
            cameraR.layers.enable( 2 );
            cameraR.viewport = new Vector4( );
            var cameras = [ cameraL, cameraR ];
            var cameraVR = new ArrayCamera( );
            cameraVR.layers.enable( 1 );
            cameraVR.layers.enable( 2 );
            var _currentDepthNear = null;
            var _currentDepthFar = null; //
            _this25.cameraAutoUpdate = true;
            _this25.enabled = false;
            _this25.isPresenting = false;
            _this25.getController = function( index ) {
                var controller = controllers[ index ];
                if ( controller === undefined ) {
                    controller = new WebXRController( );
                    controllers[ index ] = controller;
                }
                return controller.getTargetRaySpace( );
            };
            _this25.getControllerGrip = function( index ) {
                var controller = controllers[ index ];
                if ( controller === undefined ) {
                    controller = new WebXRController( );
                    controllers[ index ] = controller;
                }
                return controller.getGripSpace( );
            };
            _this25.getHand = function( index ) {
                var controller = controllers[ index ];
                if ( controller === undefined ) {
                    controller = new WebXRController( );
                    controllers[ index ] = controller;
                }
                return controller.getHandSpace( );
            }; //
            function onSessionEvent( event ) {
                var controllerIndex = controllerInputSources.indexOf( event.inputSource );
                if ( controllerIndex === -1 ) {
                    return;
                }
                var controller = controllers[ controllerIndex ];
                if ( controller !== undefined ) {
                    controller.dispatchEvent( {
                        type: event.type,
                        data: event.inputSource
                    } );
                }
            }

            function onSessionEnd( ) {
                session.removeEventListener( 'select', onSessionEvent );
                session.removeEventListener( 'selectstart', onSessionEvent );
                session.removeEventListener( 'selectend', onSessionEvent );
                session.removeEventListener( 'squeeze', onSessionEvent );
                session.removeEventListener( 'squeezestart', onSessionEvent );
                session.removeEventListener( 'squeezeend', onSessionEvent );
                session.removeEventListener( 'end', onSessionEnd );
                session.removeEventListener( 'inputsourceschange', onInputSourcesChange );
                for ( var _i145 = 0; _i145 < controllers.length; _i145++ ) {
                    var inputSource = controllerInputSources[ _i145 ];
                    if ( inputSource === null ) continue;
                    controllerInputSources[ _i145 ] = null;
                    controllers[ _i145 ].disconnect( inputSource );
                }
                _currentDepthNear = null;
                _currentDepthFar = null; // restore framebuffer/rendering state
                renderer.setRenderTarget( initialRenderTarget );
                glBaseLayer = null;
                glProjLayer = null;
                glBinding = null;
                session = null;
                newRenderTarget = null; //
                animation.stop( );
                scope.isPresenting = false;
                scope.dispatchEvent( {
                    type: 'sessionend'
                } );
            }
            _this25.setFramebufferScaleFactor = function( value ) {
                framebufferScaleFactor = value;
                if ( scope.isPresenting === true ) {
                    console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );
                }
            };
            _this25.setReferenceSpaceType = function( value ) {
                referenceSpaceType = value;
                if ( scope.isPresenting === true ) {
                    console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );
                }
            };
            _this25.getReferenceSpace = function( ) {
                return customReferenceSpace || referenceSpace;
            };
            _this25.setReferenceSpace = function( space ) {
                customReferenceSpace = space;
            };
            _this25.getBaseLayer = function( ) {
                return glProjLayer !== null ? glProjLayer : glBaseLayer;
            };
            _this25.getBinding = function( ) {
                return glBinding;
            };
            _this25.getFrame = function( ) {
                return xrFrame;
            };
            _this25.getSession = function( ) {
                return session;
            };
            _this25.setSession = /*#__PURE__*/ function( ) {
                var _ref = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee( value ) {
                    var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit, renderTargetProperties;
                    return _regeneratorRuntime( ).wrap( function _callee$( _context8 ) {
                        while ( 1 ) {
                            switch ( _context8.prev = _context8.next ) {
                                case 0:
                                    session = value;
                                    if ( !( session !== null ) ) {
                                        _context8.next = 25;
                                        break;
                                    }
                                    initialRenderTarget = renderer.getRenderTarget( );
                                    session.addEventListener( 'select', onSessionEvent );
                                    session.addEventListener( 'selectstart', onSessionEvent );
                                    session.addEventListener( 'selectend', onSessionEvent );
                                    session.addEventListener( 'squeeze', onSessionEvent );
                                    session.addEventListener( 'squeezestart', onSessionEvent );
                                    session.addEventListener( 'squeezeend', onSessionEvent );
                                    session.addEventListener( 'end', onSessionEnd );
                                    session.addEventListener( 'inputsourceschange', onInputSourcesChange );
                                    if ( !( attributes.xrCompatible !== true ) ) {
                                        _context8.next = 14;
                                        break;
                                    }
                                    _context8.next = 14;
                                    return gl.makeXRCompatible( );
                                case 14:
                                    if ( session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false ) {
                                        layerInit = {
                                            antialias: session.renderState.layers === undefined ? attributes.antialias : true,
                                            alpha: attributes.alpha,
                                            depth: attributes.depth,
                                            stencil: attributes.stencil,
                                            framebufferScaleFactor: framebufferScaleFactor
                                        };
                                        glBaseLayer = new XRWebGLLayer( session, gl, layerInit );
                                        session.updateRenderState( {
                                            baseLayer: glBaseLayer
                                        } );
                                        newRenderTarget = new WebGLRenderTarget( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                                            format: RGBAFormat,
                                            type: UnsignedByteType,
                                            encoding: renderer.outputEncoding
                                        } );
                                    } else {
                                        depthFormat = null;
                                        depthType = null;
                                        glDepthFormat = null;
                                        if ( attributes.depth ) {
                                            glDepthFormat = attributes.stencil ? 35056 : 33190;
                                            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                                            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                                        }
                                        projectionlayerInit = {
                                            colorFormat: 32856,
                                            depthFormat: glDepthFormat,
                                            scaleFactor: framebufferScaleFactor
                                        };
                                        glBinding = new XRWebGLBinding( session, gl );
                                        glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );
                                        session.updateRenderState( {
                                            layers: [ glProjLayer ]
                                        } );
                                        newRenderTarget = new WebGLRenderTarget( glProjLayer.textureWidth, glProjLayer.textureHeight, {
                                            format: RGBAFormat,
                                            type: UnsignedByteType,
                                            depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
                                            stencilBuffer: attributes.stencil,
                                            encoding: renderer.outputEncoding,
                                            samples: attributes.antialias ? 4 : 0
                                        } );
                                        renderTargetProperties = renderer.properties.get( newRenderTarget );
                                        renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
                                    }
                                    newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278
                                    // Set foveation to maximum.
                                    this.setFoveation( 1.0 );
                                    customReferenceSpace = null;
                                    _context8.next = 20;
                                    return session.requestReferenceSpace( referenceSpaceType );
                                case 20:
                                    referenceSpace = _context8.sent;
                                    animation.setContext( session );
                                    animation.start( );
                                    scope.isPresenting = true;
                                    scope.dispatchEvent( {
                                        type: 'sessionstart'
                                    } );
                                case 25:
                                case "end":
                                    return _context8.stop( );
                            }
                        }
                    }, _callee, this );
                } ) );
                return function( _x8 ) {
                    return _ref.apply( this, arguments );
                };
            }( );

            function onInputSourcesChange( event ) { // Notify disconnected
                for ( var _i146 = 0; _i146 < event.removed.length; _i146++ ) {
                    var inputSource = event.removed[ _i146 ];
                    var index = controllerInputSources.indexOf( inputSource );
                    if ( index >= 0 ) {
                        controllerInputSources[ index ] = null;
                        controllers[ index ].dispatchEvent( {
                            type: 'disconnected',
                            data: inputSource
                        } );
                    }
                } // Notify connected
                for ( var _i147 = 0; _i147 < event.added.length; _i147++ ) {
                    var _inputSource = event.added[ _i147 ];
                    var controllerIndex = controllerInputSources.indexOf( _inputSource );
                    if ( controllerIndex === -1 ) { // Assign input source a controller that currently has no input source
                        for ( var _i148 = 0; _i148 < controllers.length; _i148++ ) {
                            if ( _i148 >= controllerInputSources.length ) {
                                controllerInputSources.push( _inputSource );
                                controllerIndex = _i148;
                                break;
                            } else if ( controllerInputSources[ _i148 ] === null ) {
                                controllerInputSources[ _i148 ] = _inputSource;
                                controllerIndex = _i148;
                                break;
                            }
                        } // If all controllers do currently receive input we ignore new ones
                        if ( controllerIndex === -1 ) break;
                    }
                    var controller = controllers[ controllerIndex ];
                    if ( controller ) {
                        controller.dispatchEvent( {
                            type: 'connected',
                            data: _inputSource
                        } );
                    }
                }
            } //
            var cameraLPos = new Vector3( );
            var cameraRPos = new Vector3( );
            /**
             * Assumes 2 cameras that are parallel and share an X-axis, and that
             * the cameras' projection and world matrices have already been set.
             * And that near and far planes are identical for both cameras.
             * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
             */
            function setProjectionFromUnion( camera, cameraL, cameraR ) {
                cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
                cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );
                var ipd = cameraLPos.distanceTo( cameraRPos );
                var projL = cameraL.projectionMatrix.elements;
                var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
                // most likely identical top and bottom frustum extents.
                // Use the left camera for these values.
                var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
                var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
                var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
                var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];
                var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
                var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
                var left = near * leftFov;
                var right = near * rightFov; // Calculate the new camera's position offset from the
                // left camera. xOffset should be roughly half `ipd`.
                var zOffset = ipd / ( -leftFov + rightFov );
                var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?
                cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
                camera.translateX( xOffset );
                camera.translateZ( zOffset );
                camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
                camera.matrixWorldInverse.copy( camera.matrixWorld ).invert( ); // Find the union of the frustum values of the cameras and scale
                // the values so that the near plane's position does not change in world space,
                // although must now be relative to the new union camera.
                var near2 = near + zOffset;
                var far2 = far + zOffset;
                var left2 = left - xOffset;
                var right2 = right + ( ipd - xOffset );
                var top2 = topFov * far / far2 * near2;
                var bottom2 = bottomFov * far / far2 * near2;
                camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
            }

            function updateCamera( camera, parent ) {
                if ( parent === null ) {
                    camera.matrixWorld.copy( camera.matrix );
                } else {
                    camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );
                }
                camera.matrixWorldInverse.copy( camera.matrixWorld ).invert( );
            }
            _this25.updateCamera = function( camera ) {
                if ( session === null ) return;
                cameraVR.near = cameraR.near = cameraL.near = camera.near;
                cameraVR.far = cameraR.far = cameraL.far = camera.far;
                if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) { // Note that the new renderState won't apply until the next frame. See #18320
                    session.updateRenderState( {
                        depthNear: cameraVR.near,
                        depthFar: cameraVR.far
                    } );
                    _currentDepthNear = cameraVR.near;
                    _currentDepthFar = cameraVR.far;
                }
                var parent = camera.parent;
                var cameras = cameraVR.cameras;
                updateCamera( cameraVR, parent );
                for ( var _i149 = 0; _i149 < cameras.length; _i149++ ) {
                    updateCamera( cameras[ _i149 ], parent );
                }
                cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale ); // update user camera and its children
                camera.position.copy( cameraVR.position );
                camera.quaternion.copy( cameraVR.quaternion );
                camera.scale.copy( cameraVR.scale );
                camera.matrix.copy( cameraVR.matrix );
                camera.matrixWorld.copy( cameraVR.matrixWorld );
                var children = camera.children;
                for ( var _i150 = 0, l = children.length; _i150 < l; _i150++ ) {
                    children[ _i150 ].updateMatrixWorld( true );
                } // update projection matrix for proper view frustum culling
                if ( cameras.length === 2 ) {
                    setProjectionFromUnion( cameraVR, cameraL, cameraR );
                } else { // assume single camera setup (AR)
                    cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );
                }
            };
            _this25.getCamera = function( ) {
                return cameraVR;
            };
            _this25.getFoveation = function( ) {
                if ( glProjLayer !== null ) {
                    return glProjLayer.fixedFoveation;
                }
                if ( glBaseLayer !== null ) {
                    return glBaseLayer.fixedFoveation;
                }
                return undefined;
            };
            _this25.setFoveation = function( foveation ) { // 0 = no foveation = full resolution
                // 1 = maximum foveation = the edges render at lower resolution
                if ( glProjLayer !== null ) {
                    glProjLayer.fixedFoveation = foveation;
                }
                if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {
                    glBaseLayer.fixedFoveation = foveation;
                }
            }; // Animation Loop
            var onAnimationFrameCallback = null;

            function onAnimationFrame( time, frame ) {
                pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
                xrFrame = frame;
                if ( pose !== null ) {
                    var views = pose.views;
                    if ( glBaseLayer !== null ) {
                        renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
                        renderer.setRenderTarget( newRenderTarget );
                    }
                    var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list
                    if ( views.length !== cameraVR.cameras.length ) {
                        cameraVR.cameras.length = 0;
                        cameraVRNeedsUpdate = true;
                    }
                    for ( var _i151 = 0; _i151 < views.length; _i151++ ) {
                        var view = views[ _i151 ];
                        var viewport = null;
                        if ( glBaseLayer !== null ) {
                            viewport = glBaseLayer.getViewport( view );
                        } else {
                            var glSubImage = glBinding.getViewSubImage( glProjLayer, view );
                            viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.
                            if ( _i151 === 0 ) {
                                renderer.setRenderTargetTextures( newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );
                                renderer.setRenderTarget( newRenderTarget );
                            }
                        }
                        var _camera = cameras[ _i151 ];
                        if ( _camera === undefined ) {
                            _camera = new PerspectiveCamera( );
                            _camera.layers.enable( _i151 );
                            _camera.viewport = new Vector4( );
                            cameras[ _i151 ] = _camera;
                        }
                        _camera.matrix.fromArray( view.transform.matrix );
                        _camera.projectionMatrix.fromArray( view.projectionMatrix );
                        _camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );
                        if ( _i151 === 0 ) {
                            cameraVR.matrix.copy( _camera.matrix );
                        }
                        if ( cameraVRNeedsUpdate === true ) {
                            cameraVR.cameras.push( _camera );
                        }
                    }
                } //
                for ( var _i152 = 0; _i152 < controllers.length; _i152++ ) {
                    var inputSource = controllerInputSources[ _i152 ];
                    var controller = controllers[ _i152 ];
                    if ( inputSource !== null && controller !== undefined ) {
                        controller.update( inputSource, frame, customReferenceSpace || referenceSpace );
                    }
                }
                if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );
                xrFrame = null;
            }
            var animation = new WebGLAnimation( );
            animation.setAnimationLoop( onAnimationFrame );
            _this25.setAnimationLoop = function( callback ) {
                onAnimationFrameCallback = callback;
            };
            _this25.dispose = function( ) {};
            return _this25;
        }
        return _createClass( WebXRManager );
    }( EventDispatcher );

    function WebGLMaterials( renderer, properties ) {
        function refreshFogUniforms( uniforms, fog ) {
            uniforms.fogColor.value.copy( fog.color );
            if ( fog.isFog ) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if ( fog.isFogExp2 ) {
                uniforms.fogDensity.value = fog.density;
            }
        }

        function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {
            if ( material.isMeshBasicMaterial ) {
                refreshUniformsCommon( uniforms, material );
            } else if ( material.isMeshLambertMaterial ) {
                refreshUniformsCommon( uniforms, material );
            } else if ( material.isMeshToonMaterial ) {
                refreshUniformsCommon( uniforms, material );
                refreshUniformsToon( uniforms, material );
            } else if ( material.isMeshPhongMaterial ) {
                refreshUniformsCommon( uniforms, material );
                refreshUniformsPhong( uniforms, material );
            } else if ( material.isMeshStandardMaterial ) {
                refreshUniformsCommon( uniforms, material );
                refreshUniformsStandard( uniforms, material );
                if ( material.isMeshPhysicalMaterial ) {
                    refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );
                }
            } else if ( material.isMeshMatcapMaterial ) {
                refreshUniformsCommon( uniforms, material );
                refreshUniformsMatcap( uniforms, material );
            } else if ( material.isMeshDepthMaterial ) {
                refreshUniformsCommon( uniforms, material );
            } else if ( material.isMeshDistanceMaterial ) {
                refreshUniformsCommon( uniforms, material );
                refreshUniformsDistance( uniforms, material );
            } else if ( material.isMeshNormalMaterial ) {
                refreshUniformsCommon( uniforms, material );
            } else if ( material.isLineBasicMaterial ) {
                refreshUniformsLine( uniforms, material );
                if ( material.isLineDashedMaterial ) {
                    refreshUniformsDash( uniforms, material );
                }
            } else if ( material.isPointsMaterial ) {
                refreshUniformsPoints( uniforms, material, pixelRatio, height );
            } else if ( material.isSpriteMaterial ) {
                refreshUniformsSprites( uniforms, material );
            } else if ( material.isShadowMaterial ) {
                uniforms.color.value.copy( material.color );
                uniforms.opacity.value = material.opacity;
            } else if ( material.isShaderMaterial ) {
                material.uniformsNeedUpdate = false; // #15581
            }
        }

        function refreshUniformsCommon( uniforms, material ) {
            uniforms.opacity.value = material.opacity;
            if ( material.color ) {
                uniforms.diffuse.value.copy( material.color );
            }
            if ( material.emissive ) {
                uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
            }
            if ( material.map ) {
                uniforms.map.value = material.map;
            }
            if ( material.alphaMap ) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if ( material.bumpMap ) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= -1;
            }
            if ( material.displacementMap ) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if ( material.emissiveMap ) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if ( material.normalMap ) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate( );
            }
            if ( material.specularMap ) {
                uniforms.specularMap.value = material.specularMap;
            }
            if ( material.alphaTest > 0 ) {
                uniforms.alphaTest.value = material.alphaTest;
            }
            var envMap = properties.get( material ).envMap;
            if ( envMap ) {
                uniforms.envMap.value = envMap;
                uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.ior.value = material.ior;
                uniforms.refractionRatio.value = material.refractionRatio;
            }
            if ( material.lightMap ) {
                uniforms.lightMap.value = material.lightMap; // artist-friendly light intensity scaling factor
                var scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
                uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
            }
            if ( material.aoMap ) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            } // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. displacementMap map
            // 4. normal map
            // 5. bump map
            // 6. roughnessMap map
            // 7. metalnessMap map
            // 8. alphaMap map
            // 9. emissiveMap map
            // 10. clearcoat map
            // 11. clearcoat normal map
            // 12. clearcoat roughnessMap map
            // 13. iridescence map
            // 14. iridescence thickness map
            // 15. specular intensity map
            // 16. specular tint map
            // 17. transmission map
            // 18. thickness map
            var uvScaleMap;
            if ( material.map ) {
                uvScaleMap = material.map;
            } else if ( material.specularMap ) {
                uvScaleMap = material.specularMap;
            } else if ( material.displacementMap ) {
                uvScaleMap = material.displacementMap;
            } else if ( material.normalMap ) {
                uvScaleMap = material.normalMap;
            } else if ( material.bumpMap ) {
                uvScaleMap = material.bumpMap;
            } else if ( material.roughnessMap ) {
                uvScaleMap = material.roughnessMap;
            } else if ( material.metalnessMap ) {
                uvScaleMap = material.metalnessMap;
            } else if ( material.alphaMap ) {
                uvScaleMap = material.alphaMap;
            } else if ( material.emissiveMap ) {
                uvScaleMap = material.emissiveMap;
            } else if ( material.clearcoatMap ) {
                uvScaleMap = material.clearcoatMap;
            } else if ( material.clearcoatNormalMap ) {
                uvScaleMap = material.clearcoatNormalMap;
            } else if ( material.clearcoatRoughnessMap ) {
                uvScaleMap = material.clearcoatRoughnessMap;
            } else if ( material.iridescenceMap ) {
                uvScaleMap = material.iridescenceMap;
            } else if ( material.iridescenceThicknessMap ) {
                uvScaleMap = material.iridescenceThicknessMap;
            } else if ( material.specularIntensityMap ) {
                uvScaleMap = material.specularIntensityMap;
            } else if ( material.specularColorMap ) {
                uvScaleMap = material.specularColorMap;
            } else if ( material.transmissionMap ) {
                uvScaleMap = material.transmissionMap;
            } else if ( material.thicknessMap ) {
                uvScaleMap = material.thicknessMap;
            } else if ( material.sheenColorMap ) {
                uvScaleMap = material.sheenColorMap;
            } else if ( material.sheenRoughnessMap ) {
                uvScaleMap = material.sheenRoughnessMap;
            }
            if ( uvScaleMap !== undefined ) { // backwards compatibility
                if ( uvScaleMap.isWebGLRenderTarget ) {
                    uvScaleMap = uvScaleMap.texture;
                }
                if ( uvScaleMap.matrixAutoUpdate === true ) {
                    uvScaleMap.updateMatrix( );
                }
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
            } // uv repeat and offset setting priorities for uv2
            // 1. ao map
            // 2. light map
            var uv2ScaleMap;
            if ( material.aoMap ) {
                uv2ScaleMap = material.aoMap;
            } else if ( material.lightMap ) {
                uv2ScaleMap = material.lightMap;
            }
            if ( uv2ScaleMap !== undefined ) { // backwards compatibility
                if ( uv2ScaleMap.isWebGLRenderTarget ) {
                    uv2ScaleMap = uv2ScaleMap.texture;
                }
                if ( uv2ScaleMap.matrixAutoUpdate === true ) {
                    uv2ScaleMap.updateMatrix( );
                }
                uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );
            }
        }

        function refreshUniformsLine( uniforms, material ) {
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
        }

        function refreshUniformsDash( uniforms, material ) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }

        function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * pixelRatio;
            uniforms.scale.value = height * 0.5;
            if ( material.map ) {
                uniforms.map.value = material.map;
            }
            if ( material.alphaMap ) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if ( material.alphaTest > 0 ) {
                uniforms.alphaTest.value = material.alphaTest;
            } // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if ( material.map ) {
                uvScaleMap = material.map;
            } else if ( material.alphaMap ) {
                uvScaleMap = material.alphaMap;
            }
            if ( uvScaleMap !== undefined ) {
                if ( uvScaleMap.matrixAutoUpdate === true ) {
                    uvScaleMap.updateMatrix( );
                }
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
            }
        }

        function refreshUniformsSprites( uniforms, material ) {
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
            uniforms.rotation.value = material.rotation;
            if ( material.map ) {
                uniforms.map.value = material.map;
            }
            if ( material.alphaMap ) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if ( material.alphaTest > 0 ) {
                uniforms.alphaTest.value = material.alphaTest;
            } // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if ( material.map ) {
                uvScaleMap = material.map;
            } else if ( material.alphaMap ) {
                uvScaleMap = material.alphaMap;
            }
            if ( uvScaleMap !== undefined ) {
                if ( uvScaleMap.matrixAutoUpdate === true ) {
                    uvScaleMap.updateMatrix( );
                }
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
            }
        }

        function refreshUniformsPhong( uniforms, material ) {
            uniforms.specular.value.copy( material.specular );
            uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
        }

        function refreshUniformsToon( uniforms, material ) {
            if ( material.gradientMap ) {
                uniforms.gradientMap.value = material.gradientMap;
            }
        }

        function refreshUniformsStandard( uniforms, material ) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if ( material.roughnessMap ) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if ( material.metalnessMap ) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            var envMap = properties.get( material ).envMap;
            if ( envMap ) { //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }

        function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {
            uniforms.ior.value = material.ior; // also part of uniforms common
            if ( material.sheen > 0 ) {
                uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );
                uniforms.sheenRoughness.value = material.sheenRoughness;
                if ( material.sheenColorMap ) {
                    uniforms.sheenColorMap.value = material.sheenColorMap;
                }
                if ( material.sheenRoughnessMap ) {
                    uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
                }
            }
            if ( material.clearcoat > 0 ) {
                uniforms.clearcoat.value = material.clearcoat;
                uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
                if ( material.clearcoatMap ) {
                    uniforms.clearcoatMap.value = material.clearcoatMap;
                }
                if ( material.clearcoatRoughnessMap ) {
                    uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
                }
                if ( material.clearcoatNormalMap ) {
                    uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
                    uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                    if ( material.side === BackSide ) {
                        uniforms.clearcoatNormalScale.value.negate( );
                    }
                }
            }
            if ( material.iridescence > 0 ) {
                uniforms.iridescence.value = material.iridescence;
                uniforms.iridescenceIOR.value = material.iridescenceIOR;
                uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
                uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];
                if ( material.iridescenceMap ) {
                    uniforms.iridescenceMap.value = material.iridescenceMap;
                }
                if ( material.iridescenceThicknessMap ) {
                    uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
                }
            }
            if ( material.transmission > 0 ) {
                uniforms.transmission.value = material.transmission;
                uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
                uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );
                if ( material.transmissionMap ) {
                    uniforms.transmissionMap.value = material.transmissionMap;
                }
                uniforms.thickness.value = material.thickness;
                if ( material.thicknessMap ) {
                    uniforms.thicknessMap.value = material.thicknessMap;
                }
                uniforms.attenuationDistance.value = material.attenuationDistance;
                uniforms.attenuationColor.value.copy( material.attenuationColor );
            }
            uniforms.specularIntensity.value = material.specularIntensity;
            uniforms.specularColor.value.copy( material.specularColor );
            if ( material.specularIntensityMap ) {
                uniforms.specularIntensityMap.value = material.specularIntensityMap;
            }
            if ( material.specularColorMap ) {
                uniforms.specularColorMap.value = material.specularColorMap;
            }
        }

        function refreshUniformsMatcap( uniforms, material ) {
            if ( material.matcap ) {
                uniforms.matcap.value = material.matcap;
            }
        }

        function refreshUniformsDistance( uniforms, material ) {
            uniforms.referencePosition.value.copy( material.referencePosition );
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }
        return {
            refreshFogUniforms: refreshFogUniforms,
            refreshMaterialUniforms: refreshMaterialUniforms
        };
    }

    function createCanvasElement( ) {
        var canvas = createElementNS( 'canvas' );
        canvas.style.display = 'block';
        return canvas;
    }

    function WebGLRenderer( ) {
        var parameters = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : {};
        this.isWebGLRenderer = true;
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement( ),
            _context = parameters.context !== undefined ? parameters.context : null,
            _depth = parameters.depth !== undefined ? parameters.depth : true,
            _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
            _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
            _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
        var _alpha;
        if ( _context !== null ) {
            _alpha = _context.getContextAttributes( ).alpha;
        } else {
            _alpha = parameters.alpha !== undefined ? parameters.alpha : false;
        }
        var currentRenderList = null;
        var currentRenderState = null; // render() can be called from within a callback triggered by another render.
        // We track this so that the nested render call gets its list and state isolated from the parent render call.
        var renderListStack = [ ];
        var renderStateStack = [ ]; // public properties
        this.domElement = _canvas; // Debug configuration container
        this.debug = {
            /**
             * Enables error checking and reporting when shader programs are being compiled
             * @type {boolean}
             */
            checkShaderErrors: true
        }; // clearing
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true; // scene graph
        this.sortObjects = true; // user-defined clipping
        this.clippingPlanes = [ ];
        this.localClippingEnabled = false; // physically based shading
        this.outputEncoding = LinearEncoding; // physical lights
        this.physicallyCorrectLights = false; // tone mapping
        this.toneMapping = NoToneMapping;
        this.toneMappingExposure = 1.0; //
        Object.defineProperties( this, { // @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d
            gammaFactor: {
                get: function get( ) {
                    console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
                    return 2;
                },
                set: function set( ) {
                    console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
                }
            }
        } ); // internal properties
        var _this = this;
        var _isContextLost = false; // internal state cache
        var _currentActiveCubeFace = 0;
        var _currentActiveMipmapLevel = 0;
        var _currentRenderTarget = null;
        var _currentMaterialId = -1;
        var _currentCamera = null;
        var _currentViewport = new Vector4( );
        var _currentScissor = new Vector4( );
        var _currentScissorTest = null; //
        var _width = _canvas.width;
        var _height = _canvas.height;
        var _pixelRatio = 1;
        var _opaqueSort = null;
        var _transparentSort = null;
        var _viewport = new Vector4( 0, 0, _width, _height );
        var _scissor = new Vector4( 0, 0, _width, _height );
        var _scissorTest = false; // frustum
        var _frustum = new Frustum( ); // clipping
        var _clippingEnabled = false;
        var _localClippingEnabled = false; // transmission
        var _transmissionRenderTarget = null; // camera matrices cache
        var _projScreenMatrix = new Matrix4( );
        var _vector2 = new Vector2( );
        var _vector3 = new Vector3( );
        var _emptyScene = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
        };

        function getTargetPixelRatio( ) {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        } // initialize
        var _gl = _context;

        function getContext( contextNames, contextAttributes ) {
            for ( var _i153 = 0; _i153 < contextNames.length; _i153++ ) {
                var contextName = contextNames[ _i153 ];
                var context = _canvas.getContext( contextName, contextAttributes );
                if ( context !== null ) return context;
            }
            return null;
        }
        try {
            var contextAttributes = {
                alpha: true,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference,
                failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
            }; // OffscreenCanvas does not have setAttribute, see #22811
            if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', "three.js r".concat( REVISION ) ); // event listeners must be registered before WebGL context is created, see #12753
            _canvas.addEventListener( 'webglcontextlost', onContextLost, false );
            _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
            _canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );
            if ( _gl === null ) {
                var contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];
                if ( _this.isWebGL1Renderer === true ) {
                    contextNames.shift( );
                }
                _gl = getContext( contextNames, contextAttributes );
                if ( _gl === null ) {
                    if ( getContext( contextNames ) ) {
                        throw new Error( 'Error creating WebGL context with your selected attributes.' );
                    } else {
                        throw new Error( 'Error creating WebGL context.' );
                    }
                }
            } // Some experimental-webgl implementations do not have getShaderPrecisionFormat
            if ( _gl.getShaderPrecisionFormat === undefined ) {
                _gl.getShaderPrecisionFormat = function( ) {
                    return {
                        'rangeMin': 1,
                        'rangeMax': 1,
                        'precision': 1
                    };
                };
            }
        } catch ( error ) {
            console.error( 'THREE.WebGLRenderer: ' + error.message );
            throw error;
        }
        var extensions, capabilities, state, info;
        var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
        var programCache, materials, renderLists, renderStates, clipping, shadowMap;
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
        var utils, bindingStates;

        function initGLContext( ) {
            extensions = new WebGLExtensions( _gl );
            capabilities = new WebGLCapabilities( _gl, extensions, parameters );
            extensions.init( capabilities );
            utils = new WebGLUtils( _gl, extensions, capabilities );
            state = new WebGLState( _gl, extensions, capabilities );
            info = new WebGLInfo( );
            properties = new WebGLProperties( );
            textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
            cubemaps = new WebGLCubeMaps( _this );
            cubeuvmaps = new WebGLCubeUVMaps( _this );
            attributes = new WebGLAttributes( _gl, capabilities );
            bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
            geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
            objects = new WebGLObjects( _gl, geometries, attributes, info );
            morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
            clipping = new WebGLClipping( properties );
            programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
            materials = new WebGLMaterials( _this, properties );
            renderLists = new WebGLRenderLists( );
            renderStates = new WebGLRenderStates( extensions, capabilities );
            background = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );
            shadowMap = new WebGLShadowMap( _this, objects, capabilities );
            bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
            indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );
            info.programs = programCache.programs;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.shadowMap = shadowMap;
            _this.state = state;
            _this.info = info;
        }
        initGLContext( ); // xr
        var xr = new WebXRManager( _this, _gl );
        this.xr = xr; // API
        this.getContext = function( ) {
            return _gl;
        };
        this.getContextAttributes = function( ) {
            return _gl.getContextAttributes( );
        };
        this.forceContextLoss = function( ) {
            var extension = extensions.get( 'WEBGL_lose_context' );
            if ( extension ) extension.loseContext( );
        };
        this.forceContextRestore = function( ) {
            var extension = extensions.get( 'WEBGL_lose_context' );
            if ( extension ) extension.restoreContext( );
        };
        this.getPixelRatio = function( ) {
            return _pixelRatio;
        };
        this.setPixelRatio = function( value ) {
            if ( value === undefined ) return;
            _pixelRatio = value;
            this.setSize( _width, _height, false );
        };
        this.getSize = function( target ) {
            return target.set( _width, _height );
        };
        this.setSize = function( width, height, updateStyle ) {
            if ( xr.isPresenting ) {
                console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
                return;
            }
            _width = width;
            _height = height;
            _canvas.width = Math.floor( width * _pixelRatio );
            _canvas.height = Math.floor( height * _pixelRatio );
            if ( updateStyle !== false ) {
                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }
            this.setViewport( 0, 0, width, height );
        };
        this.getDrawingBufferSize = function( target ) {
            return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor( );
        };
        this.setDrawingBufferSize = function( width, height, pixelRatio ) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            _canvas.width = Math.floor( width * pixelRatio );
            _canvas.height = Math.floor( height * pixelRatio );
            this.setViewport( 0, 0, width, height );
        };
        this.getCurrentViewport = function( target ) {
            return target.copy( _currentViewport );
        };
        this.getViewport = function( target ) {
            return target.copy( _viewport );
        };
        this.setViewport = function( x, y, width, height ) {
            if ( x.isVector4 ) {
                _viewport.set( x.x, x.y, x.z, x.w );
            } else {
                _viewport.set( x, y, width, height );
            }
            state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor( ) );
        };
        this.getScissor = function( target ) {
            return target.copy( _scissor );
        };
        this.setScissor = function( x, y, width, height ) {
            if ( x.isVector4 ) {
                _scissor.set( x.x, x.y, x.z, x.w );
            } else {
                _scissor.set( x, y, width, height );
            }
            state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor( ) );
        };
        this.getScissorTest = function( ) {
            return _scissorTest;
        };
        this.setScissorTest = function( _boolean ) {
            state.setScissorTest( _scissorTest = _boolean );
        };
        this.setOpaqueSort = function( method ) {
            _opaqueSort = method;
        };
        this.setTransparentSort = function( method ) {
            _transparentSort = method;
        }; // Clearing
        this.getClearColor = function( target ) {
            return target.copy( background.getClearColor( ) );
        };
        this.setClearColor = function( ) {
            background.setClearColor.apply( background, arguments );
        };
        this.getClearAlpha = function( ) {
            return background.getClearAlpha( );
        };
        this.setClearAlpha = function( ) {
            background.setClearAlpha.apply( background, arguments );
        };
        this.clear = function( ) {
            var color = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : true;
            var depth = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : true;
            var stencil = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : true;
            var bits = 0;
            if ( color ) bits |= 16384;
            if ( depth ) bits |= 256;
            if ( stencil ) bits |= 1024;
            _gl.clear( bits );
        };
        this.clearColor = function( ) {
            this.clear( true, false, false );
        };
        this.clearDepth = function( ) {
            this.clear( false, true, false );
        };
        this.clearStencil = function( ) {
            this.clear( false, false, true );
        }; //
        this.dispose = function( ) {
            _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
            _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
            _canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );
            renderLists.dispose( );
            renderStates.dispose( );
            properties.dispose( );
            cubemaps.dispose( );
            cubeuvmaps.dispose( );
            objects.dispose( );
            bindingStates.dispose( );
            programCache.dispose( );
            xr.dispose( );
            xr.removeEventListener( 'sessionstart', onXRSessionStart );
            xr.removeEventListener( 'sessionend', onXRSessionEnd );
            if ( _transmissionRenderTarget ) {
                _transmissionRenderTarget.dispose( );
                _transmissionRenderTarget = null;
            }
            animation.stop( );
        }; // Events
        function onContextLost( event ) {
            event.preventDefault( );
            console.log( 'THREE.WebGLRenderer: Context Lost.' );
            _isContextLost = true;
        }

        function /* event */ onContextRestore( ) {
            console.log( 'THREE.WebGLRenderer: Context Restored.' );
            _isContextLost = false;
            var infoAutoReset = info.autoReset;
            var shadowMapEnabled = shadowMap.enabled;
            var shadowMapAutoUpdate = shadowMap.autoUpdate;
            var shadowMapNeedsUpdate = shadowMap.needsUpdate;
            var shadowMapType = shadowMap.type;
            initGLContext( );
            info.autoReset = infoAutoReset;
            shadowMap.enabled = shadowMapEnabled;
            shadowMap.autoUpdate = shadowMapAutoUpdate;
            shadowMap.needsUpdate = shadowMapNeedsUpdate;
            shadowMap.type = shadowMapType;
        }

        function onContextCreationError( event ) {
            console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );
        }

        function onMaterialDispose( event ) {
            var material = event.target;
            material.removeEventListener( 'dispose', onMaterialDispose );
            deallocateMaterial( material );
        } // Buffer deallocation
        function deallocateMaterial( material ) {
            releaseMaterialProgramReferences( material );
            properties.remove( material );
        }

        function releaseMaterialProgramReferences( material ) {
            var programs = properties.get( material ).programs;
            if ( programs !== undefined ) {
                programs.forEach( function( program ) {
                    programCache.releaseProgram( program );
                } );
                if ( material.isShaderMaterial ) {
                    programCache.releaseShaderCache( material );
                }
            }
        } // Buffer rendering
        this.renderBufferDirect = function( camera, scene, geometry, material, object, group ) {
            if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
            var frontFaceCW = object.isMesh && object.matrixWorld.determinant( ) < 0;
            var program = setProgram( camera, scene, geometry, material, object );
            state.setMaterial( material, frontFaceCW ); //
            var index = geometry.index;
            var position = geometry.attributes.position; //
            if ( index === null ) {
                if ( position === undefined || position.count === 0 ) return;
            } else if ( index.count === 0 ) {
                return;
            } //
            var rangeFactor = 1;
            if ( material.wireframe === true ) {
                index = geometries.getWireframeAttribute( geometry );
                rangeFactor = 2;
            }
            bindingStates.setup( object, material, program, geometry, index );
            var attribute;
            var renderer = bufferRenderer;
            if ( index !== null ) {
                attribute = attributes.get( index );
                renderer = indexedBufferRenderer;
                renderer.setIndex( attribute );
            } //
            var dataCount = index !== null ? index.count : position.count;
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max( rangeStart, groupStart );
            var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
            var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
            if ( drawCount === 0 ) return; //
            if ( object.isMesh ) {
                if ( material.wireframe === true ) {
                    state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio( ) );
                    renderer.setMode( 1 );
                } else {
                    renderer.setMode( 4 );
                }
            } else if ( object.isLine ) {
                var lineWidth = material.linewidth;
                if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
                state.setLineWidth( lineWidth * getTargetPixelRatio( ) );
                if ( object.isLineSegments ) {
                    renderer.setMode( 1 );
                } else if ( object.isLineLoop ) {
                    renderer.setMode( 2 );
                } else {
                    renderer.setMode( 3 );
                }
            } else if ( object.isPoints ) {
                renderer.setMode( 0 );
            } else if ( object.isSprite ) {
                renderer.setMode( 4 );
            }
            if ( object.isInstancedMesh ) {
                renderer.renderInstances( drawStart, drawCount, object.count );
            } else if ( geometry.isInstancedBufferGeometry ) {
                var instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );
                renderer.renderInstances( drawStart, drawCount, instanceCount );
            } else {
                renderer.render( drawStart, drawCount );
            }
        }; // Compile
        this.compile = function( scene, camera ) {
            currentRenderState = renderStates.get( scene );
            currentRenderState.init( );
            renderStateStack.push( currentRenderState );
            scene.traverseVisible( function( object ) {
                if ( object.isLight && object.layers.test( camera.layers ) ) {
                    currentRenderState.pushLight( object );
                    if ( object.castShadow ) {
                        currentRenderState.pushShadow( object );
                    }
                }
            } );
            currentRenderState.setupLights( _this.physicallyCorrectLights );
            scene.traverse( function( object ) {
                var material = object.material;
                if ( material ) {
                    if ( Array.isArray( material ) ) {
                        for ( var _i154 = 0; _i154 < material.length; _i154++ ) {
                            var material2 = material[ _i154 ];
                            getProgram( material2, scene, object );
                        }
                    } else {
                        getProgram( material, scene, object );
                    }
                }
            } );
            renderStateStack.pop( );
            currentRenderState = null;
        }; // Animation Loop
        var onAnimationFrameCallback = null;

        function onAnimationFrame( time ) {
            if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
        }

        function onXRSessionStart( ) {
            animation.stop( );
        }

        function onXRSessionEnd( ) {
            animation.start( );
        }
        var animation = new WebGLAnimation( );
        animation.setAnimationLoop( onAnimationFrame );
        if ( typeof self !== 'undefined' ) animation.setContext( self );
        this.setAnimationLoop = function( callback ) {
            onAnimationFrameCallback = callback;
            xr.setAnimationLoop( callback );
            callback === null ? animation.stop( ) : animation.start( );
        };
        xr.addEventListener( 'sessionstart', onXRSessionStart );
        xr.addEventListener( 'sessionend', onXRSessionEnd ); // Rendering
        this.render = function( scene, camera ) {
            if ( camera !== undefined && camera.isCamera !== true ) {
                console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
                return;
            }
            if ( _isContextLost === true ) return; // update scene graph
            if ( scene.autoUpdate === true ) scene.updateMatrixWorld( ); // update camera matrices and frustum
            if ( camera.parent === null ) camera.updateMatrixWorld( );
            if ( xr.enabled === true && xr.isPresenting === true ) {
                if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );
                camera = xr.getCamera( ); // use XR camera for rendering
            } //
            if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );
            currentRenderState = renderStates.get( scene, renderStateStack.length );
            currentRenderState.init( );
            renderStateStack.push( currentRenderState );
            _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
            _frustum.setFromProjectionMatrix( _projScreenMatrix );
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
            currentRenderList = renderLists.get( scene, renderListStack.length );
            currentRenderList.init( );
            renderListStack.push( currentRenderList );
            projectObject( scene, camera, 0, _this.sortObjects );
            currentRenderList.finish( );
            if ( _this.sortObjects === true ) {
                currentRenderList.sort( _opaqueSort, _transparentSort );
            } //
            if ( _clippingEnabled === true ) clipping.beginShadows( );
            var shadowsArray = currentRenderState.state.shadowsArray;
            shadowMap.render( shadowsArray, scene, camera );
            if ( _clippingEnabled === true ) clipping.endShadows( ); //
            if ( this.info.autoReset === true ) this.info.reset( ); //
            background.render( currentRenderList, scene ); // render scene
            currentRenderState.setupLights( _this.physicallyCorrectLights );
            if ( camera.isArrayCamera ) {
                var cameras = camera.cameras;
                for ( var _i155 = 0, l = cameras.length; _i155 < l; _i155++ ) {
                    var camera2 = cameras[ _i155 ];
                    renderScene( currentRenderList, scene, camera2, camera2.viewport );
                }
            } else {
                renderScene( currentRenderList, scene, camera );
            } //
            if ( _currentRenderTarget !== null ) { // resolve multisample renderbuffers to a single-sample texture if necessary
                textures.updateMultisampleRenderTarget( _currentRenderTarget ); // Generate mipmap if we're using any kind of mipmap filtering
                textures.updateRenderTargetMipmap( _currentRenderTarget );
            } //
            if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera ); // _gl.finish();
            bindingStates.resetDefaultState( );
            _currentMaterialId = -1;
            _currentCamera = null;
            renderStateStack.pop( );
            if ( renderStateStack.length > 0 ) {
                currentRenderState = renderStateStack[ renderStateStack.length - 1 ];
            } else {
                currentRenderState = null;
            }
            renderListStack.pop( );
            if ( renderListStack.length > 0 ) {
                currentRenderList = renderListStack[ renderListStack.length - 1 ];
            } else {
                currentRenderList = null;
            }
        };

        function projectObject( object, camera, groupOrder, sortObjects ) {
            if ( object.visible === false ) return;
            var visible = object.layers.test( camera.layers );
            if ( visible ) {
                if ( object.isGroup ) {
                    groupOrder = object.renderOrder;
                } else if ( object.isLOD ) {
                    if ( object.autoUpdate === true ) object.update( camera );
                } else if ( object.isLight ) {
                    currentRenderState.pushLight( object );
                    if ( object.castShadow ) {
                        currentRenderState.pushShadow( object );
                    }
                } else if ( object.isSprite ) {
                    if ( !object.frustumCulled || _frustum.intersectsSprite( object ) ) {
                        if ( sortObjects ) {
                            _vector3.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );
                        }
                        var geometry = objects.update( object );
                        var material = object.material;
                        if ( material.visible ) {
                            currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );
                        }
                    }
                } else if ( object.isMesh || object.isLine || object.isPoints ) {
                    if ( object.isSkinnedMesh ) { // update skeleton only once in a frame
                        if ( object.skeleton.frame !== info.render.frame ) {
                            object.skeleton.update( );
                            object.skeleton.frame = info.render.frame;
                        }
                    }
                    if ( !object.frustumCulled || _frustum.intersectsObject( object ) ) {
                        if ( sortObjects ) {
                            _vector3.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );
                        }
                        var _geometry = objects.update( object );
                        var _material = object.material;
                        if ( Array.isArray( _material ) ) {
                            var groups = _geometry.groups;
                            for ( var _i156 = 0, l = groups.length; _i156 < l; _i156++ ) {
                                var group = groups[ _i156 ];
                                var groupMaterial = _material[ group.materialIndex ];
                                if ( groupMaterial && groupMaterial.visible ) {
                                    currentRenderList.push( object, _geometry, groupMaterial, groupOrder, _vector3.z, group );
                                }
                            }
                        } else if ( _material.visible ) {
                            currentRenderList.push( object, _geometry, _material, groupOrder, _vector3.z, null );
                        }
                    }
                }
            }
            var children = object.children;
            for ( var _i157 = 0, _l6 = children.length; _i157 < _l6; _i157++ ) {
                projectObject( children[ _i157 ], camera, groupOrder, sortObjects );
            }
        }

        function renderScene( currentRenderList, scene, camera, viewport ) {
            var opaqueObjects = currentRenderList.opaque;
            var transmissiveObjects = currentRenderList.transmissive;
            var transparentObjects = currentRenderList.transparent;
            currentRenderState.setupLightsView( camera );
            if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );
            if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );
            if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
            if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
            if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera ); // Ensure depth buffer writing is enabled so it can be cleared on next render
            state.buffers.depth.setTest( true );
            state.buffers.depth.setMask( true );
            state.buffers.color.setMask( true );
            state.setPolygonOffset( false );
        }

        function renderTransmissionPass( opaqueObjects, scene, camera ) {
            var isWebGL2 = capabilities.isWebGL2;
            if ( _transmissionRenderTarget === null ) {
                _transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
                    generateMipmaps: true,
                    type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
                    minFilter: LinearMipmapLinearFilter,
                    samples: isWebGL2 && _antialias === true ? 4 : 0
                } );
            }
            _this.getDrawingBufferSize( _vector2 );
            if ( isWebGL2 ) {
                _transmissionRenderTarget.setSize( _vector2.x, _vector2.y );
            } else {
                _transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );
            } //
            var currentRenderTarget = _this.getRenderTarget( );
            _this.setRenderTarget( _transmissionRenderTarget );
            _this.clear( ); // Turn off the features which can affect the frag color for opaque objects pass.
            // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
            var currentToneMapping = _this.toneMapping;
            _this.toneMapping = NoToneMapping;
            renderObjects( opaqueObjects, scene, camera );
            _this.toneMapping = currentToneMapping;
            textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
            textures.updateRenderTargetMipmap( _transmissionRenderTarget );
            _this.setRenderTarget( currentRenderTarget );
        }

        function renderObjects( renderList, scene, camera ) {
            var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
            for ( var _i158 = 0, l = renderList.length; _i158 < l; _i158++ ) {
                var renderItem = renderList[ _i158 ];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if ( object.layers.test( camera.layers ) ) {
                    renderObject( object, scene, camera, geometry, material, group );
                }
            }
        }

        function renderObject( object, scene, camera, geometry, material, group ) {
            object.onBeforeRender( _this, scene, camera, geometry, material, group );
            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
            material.onBeforeRender( _this, scene, camera, geometry, object, group );
            if ( material.transparent === true && material.side === DoubleSide ) {
                material.side = BackSide;
                material.needsUpdate = true;
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
                material.side = FrontSide;
                material.needsUpdate = true;
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
                material.side = DoubleSide;
            } else {
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
            }
            object.onAfterRender( _this, scene, camera, geometry, material, group );
        }

        function getProgram( material, scene, object ) {
            if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
            var materialProperties = properties.get( material );
            var lights = currentRenderState.state.lights;
            var shadowsArray = currentRenderState.state.shadowsArray;
            var lightsStateVersion = lights.state.version;
            var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
            var programCacheKey = programCache.getProgramCacheKey( parameters );
            var programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
            materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
            materialProperties.fog = scene.fog;
            materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
            if ( programs === undefined ) { // new material
                material.addEventListener( 'dispose', onMaterialDispose );
                programs = new Map( );
                materialProperties.programs = programs;
            }
            var program = programs.get( programCacheKey );
            if ( program !== undefined ) { // early out if program and light state is identical
                if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {
                    updateCommonMaterialProperties( material, parameters );
                    return program;
                }
            } else {
                parameters.uniforms = programCache.getUniforms( material );
                material.onBuild( object, parameters, _this );
                material.onBeforeCompile( parameters, _this );
                program = programCache.acquireProgram( parameters, programCacheKey );
                programs.set( programCacheKey, program );
                materialProperties.uniforms = parameters.uniforms;
            }
            var uniforms = materialProperties.uniforms;
            if ( !material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true ) {
                uniforms.clippingPlanes = clipping.uniform;
            }
            updateCommonMaterialProperties( material, parameters ); // store the light setup it was created for
            materialProperties.needsLights = materialNeedsLights( material );
            materialProperties.lightsStateVersion = lightsStateVersion;
            if ( materialProperties.needsLights ) { // wire up the material to this renderer's lighting state
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.lightProbe.value = lights.state.probe;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.spotLightShadows.value = lights.state.spotShadow;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.ltc_1.value = lights.state.rectAreaLTC1;
                uniforms.ltc_2.value = lights.state.rectAreaLTC2;
                uniforms.pointLights.value = lights.state.point;
                uniforms.pointLightShadows.value = lights.state.pointShadow;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
            }
            var progUniforms = program.getUniforms( );
            var uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
            materialProperties.currentProgram = program;
            materialProperties.uniformsList = uniformsList;
            return program;
        }

        function updateCommonMaterialProperties( material, parameters ) {
            var materialProperties = properties.get( material );
            materialProperties.outputEncoding = parameters.outputEncoding;
            materialProperties.instancing = parameters.instancing;
            materialProperties.skinning = parameters.skinning;
            materialProperties.morphTargets = parameters.morphTargets;
            materialProperties.morphNormals = parameters.morphNormals;
            materialProperties.morphColors = parameters.morphColors;
            materialProperties.morphTargetsCount = parameters.morphTargetsCount;
            materialProperties.numClippingPlanes = parameters.numClippingPlanes;
            materialProperties.numIntersection = parameters.numClipIntersection;
            materialProperties.vertexAlphas = parameters.vertexAlphas;
            materialProperties.vertexTangents = parameters.vertexTangents;
            materialProperties.toneMapping = parameters.toneMapping;
        }

        function setProgram( camera, scene, geometry, material, object ) {
            if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
            textures.resetTextureUnits( );
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
            var envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
            var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
            var vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
            var morphTargets = !!geometry.morphAttributes.position;
            var morphNormals = !!geometry.morphAttributes.normal;
            var morphColors = !!geometry.morphAttributes.color;
            var toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
            var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
            var materialProperties = properties.get( material );
            var lights = currentRenderState.state.lights;
            if ( _clippingEnabled === true ) {
                if ( _localClippingEnabled === true || camera !== _currentCamera ) {
                    var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    clipping.setState( material, camera, useCache );
                }
            } //
            var needsProgramChange = false;
            if ( material.version === materialProperties.__version ) {
                if ( materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version ) {
                    needsProgramChange = true;
                } else if ( materialProperties.outputEncoding !== encoding ) {
                    needsProgramChange = true;
                } else if ( object.isInstancedMesh && materialProperties.instancing === false ) {
                    needsProgramChange = true;
                } else if ( !object.isInstancedMesh && materialProperties.instancing === true ) {
                    needsProgramChange = true;
                } else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {
                    needsProgramChange = true;
                } else if ( !object.isSkinnedMesh && materialProperties.skinning === true ) {
                    needsProgramChange = true;
                } else if ( materialProperties.envMap !== envMap ) {
                    needsProgramChange = true;
                } else if ( material.fog === true && materialProperties.fog !== fog ) {
                    needsProgramChange = true;
                } else if ( materialProperties.numClippingPlanes !== undefined && ( materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection ) ) {
                    needsProgramChange = true;
                } else if ( materialProperties.vertexAlphas !== vertexAlphas ) {
                    needsProgramChange = true;
                } else if ( materialProperties.vertexTangents !== vertexTangents ) {
                    needsProgramChange = true;
                } else if ( materialProperties.morphTargets !== morphTargets ) {
                    needsProgramChange = true;
                } else if ( materialProperties.morphNormals !== morphNormals ) {
                    needsProgramChange = true;
                } else if ( materialProperties.morphColors !== morphColors ) {
                    needsProgramChange = true;
                } else if ( materialProperties.toneMapping !== toneMapping ) {
                    needsProgramChange = true;
                } else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {
                    needsProgramChange = true;
                }
            } else {
                needsProgramChange = true;
                materialProperties.__version = material.version;
            } //
            var program = materialProperties.currentProgram;
            if ( needsProgramChange === true ) {
                program = getProgram( material, scene, object );
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var p_uniforms = program.getUniforms( ),
                m_uniforms = materialProperties.uniforms;
            if ( state.useProgram( program.program ) ) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if ( material.id !== _currentMaterialId ) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if ( refreshProgram || _currentCamera !== camera ) {
                p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
                if ( capabilities.logarithmicDepthBuffer ) {
                    p_uniforms.setValue( _gl, 'logDepthBufFC', 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
                }
                if ( _currentCamera !== camera ) {
                    _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:
                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                } // load material specific uniforms
                // (shader material also gets them for the sake of genericity)
                if ( material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap ) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if ( uCamPos !== undefined ) {
                        uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );
                    }
                }
                if ( material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial ) {
                    p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );
                }
                if ( material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh ) {
                    p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
                }
            } // skinning and morph target uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone and morph texture must go before other textures
            // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
            if ( object.isSkinnedMesh ) {
                p_uniforms.setOptional( _gl, object, 'bindMatrix' );
                p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
                var skeleton = object.skeleton;
                if ( skeleton ) {
                    if ( capabilities.floatVertexTextures ) {
                        if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture( );
                        p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
                        p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
                    } else {
                        console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );
                    }
                }
            }
            var morphAttributes = geometry.morphAttributes;
            if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) {
                morphtargets.update( object, geometry, material, program );
            }
            if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {
                materialProperties.receiveShadow = object.receiveShadow;
                p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );
            }
            if ( refreshMaterial ) {
                p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
                if ( materialProperties.needsLights ) { // the current material requires lighting info
                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required
                    markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
                } // refresh uniforms common to several materials
                if ( fog && material.fog === true ) {
                    materials.refreshFogUniforms( m_uniforms, fog );
                }
                materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );
                WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
            }
            if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {
                WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
                material.uniformsNeedUpdate = false;
            }
            if ( material.isSpriteMaterial ) {
                p_uniforms.setValue( _gl, 'center', object.center );
            } // common matrices
            p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
            p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
            p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
            return program;
        } // If uniforms are marked as clean, they don't need to be loaded to the GPU.
        function markUniformsLightsNeedsUpdate( uniforms, value ) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.lightProbe.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.directionalLightShadows.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.pointLightShadows.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.spotLightShadows.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }

        function materialNeedsLights( material ) {
            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        }
        this.getActiveCubeFace = function( ) {
            return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function( ) {
            return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function( ) {
            return _currentRenderTarget;
        };
        this.setRenderTargetTextures = function( renderTarget, colorTexture, depthTexture ) {
            properties.get( renderTarget.texture ).__webglTexture = colorTexture;
            properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;
            var renderTargetProperties = properties.get( renderTarget );
            renderTargetProperties.__hasExternalTextures = true;
            if ( renderTargetProperties.__hasExternalTextures ) {
                renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
                if ( !renderTargetProperties.__autoAllocateDepthBuffer ) { // The multisample_render_to_texture extension doesn't work properly if there
                    // are midframe flushes and an external depth buffer. Disable use of the extension.
                    if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {
                        console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
                        renderTargetProperties.__useRenderToTexture = false;
                    }
                }
            }
        };
        this.setRenderTargetFramebuffer = function( renderTarget, defaultFramebuffer ) {
            var renderTargetProperties = properties.get( renderTarget );
            renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
            renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
        };
        this.setRenderTarget = function( renderTarget ) {
            var activeCubeFace = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var activeMipmapLevel = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            _currentRenderTarget = renderTarget;
            _currentActiveCubeFace = activeCubeFace;
            _currentActiveMipmapLevel = activeMipmapLevel;
            var useDefaultFramebuffer = true;
            if ( renderTarget ) {
                var renderTargetProperties = properties.get( renderTarget );
                if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) { // We need to make sure to rebind the framebuffer.
                    state.bindFramebuffer( 36160, null );
                    useDefaultFramebuffer = false;
                } else if ( renderTargetProperties.__webglFramebuffer === undefined ) {
                    textures.setupRenderTarget( renderTarget );
                } else if ( renderTargetProperties.__hasExternalTextures ) { // Color and depth texture must be rebound in order for the swapchain to update.
                    textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );
                }
            }
            var framebuffer = null;
            var isCube = false;
            var isRenderTarget3D = false;
            if ( renderTarget ) {
                var texture = renderTarget.texture;
                if ( texture.isData3DTexture || texture.isDataArrayTexture ) {
                    isRenderTarget3D = true;
                }
                var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;
                if ( renderTarget.isWebGLCubeRenderTarget ) {
                    framebuffer = __webglFramebuffer[ activeCubeFace ];
                    isCube = true;
                } else if ( capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT( renderTarget ) === false ) {
                    framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;
                } else {
                    framebuffer = __webglFramebuffer;
                }
                _currentViewport.copy( renderTarget.viewport );
                _currentScissor.copy( renderTarget.scissor );
                _currentScissorTest = renderTarget.scissorTest;
            } else {
                _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor( );
                _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor( );
                _currentScissorTest = _scissorTest;
            }
            var framebufferBound = state.bindFramebuffer( 36160, framebuffer );
            if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {
                state.drawBuffers( renderTarget, framebuffer );
            }
            state.viewport( _currentViewport );
            state.scissor( _currentScissor );
            state.setScissorTest( _currentScissorTest );
            if ( isCube ) {
                var textureProperties = properties.get( renderTarget.texture );
                _gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );
            } else if ( isRenderTarget3D ) {
                var _textureProperties = properties.get( renderTarget.texture );
                var layer = activeCubeFace || 0;
                _gl.framebufferTextureLayer( 36160, 36064, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer );
            }
            _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
        };
        this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {
            if ( !( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
                return;
            }
            var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
            if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {
                framebuffer = framebuffer[ activeCubeFaceIndex ];
            }
            if ( framebuffer ) {
                state.bindFramebuffer( 36160, framebuffer );
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {
                        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
                        return;
                    }
                    var halfFloatSupportedByExt = textureType === HalfFloatType && ( extensions.has( 'EXT_color_buffer_half_float' ) || capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) );
                    if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
                        !( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
                        !halfFloatSupportedByExt ) {
                        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
                        return;
                    } // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                    if ( x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height ) {
                        _gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );
                    }
                } finally { // restore framebuffer of current render target if necessary
                    var _framebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
                    state.bindFramebuffer( 36160, _framebuffer );
                }
            }
        };
        this.copyFramebufferToTexture = function( position, texture ) {
            var level = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var levelScale = Math.pow( 2, -level );
            var width = Math.floor( texture.image.width * levelScale );
            var height = Math.floor( texture.image.height * levelScale );
            textures.setTexture2D( texture, 0 );
            _gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );
            state.unbindTexture( );
        };
        this.copyTextureToTexture = function( position, srcTexture, dstTexture ) {
            var level = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 0;
            var width = srcTexture.image.width;
            var height = srcTexture.image.height;
            var glFormat = utils.convert( dstTexture.format );
            var glType = utils.convert( dstTexture.type );
            textures.setTexture2D( dstTexture, 0 ); // As another texture upload may have changed pixelStorei
            // parameters, make sure they are correct for the dstTexture
            _gl.pixelStorei( 37440, dstTexture.flipY );
            _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
            _gl.pixelStorei( 3317, dstTexture.unpackAlignment );
            if ( srcTexture.isDataTexture ) {
                _gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );
            } else {
                if ( srcTexture.isCompressedTexture ) {
                    _gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );
                } else {
                    _gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );
                }
            } // Generate mipmaps only when copying level 0
            if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );
            state.unbindTexture( );
        };
        this.copyTextureToTexture3D = function( sourceBox, position, srcTexture, dstTexture ) {
            var level = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : 0;
            if ( _this.isWebGL1Renderer ) {
                console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
                return;
            }
            var width = sourceBox.max.x - sourceBox.min.x + 1;
            var height = sourceBox.max.y - sourceBox.min.y + 1;
            var depth = sourceBox.max.z - sourceBox.min.z + 1;
            var glFormat = utils.convert( dstTexture.format );
            var glType = utils.convert( dstTexture.type );
            var glTarget;
            if ( dstTexture.isData3DTexture ) {
                textures.setTexture3D( dstTexture, 0 );
                glTarget = 32879;
            } else if ( dstTexture.isDataArrayTexture ) {
                textures.setTexture2DArray( dstTexture, 0 );
                glTarget = 35866;
            } else {
                console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
                return;
            }
            _gl.pixelStorei( 37440, dstTexture.flipY );
            _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
            _gl.pixelStorei( 3317, dstTexture.unpackAlignment );
            var unpackRowLen = _gl.getParameter( 3314 );
            var unpackImageHeight = _gl.getParameter( 32878 );
            var unpackSkipPixels = _gl.getParameter( 3316 );
            var unpackSkipRows = _gl.getParameter( 3315 );
            var unpackSkipImages = _gl.getParameter( 32877 );
            var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;
            _gl.pixelStorei( 3314, image.width );
            _gl.pixelStorei( 32878, image.height );
            _gl.pixelStorei( 3316, sourceBox.min.x );
            _gl.pixelStorei( 3315, sourceBox.min.y );
            _gl.pixelStorei( 32877, sourceBox.min.z );
            if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {
                _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );
            } else {
                if ( srcTexture.isCompressedTexture ) {
                    console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
                    _gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );
                } else {
                    _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );
                }
            }
            _gl.pixelStorei( 3314, unpackRowLen );
            _gl.pixelStorei( 32878, unpackImageHeight );
            _gl.pixelStorei( 3316, unpackSkipPixels );
            _gl.pixelStorei( 3315, unpackSkipRows );
            _gl.pixelStorei( 32877, unpackSkipImages ); // Generate mipmaps only when copying level 0
            if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );
            state.unbindTexture( );
        };
        this.initTexture = function( texture ) {
            if ( texture.isCubeTexture ) {
                textures.setTextureCube( texture, 0 );
            } else if ( texture.isData3DTexture ) {
                textures.setTexture3D( texture, 0 );
            } else if ( texture.isDataArrayTexture ) {
                textures.setTexture2DArray( texture, 0 );
            } else {
                textures.setTexture2D( texture, 0 );
            }
            state.unbindTexture( );
        };
        this.resetState = function( ) {
            _currentActiveCubeFace = 0;
            _currentActiveMipmapLevel = 0;
            _currentRenderTarget = null;
            state.reset( );
            bindingStates.reset( );
        };
        if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
            __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', {
                detail: this
            } ) );
        }
    }
    var WebGL1Renderer = /*#__PURE__*/ function( _WebGLRenderer ) {
        _inherits( WebGL1Renderer, _WebGLRenderer );
        var _super28 = _createSuper( WebGL1Renderer );

        function WebGL1Renderer( ) {
            _classCallCheck( this, WebGL1Renderer );
            return _super28.apply( this, arguments );
        }
        return _createClass( WebGL1Renderer );
    }( WebGLRenderer );
    WebGL1Renderer.prototype.isWebGL1Renderer = true;
    var Scene = /*#__PURE__*/ function( _Object3D5 ) {
        _inherits( Scene, _Object3D5 );
        var _super29 = _createSuper( Scene );

        function Scene( ) {
            var _this26;
            _classCallCheck( this, Scene );
            _this26 = _super29.call( this );
            _this26.isScene = true;
            _this26.type = 'Scene';
            _this26.background = null;
            _this26.environment = null;
            _this26.fog = null;
            _this26.overrideMaterial = null;
            _this26.autoUpdate = true; // checked by the renderer
            if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
                __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', {
                    detail: _assertThisInitialized( _this26 )
                } ) );
            }
            return _this26;
        }
        _createClass( Scene, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Scene.prototype ), "copy", this ).call( this, source, recursive );
                if ( source.background !== null ) this.background = source.background.clone( );
                if ( source.environment !== null ) this.environment = source.environment.clone( );
                if ( source.fog !== null ) this.fog = source.fog.clone( );
                if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone( );
                this.autoUpdate = source.autoUpdate;
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var data = _get( _getPrototypeOf( Scene.prototype ), "toJSON", this ).call( this, meta );
                if ( this.fog !== null ) data.object.fog = this.fog.toJSON( );
                return data;
            }
        } ] );
        return Scene;
    }( Object3D );
    var InterleavedBuffer = /*#__PURE__*/ function( ) {
        function InterleavedBuffer( array, stride ) {
            _classCallCheck( this, InterleavedBuffer );
            this.isInterleavedBuffer = true;
            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;
            this.usage = StaticDrawUsage;
            this.updateRange = {
                offset: 0,
                count: -1
            };
            this.version = 0;
            this.uuid = generateUUID( );
        }
        _createClass( InterleavedBuffer, [ {
            key: "onUploadCallback",
            value: function onUploadCallback( ) {}
        }, {
            key: "needsUpdate",
            set: function set( value ) {
                if ( value === true ) this.version++;
            }
        }, {
            key: "setUsage",
            value: function setUsage( value ) {
                this.usage = value;
                return this;
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.array = new source.array.constructor( source.array );
                this.count = source.count;
                this.stride = source.stride;
                this.usage = source.usage;
                return this;
            }
        }, {
            key: "copyAt",
            value: function copyAt( index1, attribute, index2 ) {
                index1 *= this.stride;
                index2 *= attribute.stride;
                for ( var _i159 = 0, l = this.stride; _i159 < l; _i159++ ) {
                    this.array[ index1 + _i159 ] = attribute.array[ index2 + _i159 ];
                }
                return this;
            }
        }, {
            key: "set",
            value: function set( value ) {
                var offset = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                this.array.set( value, offset );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( data ) {
                if ( data.arrayBuffers === undefined ) {
                    data.arrayBuffers = {};
                }
                if ( this.array.buffer._uuid === undefined ) {
                    this.array.buffer._uuid = generateUUID( );
                }
                if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {
                    data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;
                }
                var array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );
                var ib = new this.constructor( array, this.stride );
                ib.setUsage( this.usage );
                return ib;
            }
        }, {
            key: "onUpload",
            value: function onUpload( callback ) {
                this.onUploadCallback = callback;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( data ) {
                if ( data.arrayBuffers === undefined ) {
                    data.arrayBuffers = {};
                } // generate UUID for array buffer if necessary
                if ( this.array.buffer._uuid === undefined ) {
                    this.array.buffer._uuid = generateUUID( );
                }
                if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {
                    data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );
                } //
                return {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                };
            }
        } ] );
        return InterleavedBuffer;
    }( );
    var _vector$6 = /*@__PURE__*/ new Vector3( );
    var InterleavedBufferAttribute = /*#__PURE__*/ function( ) {
        function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset ) {
            var normalized = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : false;
            _classCallCheck( this, InterleavedBufferAttribute );
            this.isInterleavedBufferAttribute = true;
            this.name = '';
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized === true;
        }
        _createClass( InterleavedBufferAttribute, [ {
            key: "count",
            get: function get( ) {
                return this.data.count;
            }
        }, {
            key: "array",
            get: function get( ) {
                return this.data.array;
            }
        }, {
            key: "needsUpdate",
            set: function set( value ) {
                this.data.needsUpdate = value;
            }
        }, {
            key: "applyMatrix4",
            value: function applyMatrix4( m ) {
                for ( var _i160 = 0, l = this.data.count; _i160 < l; _i160++ ) {
                    _vector$6.fromBufferAttribute( this, _i160 );
                    _vector$6.applyMatrix4( m );
                    this.setXYZ( _i160, _vector$6.x, _vector$6.y, _vector$6.z );
                }
                return this;
            }
        }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix( m ) {
                for ( var _i161 = 0, l = this.count; _i161 < l; _i161++ ) {
                    _vector$6.fromBufferAttribute( this, _i161 );
                    _vector$6.applyNormalMatrix( m );
                    this.setXYZ( _i161, _vector$6.x, _vector$6.y, _vector$6.z );
                }
                return this;
            }
        }, {
            key: "transformDirection",
            value: function transformDirection( m ) {
                for ( var _i162 = 0, l = this.count; _i162 < l; _i162++ ) {
                    _vector$6.fromBufferAttribute( this, _i162 );
                    _vector$6.transformDirection( m );
                    this.setXYZ( _i162, _vector$6.x, _vector$6.y, _vector$6.z );
                }
                return this;
            }
        }, {
            key: "setX",
            value: function setX( index, x ) {
                this.data.array[ index * this.data.stride + this.offset ] = x;
                return this;
            }
        }, {
            key: "setY",
            value: function setY( index, y ) {
                this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
                return this;
            }
        }, {
            key: "setZ",
            value: function setZ( index, z ) {
                this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
                return this;
            }
        }, {
            key: "setW",
            value: function setW( index, w ) {
                this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
                return this;
            }
        }, {
            key: "getX",
            value: function getX( index ) {
                return this.data.array[ index * this.data.stride + this.offset ];
            }
        }, {
            key: "getY",
            value: function getY( index ) {
                return this.data.array[ index * this.data.stride + this.offset + 1 ];
            }
        }, {
            key: "getZ",
            value: function getZ( index ) {
                return this.data.array[ index * this.data.stride + this.offset + 2 ];
            }
        }, {
            key: "getW",
            value: function getW( index ) {
                return this.data.array[ index * this.data.stride + this.offset + 3 ];
            }
        }, {
            key: "setXY",
            value: function setXY( index, x, y ) {
                index = index * this.data.stride + this.offset;
                this.data.array[ index + 0 ] = x;
                this.data.array[ index + 1 ] = y;
                return this;
            }
        }, {
            key: "setXYZ",
            value: function setXYZ( index, x, y, z ) {
                index = index * this.data.stride + this.offset;
                this.data.array[ index + 0 ] = x;
                this.data.array[ index + 1 ] = y;
                this.data.array[ index + 2 ] = z;
                return this;
            }
        }, {
            key: "setXYZW",
            value: function setXYZW( index, x, y, z, w ) {
                index = index * this.data.stride + this.offset;
                this.data.array[ index + 0 ] = x;
                this.data.array[ index + 1 ] = y;
                this.data.array[ index + 2 ] = z;
                this.data.array[ index + 3 ] = w;
                return this;
            }
        }, {
            key: "clone",
            value: function clone( data ) {
                if ( data === undefined ) {
                    console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.' );
                    var array = [ ];
                    for ( var _i163 = 0; _i163 < this.count; _i163++ ) {
                        var index = _i163 * this.data.stride + this.offset;
                        for ( var j = 0; j < this.itemSize; j++ ) {
                            array.push( this.data.array[ index + j ] );
                        }
                    }
                    return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );
                } else {
                    if ( data.interleavedBuffers === undefined ) {
                        data.interleavedBuffers = {};
                    }
                    if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {
                        data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );
                    }
                    return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );
                }
            }
        }, {
            key: "toJSON",
            value: function toJSON( data ) {
                if ( data === undefined ) {
                    console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.' );
                    var array = [ ];
                    for ( var _i164 = 0; _i164 < this.count; _i164++ ) {
                        var index = _i164 * this.data.stride + this.offset;
                        for ( var j = 0; j < this.itemSize; j++ ) {
                            array.push( this.data.array[ index + j ] );
                        }
                    } // deinterleave data and save it as an ordinary buffer attribute for now
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: array,
                        normalized: this.normalized
                    };
                } else { // save as true interleaved attribtue
                    if ( data.interleavedBuffers === undefined ) {
                        data.interleavedBuffers = {};
                    }
                    if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {
                        data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );
                    }
                    return {
                        isInterleavedBufferAttribute: true,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    };
                }
            }
        } ] );
        return InterleavedBufferAttribute;
    }( );
    var _basePosition = /*@__PURE__*/ new Vector3( );
    var _skinIndex = /*@__PURE__*/ new Vector4( );
    var _skinWeight = /*@__PURE__*/ new Vector4( );
    var _vector$5 = /*@__PURE__*/ new Vector3( );
    var _matrix = /*@__PURE__*/ new Matrix4( );
    var SkinnedMesh = /*#__PURE__*/ function( _Mesh ) {
        _inherits( SkinnedMesh, _Mesh );
        var _super30 = _createSuper( SkinnedMesh );

        function SkinnedMesh( geometry, material ) {
            var _this27;
            _classCallCheck( this, SkinnedMesh );
            _this27 = _super30.call( this, geometry, material );
            _this27.isSkinnedMesh = true;
            _this27.type = 'SkinnedMesh';
            _this27.bindMode = 'attached';
            _this27.bindMatrix = new Matrix4( );
            _this27.bindMatrixInverse = new Matrix4( );
            return _this27;
        }
        _createClass( SkinnedMesh, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( SkinnedMesh.prototype ), "copy", this ).call( this, source, recursive );
                this.bindMode = source.bindMode;
                this.bindMatrix.copy( source.bindMatrix );
                this.bindMatrixInverse.copy( source.bindMatrixInverse );
                this.skeleton = source.skeleton;
                return this;
            }
        }, {
            key: "bind",
            value: function bind( skeleton, bindMatrix ) {
                this.skeleton = skeleton;
                if ( bindMatrix === undefined ) {
                    this.updateMatrixWorld( true );
                    this.skeleton.calculateInverses( );
                    bindMatrix = this.matrixWorld;
                }
                this.bindMatrix.copy( bindMatrix );
                this.bindMatrixInverse.copy( bindMatrix ).invert( );
            }
        }, {
            key: "pose",
            value: function pose( ) {
                this.skeleton.pose( );
            }
        }, {
            key: "normalizeSkinWeights",
            value: function normalizeSkinWeights( ) {
                var vector = new Vector4( );
                var skinWeight = this.geometry.attributes.skinWeight;
                for ( var _i165 = 0, l = skinWeight.count; _i165 < l; _i165++ ) {
                    vector.fromBufferAttribute( skinWeight, _i165 );
                    var scale = 1.0 / vector.manhattanLength( );
                    if ( scale !== Infinity ) {
                        vector.multiplyScalar( scale );
                    } else {
                        vector.set( 1, 0, 0, 0 ); // do something reasonable
                    }
                    skinWeight.setXYZW( _i165, vector.x, vector.y, vector.z, vector.w );
                }
            }
        }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld( force ) {
                _get( _getPrototypeOf( SkinnedMesh.prototype ), "updateMatrixWorld", this ).call( this, force );
                if ( this.bindMode === 'attached' ) {
                    this.bindMatrixInverse.copy( this.matrixWorld ).invert( );
                } else if ( this.bindMode === 'detached' ) {
                    this.bindMatrixInverse.copy( this.bindMatrix ).invert( );
                } else {
                    console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
                }
            }
        }, {
            key: "boneTransform",
            value: function boneTransform( index, target ) {
                var skeleton = this.skeleton;
                var geometry = this.geometry;
                _skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
                _skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );
                _basePosition.copy( target ).applyMatrix4( this.bindMatrix );
                target.set( 0, 0, 0 );
                for ( var _i166 = 0; _i166 < 4; _i166++ ) {
                    var weight = _skinWeight.getComponent( _i166 );
                    if ( weight !== 0 ) {
                        var boneIndex = _skinIndex.getComponent( _i166 );
                        _matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );
                        target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );
                    }
                }
                return target.applyMatrix4( this.bindMatrixInverse );
            }
        } ] );
        return SkinnedMesh;
    }( Mesh );
    var Bone = /*#__PURE__*/ function( _Object3D6 ) {
        _inherits( Bone, _Object3D6 );
        var _super31 = _createSuper( Bone );

        function Bone( ) {
            var _this28;
            _classCallCheck( this, Bone );
            _this28 = _super31.call( this );
            _this28.isBone = true;
            _this28.type = 'Bone';
            return _this28;
        }
        return _createClass( Bone );
    }( Object3D );
    var DataTexture = /*#__PURE__*/ function( _Texture5 ) {
        _inherits( DataTexture, _Texture5 );
        var _super32 = _createSuper( DataTexture );

        function DataTexture( ) {
            var _this29;
            var data = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : null;
            var width = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            var height = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1;
            var format = arguments.length > 3 ? arguments[ 3 ] : undefined;
            var type = arguments.length > 4 ? arguments[ 4 ] : undefined;
            var mapping = arguments.length > 5 ? arguments[ 5 ] : undefined;
            var wrapS = arguments.length > 6 ? arguments[ 6 ] : undefined;
            var wrapT = arguments.length > 7 ? arguments[ 7 ] : undefined;
            var magFilter = arguments.length > 8 && arguments[ 8 ] !== undefined ? arguments[ 8 ] : NearestFilter;
            var minFilter = arguments.length > 9 && arguments[ 9 ] !== undefined ? arguments[ 9 ] : NearestFilter;
            var anisotropy = arguments.length > 10 ? arguments[ 10 ] : undefined;
            var encoding = arguments.length > 11 ? arguments[ 11 ] : undefined;
            _classCallCheck( this, DataTexture );
            _this29 = _super32.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
            _this29.isDataTexture = true;
            _this29.image = {
                data: data,
                width: width,
                height: height
            };
            _this29.generateMipmaps = false;
            _this29.flipY = false;
            _this29.unpackAlignment = 1;
            return _this29;
        }
        return _createClass( DataTexture );
    }( Texture );
    var _offsetMatrix = /*@__PURE__*/ new Matrix4( );
    var _identityMatrix = /*@__PURE__*/ new Matrix4( );
    var Skeleton = /*#__PURE__*/ function( ) {
        function Skeleton( ) {
            var bones = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
            var boneInverses = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : [ ];
            _classCallCheck( this, Skeleton );
            this.uuid = generateUUID( );
            this.bones = bones.slice( 0 );
            this.boneInverses = boneInverses;
            this.boneMatrices = null;
            this.boneTexture = null;
            this.boneTextureSize = 0;
            this.frame = -1;
            this.init( );
        }
        _createClass( Skeleton, [ {
            key: "init",
            value: function init( ) {
                var bones = this.bones;
                var boneInverses = this.boneInverses;
                this.boneMatrices = new Float32Array( bones.length * 16 ); // calculate inverse bone matrices if necessary
                if ( boneInverses.length === 0 ) {
                    this.calculateInverses( );
                } else { // handle special case
                    if ( bones.length !== boneInverses.length ) {
                        console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );
                        this.boneInverses = [ ];
                        for ( var _i167 = 0, il = this.bones.length; _i167 < il; _i167++ ) {
                            this.boneInverses.push( new Matrix4( ) );
                        }
                    }
                }
            }
        }, {
            key: "calculateInverses",
            value: function calculateInverses( ) {
                this.boneInverses.length = 0;
                for ( var _i168 = 0, il = this.bones.length; _i168 < il; _i168++ ) {
                    var inverse = new Matrix4( );
                    if ( this.bones[ _i168 ] ) {
                        inverse.copy( this.bones[ _i168 ].matrixWorld ).invert( );
                    }
                    this.boneInverses.push( inverse );
                }
            }
        }, {
            key: "pose",
            value: function pose( ) { // recover the bind-time world matrices
                for ( var _i169 = 0, il = this.bones.length; _i169 < il; _i169++ ) {
                    var bone = this.bones[ _i169 ];
                    if ( bone ) {
                        bone.matrixWorld.copy( this.boneInverses[ _i169 ] ).invert( );
                    }
                } // compute the local matrices, positions, rotations and scales
                for ( var _i170 = 0, _il12 = this.bones.length; _i170 < _il12; _i170++ ) {
                    var _bone = this.bones[ _i170 ];
                    if ( _bone ) {
                        if ( _bone.parent && _bone.parent.isBone ) {
                            _bone.matrix.copy( _bone.parent.matrixWorld ).invert( );
                            _bone.matrix.multiply( _bone.matrixWorld );
                        } else {
                            _bone.matrix.copy( _bone.matrixWorld );
                        }
                        _bone.matrix.decompose( _bone.position, _bone.quaternion, _bone.scale );
                    }
                }
            }
        }, {
            key: "update",
            value: function update( ) {
                var bones = this.bones;
                var boneInverses = this.boneInverses;
                var boneMatrices = this.boneMatrices;
                var boneTexture = this.boneTexture; // flatten bone matrices to array
                for ( var _i171 = 0, il = bones.length; _i171 < il; _i171++ ) { // compute the offset between the current and the original transform
                    var matrix = bones[ _i171 ] ? bones[ _i171 ].matrixWorld : _identityMatrix;
                    _offsetMatrix.multiplyMatrices( matrix, boneInverses[ _i171 ] );
                    _offsetMatrix.toArray( boneMatrices, _i171 * 16 );
                }
                if ( boneTexture !== null ) {
                    boneTexture.needsUpdate = true;
                }
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new Skeleton( this.bones, this.boneInverses );
            }
        }, {
            key: "computeBoneTexture",
            value: function computeBoneTexture( ) { // layout (1 matrix = 4 pixels)
                //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
                size = ceilPowerOfTwo( size );
                size = Math.max( size, 4 );
                var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
                boneMatrices.set( this.boneMatrices ); // copy current values
                var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
                boneTexture.needsUpdate = true;
                this.boneMatrices = boneMatrices;
                this.boneTexture = boneTexture;
                this.boneTextureSize = size;
                return this;
            }
        }, {
            key: "getBoneByName",
            value: function getBoneByName( name ) {
                for ( var _i172 = 0, il = this.bones.length; _i172 < il; _i172++ ) {
                    var bone = this.bones[ _i172 ];
                    if ( bone.name === name ) {
                        return bone;
                    }
                }
                return undefined;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                if ( this.boneTexture !== null ) {
                    this.boneTexture.dispose( );
                    this.boneTexture = null;
                }
            }
        }, {
            key: "fromJSON",
            value: function fromJSON( json, bones ) {
                this.uuid = json.uuid;
                for ( var _i173 = 0, l = json.bones.length; _i173 < l; _i173++ ) {
                    var uuid = json.bones[ _i173 ];
                    var bone = bones[ uuid ];
                    if ( bone === undefined ) {
                        console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
                        bone = new Bone( );
                    }
                    this.bones.push( bone );
                    this.boneInverses.push( new Matrix4( ).fromArray( json.boneInverses[ _i173 ] ) );
                }
                this.init( );
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Skeleton',
                        generator: 'Skeleton.toJSON'
                    },
                    bones: [ ],
                    boneInverses: [ ]
                };
                data.uuid = this.uuid;
                var bones = this.bones;
                var boneInverses = this.boneInverses;
                for ( var _i174 = 0, l = bones.length; _i174 < l; _i174++ ) {
                    var bone = bones[ _i174 ];
                    data.bones.push( bone.uuid );
                    var boneInverse = boneInverses[ _i174 ];
                    data.boneInverses.push( boneInverse.toArray( ) );
                }
                return data;
            }
        } ] );
        return Skeleton;
    }( );
    var InstancedBufferAttribute = /*#__PURE__*/ function( _BufferAttribute4 ) {
        _inherits( InstancedBufferAttribute, _BufferAttribute4 );
        var _super33 = _createSuper( InstancedBufferAttribute );

        function InstancedBufferAttribute( array, itemSize, normalized ) {
            var _this30;
            var meshPerAttribute = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, InstancedBufferAttribute );
            if ( typeof normalized === 'number' ) {
                meshPerAttribute = normalized;
                normalized = false;
                console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );
            }
            _this30 = _super33.call( this, array, itemSize, normalized );
            _this30.isInstancedBufferAttribute = true;
            _this30.meshPerAttribute = meshPerAttribute;
            return _this30;
        }
        _createClass( InstancedBufferAttribute, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( InstancedBufferAttribute.prototype ), "copy", this ).call( this, source );
                this.meshPerAttribute = source.meshPerAttribute;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = _get( _getPrototypeOf( InstancedBufferAttribute.prototype ), "toJSON", this ).call( this );
                data.meshPerAttribute = this.meshPerAttribute;
                data.isInstancedBufferAttribute = true;
                return data;
            }
        } ] );
        return InstancedBufferAttribute;
    }( BufferAttribute );
    var _instanceLocalMatrix = /*@__PURE__*/ new Matrix4( );
    var _instanceWorldMatrix = /*@__PURE__*/ new Matrix4( );
    var _instanceIntersects = [ ];
    var _mesh = /*@__PURE__*/ new Mesh( );
    var InstancedMesh = /*#__PURE__*/ function( _Mesh2 ) {
        _inherits( InstancedMesh, _Mesh2 );
        var _super34 = _createSuper( InstancedMesh );

        function InstancedMesh( geometry, material, count ) {
            var _this31;
            _classCallCheck( this, InstancedMesh );
            _this31 = _super34.call( this, geometry, material );
            _this31.isInstancedMesh = true;
            _this31.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
            _this31.instanceColor = null;
            _this31.count = count;
            _this31.frustumCulled = false;
            return _this31;
        }
        _createClass( InstancedMesh, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( InstancedMesh.prototype ), "copy", this ).call( this, source, recursive );
                this.instanceMatrix.copy( source.instanceMatrix );
                if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone( );
                this.count = source.count;
                return this;
            }
        }, {
            key: "getColorAt",
            value: function getColorAt( index, color ) {
                color.fromArray( this.instanceColor.array, index * 3 );
            }
        }, {
            key: "getMatrixAt",
            value: function getMatrixAt( index, matrix ) {
                matrix.fromArray( this.instanceMatrix.array, index * 16 );
            }
        }, {
            key: "raycast",
            value: function raycast( raycaster, intersects ) {
                var matrixWorld = this.matrixWorld;
                var raycastTimes = this.count;
                _mesh.geometry = this.geometry;
                _mesh.material = this.material;
                if ( _mesh.material === undefined ) return;
                for ( var instanceId = 0; instanceId < raycastTimes; instanceId++ ) { // calculate the world matrix for each instance
                    this.getMatrixAt( instanceId, _instanceLocalMatrix );
                    _instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix ); // the mesh represents this single instance
                    _mesh.matrixWorld = _instanceWorldMatrix;
                    _mesh.raycast( raycaster, _instanceIntersects ); // process the result of raycast
                    for ( var _i175 = 0, l = _instanceIntersects.length; _i175 < l; _i175++ ) {
                        var _intersect = _instanceIntersects[ _i175 ];
                        _intersect.instanceId = instanceId;
                        _intersect.object = this;
                        intersects.push( _intersect );
                    }
                    _instanceIntersects.length = 0;
                }
            }
        }, {
            key: "setColorAt",
            value: function setColorAt( index, color ) {
                if ( this.instanceColor === null ) {
                    this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );
                }
                color.toArray( this.instanceColor.array, index * 3 );
            }
        }, {
            key: "setMatrixAt",
            value: function setMatrixAt( index, matrix ) {
                matrix.toArray( this.instanceMatrix.array, index * 16 );
            }
        }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets( ) {}
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.dispatchEvent( {
                    type: 'dispose'
                } );
            }
        } ] );
        return InstancedMesh;
    }( Mesh );
    var LineBasicMaterial = /*#__PURE__*/ function( _Material$5 ) {
        _inherits( LineBasicMaterial, _Material$5 );
        var _super35 = _createSuper( LineBasicMaterial );

        function LineBasicMaterial( parameters ) {
            var _this32;
            _classCallCheck( this, LineBasicMaterial );
            _this32 = _super35.call( this );
            _this32.isLineBasicMaterial = true;
            _this32.type = 'LineBasicMaterial';
            _this32.color = new Color( 0xffffff );
            _this32.linewidth = 1;
            _this32.linecap = 'round';
            _this32.linejoin = 'round';
            _this32.fog = true;
            _this32.setValues( parameters );
            return _this32;
        }
        _createClass( LineBasicMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( LineBasicMaterial.prototype ), "copy", this ).call( this, source );
                this.color.copy( source.color );
                this.linewidth = source.linewidth;
                this.linecap = source.linecap;
                this.linejoin = source.linejoin;
                this.fog = source.fog;
                return this;
            }
        } ] );
        return LineBasicMaterial;
    }( Material$1 );
    var _start$1 = /*@__PURE__*/ new Vector3( );
    var _end$1 = /*@__PURE__*/ new Vector3( );
    var _inverseMatrix$1 = /*@__PURE__*/ new Matrix4( );
    var _ray$1 = /*@__PURE__*/ new Ray$1( );
    var _sphere$1 = /*@__PURE__*/ new Sphere( );
    var Line = /*#__PURE__*/ function( _Object3D7 ) {
        _inherits( Line, _Object3D7 );
        var _super36 = _createSuper( Line );

        function Line( ) {
            var _this33;
            var geometry = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new BufferGeometry( );
            var material = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new LineBasicMaterial( );
            _classCallCheck( this, Line );
            _this33 = _super36.call( this );
            _this33.isLine = true;
            _this33.type = 'Line';
            _this33.geometry = geometry;
            _this33.material = material;
            _this33.updateMorphTargets( );
            return _this33;
        }
        _createClass( Line, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Line.prototype ), "copy", this ).call( this, source, recursive );
                this.material = source.material;
                this.geometry = source.geometry;
                return this;
            }
        }, {
            key: "computeLineDistances",
            value: function computeLineDistances( ) {
                var geometry = this.geometry; // we assume non-indexed geometry
                if ( geometry.index === null ) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [ 0 ];
                    for ( var _i176 = 1, l = positionAttribute.count; _i176 < l; _i176++ ) {
                        _start$1.fromBufferAttribute( positionAttribute, _i176 - 1 );
                        _end$1.fromBufferAttribute( positionAttribute, _i176 );
                        lineDistances[ _i176 ] = lineDistances[ _i176 - 1 ];
                        lineDistances[ _i176 ] += _start$1.distanceTo( _end$1 );
                    }
                    geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
                } else {
                    console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
                }
                return this;
            }
        }, {
            key: "raycast",
            value: function raycast( raycaster, intersects ) {
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Line.threshold;
                var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray
                if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere( );
                _sphere$1.copy( geometry.boundingSphere );
                _sphere$1.applyMatrix4( matrixWorld );
                _sphere$1.radius += threshold;
                if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return; //
                _inverseMatrix$1.copy( matrixWorld ).invert( );
                _ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );
                var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
                var localThresholdSq = localThreshold * localThreshold;
                var vStart = new Vector3( );
                var vEnd = new Vector3( );
                var interSegment = new Vector3( );
                var interRay = new Vector3( );
                var step = this.isLineSegments ? 2 : 1;
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positionAttribute = attributes.position;
                if ( index !== null ) {
                    var start = Math.max( 0, drawRange.start );
                    var end = Math.min( index.count, drawRange.start + drawRange.count );
                    for ( var _i177 = start, l = end - 1; _i177 < l; _i177 += step ) {
                        var _a10 = index.getX( _i177 );
                        var _b10 = index.getX( _i177 + 1 );
                        vStart.fromBufferAttribute( positionAttribute, _a10 );
                        vEnd.fromBufferAttribute( positionAttribute, _b10 );
                        var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
                        if ( distSq > localThresholdSq ) continue;
                        interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
                        var distance = raycaster.ray.origin.distanceTo( interRay );
                        if ( distance < raycaster.near || distance > raycaster.far ) continue;
                        intersects.push( {
                            distance: distance, // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone( ).applyMatrix4( this.matrixWorld ),
                            index: _i177,
                            face: null,
                            faceIndex: null,
                            object: this
                        } );
                    }
                } else {
                    var _start6 = Math.max( 0, drawRange.start );
                    var _end5 = Math.min( positionAttribute.count, drawRange.start + drawRange.count );
                    for ( var _i178 = _start6, _l7 = _end5 - 1; _i178 < _l7; _i178 += step ) {
                        vStart.fromBufferAttribute( positionAttribute, _i178 );
                        vEnd.fromBufferAttribute( positionAttribute, _i178 + 1 );
                        var _distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
                        if ( _distSq > localThresholdSq ) continue;
                        interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
                        var _distance = raycaster.ray.origin.distanceTo( interRay );
                        if ( _distance < raycaster.near || _distance > raycaster.far ) continue;
                        intersects.push( {
                            distance: _distance, // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone( ).applyMatrix4( this.matrixWorld ),
                            index: _i178,
                            face: null,
                            faceIndex: null,
                            object: this
                        } );
                    }
                }
            }
        }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets( ) {
                var geometry = this.geometry;
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys( morphAttributes );
                if ( keys.length > 0 ) {
                    var morphAttribute = morphAttributes[ keys[ 0 ] ];
                    if ( morphAttribute !== undefined ) {
                        this.morphTargetInfluences = [ ];
                        this.morphTargetDictionary = {};
                        for ( var m = 0, ml = morphAttribute.length; m < ml; m++ ) {
                            var name = morphAttribute[ m ].name || String( m );
                            this.morphTargetInfluences.push( 0 );
                            this.morphTargetDictionary[ name ] = m;
                        }
                    }
                }
            }
        } ] );
        return Line;
    }( Object3D );
    var _start = /*@__PURE__*/ new Vector3( );
    var _end = /*@__PURE__*/ new Vector3( );
    var LineSegments = /*#__PURE__*/ function( _Line ) {
        _inherits( LineSegments, _Line );
        var _super37 = _createSuper( LineSegments );

        function LineSegments( geometry, material ) {
            var _this34;
            _classCallCheck( this, LineSegments );
            _this34 = _super37.call( this, geometry, material );
            _this34.isLineSegments = true;
            _this34.type = 'LineSegments';
            return _this34;
        }
        _createClass( LineSegments, [ {
            key: "computeLineDistances",
            value: function computeLineDistances( ) {
                var geometry = this.geometry; // we assume non-indexed geometry
                if ( geometry.index === null ) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [ ];
                    for ( var _i179 = 0, l = positionAttribute.count; _i179 < l; _i179 += 2 ) {
                        _start.fromBufferAttribute( positionAttribute, _i179 );
                        _end.fromBufferAttribute( positionAttribute, _i179 + 1 );
                        lineDistances[ _i179 ] = _i179 === 0 ? 0 : lineDistances[ _i179 - 1 ];
                        lineDistances[ _i179 + 1 ] = lineDistances[ _i179 ] + _start.distanceTo( _end );
                    }
                    geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
                } else {
                    console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
                }
                return this;
            }
        } ] );
        return LineSegments;
    }( Line );
    var LineLoop = /*#__PURE__*/ function( _Line2 ) {
        _inherits( LineLoop, _Line2 );
        var _super38 = _createSuper( LineLoop );

        function LineLoop( geometry, material ) {
            var _this35;
            _classCallCheck( this, LineLoop );
            _this35 = _super38.call( this, geometry, material );
            _this35.isLineLoop = true;
            _this35.type = 'LineLoop';
            return _this35;
        }
        return _createClass( LineLoop );
    }( Line );
    var PointsMaterial = /*#__PURE__*/ function( _Material$6 ) {
        _inherits( PointsMaterial, _Material$6 );
        var _super39 = _createSuper( PointsMaterial );

        function PointsMaterial( parameters ) {
            var _this36;
            _classCallCheck( this, PointsMaterial );
            _this36 = _super39.call( this );
            _this36.isPointsMaterial = true;
            _this36.type = 'PointsMaterial';
            _this36.color = new Color( 0xffffff );
            _this36.map = null;
            _this36.alphaMap = null;
            _this36.size = 1;
            _this36.sizeAttenuation = true;
            _this36.fog = true;
            _this36.setValues( parameters );
            return _this36;
        }
        _createClass( PointsMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( PointsMaterial.prototype ), "copy", this ).call( this, source );
                this.color.copy( source.color );
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.size = source.size;
                this.sizeAttenuation = source.sizeAttenuation;
                this.fog = source.fog;
                return this;
            }
        } ] );
        return PointsMaterial;
    }( Material$1 );
    var _inverseMatrix = /*@__PURE__*/ new Matrix4( );
    var _ray = /*@__PURE__*/ new Ray$1( );
    var _sphere = /*@__PURE__*/ new Sphere( );
    var _position$2 = /*@__PURE__*/ new Vector3( );
    var Points = /*#__PURE__*/ function( _Object3D8 ) {
        _inherits( Points, _Object3D8 );
        var _super40 = _createSuper( Points );

        function Points( ) {
            var _this37;
            var geometry = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : new BufferGeometry( );
            var material = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new PointsMaterial( );
            _classCallCheck( this, Points );
            _this37 = _super40.call( this );
            _this37.isPoints = true;
            _this37.type = 'Points';
            _this37.geometry = geometry;
            _this37.material = material;
            _this37.updateMorphTargets( );
            return _this37;
        }
        _createClass( Points, [ {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Points.prototype ), "copy", this ).call( this, source, recursive );
                this.material = source.material;
                this.geometry = source.geometry;
                return this;
            }
        }, {
            key: "raycast",
            value: function raycast( raycaster, intersects ) {
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;
                var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray
                if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere( );
                _sphere.copy( geometry.boundingSphere );
                _sphere.applyMatrix4( matrixWorld );
                _sphere.radius += threshold;
                if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return; //
                _inverseMatrix.copy( matrixWorld ).invert( );
                _ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );
                var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
                var localThresholdSq = localThreshold * localThreshold;
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positionAttribute = attributes.position;
                if ( index !== null ) {
                    var start = Math.max( 0, drawRange.start );
                    var end = Math.min( index.count, drawRange.start + drawRange.count );
                    for ( var _i180 = start, il = end; _i180 < il; _i180++ ) {
                        var _a11 = index.getX( _i180 );
                        _position$2.fromBufferAttribute( positionAttribute, _a11 );
                        testPoint( _position$2, _a11, localThresholdSq, matrixWorld, raycaster, intersects, this );
                    }
                } else {
                    var _start7 = Math.max( 0, drawRange.start );
                    var _end6 = Math.min( positionAttribute.count, drawRange.start + drawRange.count );
                    for ( var _i181 = _start7, l = _end6; _i181 < l; _i181++ ) {
                        _position$2.fromBufferAttribute( positionAttribute, _i181 );
                        testPoint( _position$2, _i181, localThresholdSq, matrixWorld, raycaster, intersects, this );
                    }
                }
            }
        }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets( ) {
                var geometry = this.geometry;
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys( morphAttributes );
                if ( keys.length > 0 ) {
                    var morphAttribute = morphAttributes[ keys[ 0 ] ];
                    if ( morphAttribute !== undefined ) {
                        this.morphTargetInfluences = [ ];
                        this.morphTargetDictionary = {};
                        for ( var m = 0, ml = morphAttribute.length; m < ml; m++ ) {
                            var name = morphAttribute[ m ].name || String( m );
                            this.morphTargetInfluences.push( 0 );
                            this.morphTargetDictionary[ name ] = m;
                        }
                    }
                }
            }
        } ] );
        return Points;
    }( Object3D );

    function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {
        var rayPointDistanceSq = _ray.distanceSqToPoint( point );
        if ( rayPointDistanceSq < localThresholdSq ) {
            var _intersectPoint = new Vector3( );
            _ray.closestPointToPoint( point, _intersectPoint );
            _intersectPoint.applyMatrix4( matrixWorld );
            var distance = raycaster.ray.origin.distanceTo( _intersectPoint );
            if ( distance < raycaster.near || distance > raycaster.far ) return;
            intersects.push( {
                distance: distance,
                distanceToRay: Math.sqrt( rayPointDistanceSq ),
                point: _intersectPoint,
                index: index,
                face: null,
                object: object
            } );
        }
    }
    /**
     * Extensible curve object.
     *
     * Some common of curve methods:
     * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
     * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following curves inherit from THREE.Curve:
     *
     * -- 2D curves --
     * THREE.ArcCurve
     * THREE.CubicBezierCurve
     * THREE.EllipseCurve
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.SplineCurve
     *
     * -- 3D curves --
     * THREE.CatmullRomCurve3
     * THREE.CubicBezierCurve3
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath.
     *
     **/
    var Curve = /*#__PURE__*/ function( ) {
        function Curve( ) {
            _classCallCheck( this, Curve );
            this.type = 'Curve';
            this.arcLengthDivisions = 200;
        } // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]
        _createClass( Curve, [ {
            key: "getPoint",
            value: function /* t, optionalTarget */ getPoint( ) {
                console.warn( 'THREE.Curve: .getPoint() not implemented.' );
                return null;
            } // Get point at relative position in curve according to arc length
            // - u [0 .. 1]
        }, {
            key: "getPointAt",
            value: function getPointAt( u, optionalTarget ) {
                var t = this.getUtoTmapping( u );
                return this.getPoint( t, optionalTarget );
            } // Get sequence of points using getPoint( t )
        }, {
            key: "getPoints",
            value: function getPoints( ) {
                var divisions = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 5;
                var points = [ ];
                for ( var d = 0; d <= divisions; d++ ) {
                    points.push( this.getPoint( d / divisions ) );
                }
                return points;
            } // Get sequence of points using getPointAt( u )
        }, {
            key: "getSpacedPoints",
            value: function getSpacedPoints( ) {
                var divisions = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : 5;
                var points = [ ];
                for ( var d = 0; d <= divisions; d++ ) {
                    points.push( this.getPointAt( d / divisions ) );
                }
                return points;
            } // Get total curve arc length
        }, {
            key: "getLength",
            value: function getLength( ) {
                var lengths = this.getLengths( );
                return lengths[ lengths.length - 1 ];
            } // Get list of cumulative segment lengths
        }, {
            key: "getLengths",
            value: function getLengths( ) {
                var divisions = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : this.arcLengthDivisions;
                if ( this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate ) {
                    return this.cacheArcLengths;
                }
                this.needsUpdate = false;
                var cache = [ ];
                var current, last = this.getPoint( 0 );
                var sum = 0;
                cache.push( 0 );
                for ( var p = 1; p <= divisions; p++ ) {
                    current = this.getPoint( p / divisions );
                    sum += current.distanceTo( last );
                    cache.push( sum );
                    last = current;
                }
                this.cacheArcLengths = cache;
                return cache; // { sums: cache, sum: sum }; Sum is in the last element.
            }
        }, {
            key: "updateArcLengths",
            value: function updateArcLengths( ) {
                this.needsUpdate = true;
                this.getLengths( );
            } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
        }, {
            key: "getUtoTmapping",
            value: function getUtoTmapping( u, distance ) {
                var arcLengths = this.getLengths( );
                var i = 0;
                var il = arcLengths.length;
                var targetArcLength; // The targeted u distance value to get
                if ( distance ) {
                    targetArcLength = distance;
                } else {
                    targetArcLength = u * arcLengths[ il - 1 ];
                } // binary search for the index with largest value smaller than target u distance
                var low = 0,
                    high = il - 1,
                    comparison;
                while ( low <= high ) {
                    i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                    comparison = arcLengths[ i ] - targetArcLength;
                    if ( comparison < 0 ) {
                        low = i + 1;
                    } else if ( comparison > 0 ) {
                        high = i - 1;
                    } else {
                        high = i;
                        break; // DONE
                    }
                }
                i = high;
                if ( arcLengths[ i ] === targetArcLength ) {
                    return i / ( il - 1 );
                } // we could get finer grain at lengths, or use simple interpolation between two points
                var lengthBefore = arcLengths[ i ];
                var lengthAfter = arcLengths[ i + 1 ];
                var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points
                var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength; // add that fractional amount to t
                var t = ( i + segmentFraction ) / ( il - 1 );
                return t;
            } // Returns a unit vector tangent at t
            // In case any sub curve does not implement its tangent derivation,
            // 2 points a small delta apart will be used to find its gradient
            // which seems to give a reasonable approximation
        }, {
            key: "getTangent",
            value: function getTangent( t, optionalTarget ) {
                var delta = 0.0001;
                var t1 = t - delta;
                var t2 = t + delta; // Capping in case of danger
                if ( t1 < 0 ) t1 = 0;
                if ( t2 > 1 ) t2 = 1;
                var pt1 = this.getPoint( t1 );
                var pt2 = this.getPoint( t2 );
                var tangent = optionalTarget || ( pt1.isVector2 ? new Vector2( ) : new Vector3( ) );
                tangent.copy( pt2 ).sub( pt1 ).normalize( );
                return tangent;
            }
        }, {
            key: "getTangentAt",
            value: function getTangentAt( u, optionalTarget ) {
                var t = this.getUtoTmapping( u );
                return this.getTangent( t, optionalTarget );
            }
        }, {
            key: "computeFrenetFrames",
            value: function computeFrenetFrames( segments, closed ) { // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
                var normal = new Vector3( );
                var tangents = [ ];
                var normals = [ ];
                var binormals = [ ];
                var vec = new Vector3( );
                var mat = new Matrix4( ); // compute the tangent vectors for each segment on the curve
                for ( var _i182 = 0; _i182 <= segments; _i182++ ) {
                    var u = _i182 / segments;
                    tangents[ _i182 ] = this.getTangentAt( u, new Vector3( ) );
                } // select an initial normal vector perpendicular to the first tangent vector,
                // and in the direction of the minimum tangent xyz component
                normals[ 0 ] = new Vector3( );
                binormals[ 0 ] = new Vector3( );
                var min = Number.MAX_VALUE;
                var tx = Math.abs( tangents[ 0 ].x );
                var ty = Math.abs( tangents[ 0 ].y );
                var tz = Math.abs( tangents[ 0 ].z );
                if ( tx <= min ) {
                    min = tx;
                    normal.set( 1, 0, 0 );
                }
                if ( ty <= min ) {
                    min = ty;
                    normal.set( 0, 1, 0 );
                }
                if ( tz <= min ) {
                    normal.set( 0, 0, 1 );
                }
                vec.crossVectors( tangents[ 0 ], normal ).normalize( );
                normals[ 0 ].crossVectors( tangents[ 0 ], vec );
                binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ); // compute the slowly-varying normal and binormal vectors for each segment on the curve
                for ( var _i183 = 1; _i183 <= segments; _i183++ ) {
                    normals[ _i183 ] = normals[ _i183 - 1 ].clone( );
                    binormals[ _i183 ] = binormals[ _i183 - 1 ].clone( );
                    vec.crossVectors( tangents[ _i183 - 1 ], tangents[ _i183 ] );
                    if ( vec.length( ) > Number.EPSILON ) {
                        vec.normalize( );
                        var theta = Math.acos( clamp( tangents[ _i183 - 1 ].dot( tangents[ _i183 ] ), -1, 1 ) ); // clamp for floating pt errors
                        normals[ _i183 ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
                    }
                    binormals[ _i183 ].crossVectors( tangents[ _i183 ], normals[ _i183 ] );
                } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
                if ( closed === true ) {
                    var _theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), -1, 1 ) );
                    _theta /= segments;
                    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
                        _theta = -_theta;
                    }
                    for ( var _i184 = 1; _i184 <= segments; _i184++ ) { // twist a little...
                        normals[ _i184 ].applyMatrix4( mat.makeRotationAxis( tangents[ _i184 ], _theta * _i184 ) );
                        binormals[ _i184 ].crossVectors( tangents[ _i184 ], normals[ _i184 ] );
                    }
                }
                return {
                    tangents: tangents,
                    normals: normals,
                    binormals: binormals
                };
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.arcLengthDivisions = source.arcLengthDivisions;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Curve',
                        generator: 'Curve.toJSON'
                    }
                };
                data.arcLengthDivisions = this.arcLengthDivisions;
                data.type = this.type;
                return data;
            }
        }, {
            key: "fromJSON",
            value: function fromJSON( json ) {
                this.arcLengthDivisions = json.arcLengthDivisions;
                return this;
            }
        } ] );
        return Curve;
    }( );
    /**
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */
    /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/
    function CubicPoly( ) {
        var c0 = 0,
            c1 = 0,
            c2 = 0,
            c3 = 0;
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init( x0, x1, t0, t1 ) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function initCatmullRom( x0, x1, x2, x3, tension ) {
                init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
            },
            initNonuniformCatmullRom: function initNonuniformCatmullRom( x0, x1, x2, x3, dt0, dt1, dt2 ) { // compute tangents when parameterized in [t1,t2]
                var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
                var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2; // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
                init( x1, x2, t1, t2 );
            },
            calc: function calc( t ) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    } //
    var tmp$2 = /*@__PURE__*/ new Vector3( );
    var px = /*@__PURE__*/ new CubicPoly( );
    var py = /*@__PURE__*/ new CubicPoly( );
    var pz = /*@__PURE__*/ new CubicPoly( );
    var CatmullRomCurve3 = /*#__PURE__*/ function( _Curve ) {
        _inherits( CatmullRomCurve3, _Curve );
        var _super41 = _createSuper( CatmullRomCurve3 );

        function CatmullRomCurve3( ) {
            var _this38;
            var points = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : [ ];
            var closed = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : false;
            var curveType = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 'centripetal';
            var tension = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 0.5;
            _classCallCheck( this, CatmullRomCurve3 );
            _this38 = _super41.call( this );
            _this38.isCatmullRomCurve3 = true;
            _this38.type = 'CatmullRomCurve3';
            _this38.points = points;
            _this38.closed = closed;
            _this38.curveType = curveType;
            _this38.tension = tension;
            return _this38;
        }
        _createClass( CatmullRomCurve3, [ {
            key: "getPoint",
            value: function getPoint( t ) {
                var optionalTarget = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : new Vector3( );
                var point = optionalTarget;
                var points = this.points;
                var l = points.length;
                var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
                var intPoint = Math.floor( p );
                var weight = p - intPoint;
                if ( this.closed ) {
                    intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;
                } else if ( weight === 0 && intPoint === l - 1 ) {
                    intPoint = l - 2;
                    weight = 1;
                }
                var p0, p3; // 4 points (p1 & p2 defined below)
                if ( this.closed || intPoint > 0 ) {
                    p0 = points[ ( intPoint - 1 ) % l ];
                } else { // extrapolate first point
                    tmp$2.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                    p0 = tmp$2;
                }
                var p1 = points[ intPoint % l ];
                var p2 = points[ ( intPoint + 1 ) % l ];
                if ( this.closed || intPoint + 2 < l ) {
                    p3 = points[ ( intPoint + 2 ) % l ];
                } else { // extrapolate last point
                    tmp$2.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
                    p3 = tmp$2;
                }
                if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) { // init Centripetal / Chordal Catmull-Rom
                    var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                    var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                    var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                    var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow ); // safety check for repeated points
                    if ( dt1 < 1e-4 ) dt1 = 1.0;
                    if ( dt0 < 1e-4 ) dt0 = dt1;
                    if ( dt2 < 1e-4 ) dt2 = dt1;
                    px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                    py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                    pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
                } else if ( this.curveType === 'catmullrom' ) {
                    px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
                    py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
                    pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );
                }
                point.set( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );
                return point;
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( CatmullRomCurve3.prototype ), "copy", this ).call( this, source );
                this.points = [ ];
                for ( var _i185 = 0, l = source.points.length; _i185 < l; _i185++ ) {
                    var point = source.points[ _i185 ];
                    this.points.push( point.clone( ) );
                }
                this.closed = source.closed;
                this.curveType = source.curveType;
                this.tension = source.tension;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var data = _get( _getPrototypeOf( CatmullRomCurve3.prototype ), "toJSON", this ).call( this );
                data.points = [ ];
                for ( var _i186 = 0, l = this.points.length; _i186 < l; _i186++ ) {
                    var point = this.points[ _i186 ];
                    data.points.push( point.toArray( ) );
                }
                data.closed = this.closed;
                data.curveType = this.curveType;
                data.tension = this.tension;
                return data;
            }
        }, {
            key: "fromJSON",
            value: function fromJSON( json ) {
                _get( _getPrototypeOf( CatmullRomCurve3.prototype ), "fromJSON", this ).call( this, json );
                this.points = [ ];
                for ( var _i187 = 0, l = json.points.length; _i187 < l; _i187++ ) {
                    var point = json.points[ _i187 ];
                    this.points.push( new Vector3( ).fromArray( point ) );
                }
                this.closed = json.closed;
                this.curveType = json.curveType;
                this.tension = json.tension;
                return this;
            }
        } ] );
        return CatmullRomCurve3;
    }( Curve );
    var MeshStandardMaterial = /*#__PURE__*/ function( _Material$7 ) {
        _inherits( MeshStandardMaterial, _Material$7 );
        var _super42 = _createSuper( MeshStandardMaterial );

        function MeshStandardMaterial( parameters ) {
            var _this39;
            _classCallCheck( this, MeshStandardMaterial );
            _this39 = _super42.call( this );
            _this39.isMeshStandardMaterial = true;
            _this39.defines = {
                'STANDARD': ''
            };
            _this39.type = 'MeshStandardMaterial';
            _this39.color = new Color( 0xffffff ); // diffuse
            _this39.roughness = 1.0;
            _this39.metalness = 0.0;
            _this39.map = null;
            _this39.lightMap = null;
            _this39.lightMapIntensity = 1.0;
            _this39.aoMap = null;
            _this39.aoMapIntensity = 1.0;
            _this39.emissive = new Color( 0x000000 );
            _this39.emissiveIntensity = 1.0;
            _this39.emissiveMap = null;
            _this39.bumpMap = null;
            _this39.bumpScale = 1;
            _this39.normalMap = null;
            _this39.normalMapType = TangentSpaceNormalMap;
            _this39.normalScale = new Vector2( 1, 1 );
            _this39.displacementMap = null;
            _this39.displacementScale = 1;
            _this39.displacementBias = 0;
            _this39.roughnessMap = null;
            _this39.metalnessMap = null;
            _this39.alphaMap = null;
            _this39.envMap = null;
            _this39.envMapIntensity = 1.0;
            _this39.wireframe = false;
            _this39.wireframeLinewidth = 1;
            _this39.wireframeLinecap = 'round';
            _this39.wireframeLinejoin = 'round';
            _this39.flatShading = false;
            _this39.fog = true;
            _this39.setValues( parameters );
            return _this39;
        }
        _createClass( MeshStandardMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( MeshStandardMaterial.prototype ), "copy", this ).call( this, source );
                this.defines = {
                    'STANDARD': ''
                };
                this.color.copy( source.color );
                this.roughness = source.roughness;
                this.metalness = source.metalness;
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy( source.emissive );
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy( source.normalScale );
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.roughnessMap = source.roughnessMap;
                this.metalnessMap = source.metalnessMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.envMapIntensity = source.envMapIntensity;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.flatShading = source.flatShading;
                this.fog = source.fog;
                return this;
            }
        } ] );
        return MeshStandardMaterial;
    }( Material$1 );
    var MeshPhysicalMaterial = /*#__PURE__*/ function( _MeshStandardMaterial ) {
        _inherits( MeshPhysicalMaterial, _MeshStandardMaterial );
        var _super43 = _createSuper( MeshPhysicalMaterial );

        function MeshPhysicalMaterial( parameters ) {
            var _this40;
            _classCallCheck( this, MeshPhysicalMaterial );
            _this40 = _super43.call( this );
            _this40.isMeshPhysicalMaterial = true;
            _this40.defines = {
                'STANDARD': '',
                'PHYSICAL': ''
            };
            _this40.type = 'MeshPhysicalMaterial';
            _this40.clearcoatMap = null;
            _this40.clearcoatRoughness = 0.0;
            _this40.clearcoatRoughnessMap = null;
            _this40.clearcoatNormalScale = new Vector2( 1, 1 );
            _this40.clearcoatNormalMap = null;
            _this40.ior = 1.5;
            Object.defineProperty( _assertThisInitialized( _this40 ), 'reflectivity', {
                get: function get( ) {
                    return clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 );
                },
                set: function set( reflectivity ) {
                    this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );
                }
            } );
            _this40.iridescenceMap = null;
            _this40.iridescenceIOR = 1.3;
            _this40.iridescenceThicknessRange = [ 100, 400 ];
            _this40.iridescenceThicknessMap = null;
            _this40.sheenColor = new Color( 0x000000 );
            _this40.sheenColorMap = null;
            _this40.sheenRoughness = 1.0;
            _this40.sheenRoughnessMap = null;
            _this40.transmissionMap = null;
            _this40.thickness = 0;
            _this40.thicknessMap = null;
            _this40.attenuationDistance = 0.0;
            _this40.attenuationColor = new Color( 1, 1, 1 );
            _this40.specularIntensity = 1.0;
            _this40.specularIntensityMap = null;
            _this40.specularColor = new Color( 1, 1, 1 );
            _this40.specularColorMap = null;
            _this40._sheen = 0.0;
            _this40._clearcoat = 0;
            _this40._iridescence = 0;
            _this40._transmission = 0;
            _this40.setValues( parameters );
            return _this40;
        }
        _createClass( MeshPhysicalMaterial, [ {
            key: "sheen",
            get: function get( ) {
                return this._sheen;
            },
            set: function set( value ) {
                if ( this._sheen > 0 !== value > 0 ) {
                    this.version++;
                }
                this._sheen = value;
            }
        }, {
            key: "clearcoat",
            get: function get( ) {
                return this._clearcoat;
            },
            set: function set( value ) {
                if ( this._clearcoat > 0 !== value > 0 ) {
                    this.version++;
                }
                this._clearcoat = value;
            }
        }, {
            key: "iridescence",
            get: function get( ) {
                return this._iridescence;
            },
            set: function set( value ) {
                if ( this._iridescence > 0 !== value > 0 ) {
                    this.version++;
                }
                this._iridescence = value;
            }
        }, {
            key: "transmission",
            get: function get( ) {
                return this._transmission;
            },
            set: function set( value ) {
                if ( this._transmission > 0 !== value > 0 ) {
                    this.version++;
                }
                this._transmission = value;
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( MeshPhysicalMaterial.prototype ), "copy", this ).call( this, source );
                this.defines = {
                    'STANDARD': '',
                    'PHYSICAL': ''
                };
                this.clearcoat = source.clearcoat;
                this.clearcoatMap = source.clearcoatMap;
                this.clearcoatRoughness = source.clearcoatRoughness;
                this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
                this.clearcoatNormalMap = source.clearcoatNormalMap;
                this.clearcoatNormalScale.copy( source.clearcoatNormalScale );
                this.ior = source.ior;
                this.iridescence = source.iridescence;
                this.iridescenceMap = source.iridescenceMap;
                this.iridescenceIOR = source.iridescenceIOR;
                this.iridescenceThicknessRange = _toConsumableArray( source.iridescenceThicknessRange );
                this.iridescenceThicknessMap = source.iridescenceThicknessMap;
                this.sheen = source.sheen;
                this.sheenColor.copy( source.sheenColor );
                this.sheenColorMap = source.sheenColorMap;
                this.sheenRoughness = source.sheenRoughness;
                this.sheenRoughnessMap = source.sheenRoughnessMap;
                this.transmission = source.transmission;
                this.transmissionMap = source.transmissionMap;
                this.thickness = source.thickness;
                this.thicknessMap = source.thicknessMap;
                this.attenuationDistance = source.attenuationDistance;
                this.attenuationColor.copy( source.attenuationColor );
                this.specularIntensity = source.specularIntensity;
                this.specularIntensityMap = source.specularIntensityMap;
                this.specularColor.copy( source.specularColor );
                this.specularColorMap = source.specularColorMap;
                return this;
            }
        } ] );
        return MeshPhysicalMaterial;
    }( MeshStandardMaterial );
    var AnimationUtils = { // same as Array.prototype.slice, but also works on typed arrays
        arraySlice: function arraySlice( array, from, to ) {
            if ( AnimationUtils.isTypedArray( array ) ) { // in ios9 array.subarray(from, undefined) will return empty array
                // but array.subarray(from) or array.subarray(from, len) is correct
                return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
            }
            return array.slice( from, to );
        }, // converts an array to a specific type
        convertArray: function convertArray( array, type, forceClone ) {
            if ( !array || // let 'undefined' and 'null' pass
                !forceClone && array.constructor === type ) return array;
            if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
                return new type( array ); // create typed array
            }
            return Array.prototype.slice.call( array ); // create Array
        },
        isTypedArray: function isTypedArray( object ) {
            return ArrayBuffer.isView( object ) && !( object instanceof DataView );
        }, // returns an array by which times and values can be sorted
        getKeyframeOrder: function getKeyframeOrder( times ) {
            function compareTime( i, j ) {
                return times[ i ] - times[ j ];
            }
            var n = times.length;
            var result = new Array( n );
            for ( var _i188 = 0; _i188 !== n; ++_i188 ) {
                result[ _i188 ] = _i188;
            }
            result.sort( compareTime );
            return result;
        }, // uses the array previously returned by 'getKeyframeOrder' to sort data
        sortedArray: function sortedArray( values, stride, order ) {
            var nValues = values.length;
            var result = new values.constructor( nValues );
            for ( var _i189 = 0, dstOffset = 0; dstOffset !== nValues; ++_i189 ) {
                var srcOffset = order[ _i189 ] * stride;
                for ( var j = 0; j !== stride; ++j ) {
                    result[ dstOffset++ ] = values[ srcOffset + j ];
                }
            }
            return result;
        }, // function for parsing AOS keyframe formats
        flattenJSON: function flattenJSON( jsonKeys, times, values, valuePropertyName ) {
            var i = 1,
                key = jsonKeys[ 0 ];
            while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
                key = jsonKeys[ i++ ];
            }
            if ( key === undefined ) return; // no data
            var value = key[ valuePropertyName ];
            if ( value === undefined ) return; // no data
            if ( Array.isArray( value ) ) {
                do {
                    value = key[ valuePropertyName ];
                    if ( value !== undefined ) {
                        times.push( key.time );
                        values.push.apply( values, value ); // push all elements
                    }
                    key = jsonKeys[ i++ ];
                } while ( key !== undefined );
            } else if ( value.toArray !== undefined ) { // ...assume THREE.Math-ish
                do {
                    value = key[ valuePropertyName ];
                    if ( value !== undefined ) {
                        times.push( key.time );
                        value.toArray( values, values.length );
                    }
                    key = jsonKeys[ i++ ];
                } while ( key !== undefined );
            } else { // otherwise push as-is
                do {
                    value = key[ valuePropertyName ];
                    if ( value !== undefined ) {
                        times.push( key.time );
                        values.push( value );
                    }
                    key = jsonKeys[ i++ ];
                } while ( key !== undefined );
            }
        },
        subclip: function subclip( sourceClip, name, startFrame, endFrame ) {
            var fps = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : 30;
            var clip = sourceClip.clone( );
            clip.name = name;
            var tracks = [ ];
            for ( var _i190 = 0; _i190 < clip.tracks.length; ++_i190 ) {
                var track = clip.tracks[ _i190 ];
                var valueSize = track.getValueSize( );
                var times = [ ];
                var values = [ ];
                for ( var j = 0; j < track.times.length; ++j ) {
                    var frame = track.times[ j ] * fps;
                    if ( frame < startFrame || frame >= endFrame ) continue;
                    times.push( track.times[ j ] );
                    for ( var k = 0; k < valueSize; ++k ) {
                        values.push( track.values[ j * valueSize + k ] );
                    }
                }
                if ( times.length === 0 ) continue;
                track.times = AnimationUtils.convertArray( times, track.times.constructor );
                track.values = AnimationUtils.convertArray( values, track.values.constructor );
                tracks.push( track );
            }
            clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip
            var minStartTime = Infinity;
            for ( var _i191 = 0; _i191 < clip.tracks.length; ++_i191 ) {
                if ( minStartTime > clip.tracks[ _i191 ].times[ 0 ] ) {
                    minStartTime = clip.tracks[ _i191 ].times[ 0 ];
                }
            } // shift all tracks such that clip begins at t=0
            for ( var _i192 = 0; _i192 < clip.tracks.length; ++_i192 ) {
                clip.tracks[ _i192 ].shift( -1 * minStartTime );
            }
            clip.resetDuration( );
            return clip;
        },
        makeClipAdditive: function makeClipAdditive( targetClip ) {
            var referenceFrame = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
            var referenceClip = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : targetClip;
            var fps = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 30;
            if ( fps <= 0 ) fps = 30;
            var numTracks = referenceClip.tracks.length;
            var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame
            var _loop = function _loop( _i193 ) {
                var referenceTrack = referenceClip.tracks[ _i193 ];
                var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric
                if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) return "continue"; // Find the track in the target clip whose name and type matches the reference track
                var targetTrack = targetClip.tracks.find( function( track ) {
                    return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
                } );
                if ( targetTrack === undefined ) return "continue";
                var referenceOffset = 0;
                var referenceValueSize = referenceTrack.getValueSize( );
                if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {
                    referenceOffset = referenceValueSize / 3;
                }
                var targetOffset = 0;
                var targetValueSize = targetTrack.getValueSize( );
                if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {
                    targetOffset = targetValueSize / 3;
                }
                var lastIndex = referenceTrack.times.length - 1;
                var referenceValue = void 0; // Find the value to subtract out of the track
                if ( referenceTime <= referenceTrack.times[ 0 ] ) { // Reference frame is earlier than the first keyframe, so just use the first keyframe
                    var startIndex = referenceOffset;
                    var endIndex = referenceValueSize - referenceOffset;
                    referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );
                } else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) { // Reference frame is after the last keyframe, so just use the last keyframe
                    var _startIndex = lastIndex * referenceValueSize + referenceOffset;
                    var _endIndex = _startIndex + referenceValueSize - referenceOffset;
                    referenceValue = AnimationUtils.arraySlice( referenceTrack.values, _startIndex, _endIndex );
                } else { // Interpolate to the reference value
                    var interpolant = referenceTrack.createInterpolant( );
                    var _startIndex2 = referenceOffset;
                    var _endIndex2 = referenceValueSize - referenceOffset;
                    interpolant.evaluate( referenceTime );
                    referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, _startIndex2, _endIndex2 );
                } // Conjugate the quaternion
                if ( referenceTrackType === 'quaternion' ) {
                    var referenceQuat = new Quaternion$1( ).fromArray( referenceValue ).normalize( ).conjugate( );
                    referenceQuat.toArray( referenceValue );
                } // Subtract the reference value from all of the track values
                var numTimes = targetTrack.times.length;
                for ( var j = 0; j < numTimes; ++j ) {
                    var valueStart = j * targetValueSize + targetOffset;
                    if ( referenceTrackType === 'quaternion' ) { // Multiply the conjugate for quaternion track types
                        Quaternion$1.multiplyQuaternionsFlat( targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart );
                    } else {
                        var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types
                        for ( var k = 0; k < valueEnd; ++k ) {
                            targetTrack.values[ valueStart + k ] -= referenceValue[ k ];
                        }
                    }
                }
            };
            for ( var _i193 = 0; _i193 < numTracks; ++_i193 ) {
                var _ret = _loop( _i193 );
                if ( _ret === "continue" ) continue;
            }
            targetClip.blendMode = AdditiveAnimationBlendMode;
            return targetClip;
        }
    };
    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     */
    var Interpolant = /*#__PURE__*/ function( ) {
        function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            _classCallCheck( this, Interpolant );
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor( sampleSize );
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
            this.settings = null;
            this.DefaultSettings_ = {};
        }
        _createClass( Interpolant, [ {
            key: "evaluate",
            value: function evaluate( t ) {
                var pp = this.parameterPositions;
                var i1 = this._cachedIndex,
                    t1 = pp[ i1 ],
                    t0 = pp[ i1 - 1 ];
                validate_interval: {
                    seek: {
                        var right;linear_scan: { //- See http://jsperf.com/comparison-to-undefined/3
                            //- slower code:
                            //-
                            //- 				if ( t >= t1 || t1 === undefined ) {
                            forward_scan: if ( !( t < t1 ) ) {
                                for ( var giveUpAt = i1 + 2;; ) {
                                    if ( t1 === undefined ) {
                                        if ( t < t0 ) break forward_scan; // after end
                                        i1 = pp.length;
                                        this._cachedIndex = i1;
                                        return this.copySampleValue_( i1 - 1 );
                                    }
                                    if ( i1 === giveUpAt ) break; // this loop
                                    t0 = t1;
                                    t1 = pp[ ++i1 ];
                                    if ( t < t1 ) { // we have arrived at the sought interval
                                        break seek;
                                    }
                                } // prepare binary search on the right side of the index
                                right = pp.length;
                                break linear_scan;
                            } //- slower code:
                            //-					if ( t < t0 || t0 === undefined ) {
                            if ( !( t >= t0 ) ) { // looping?
                                var t1global = pp[ 1 ];
                                if ( t < t1global ) {
                                    i1 = 2; // + 1, using the scan for the details
                                    t0 = t1global;
                                } // linear reverse scan
                                for ( var _giveUpAt = i1 - 2;; ) {
                                    if ( t0 === undefined ) { // before start
                                        this._cachedIndex = 0;
                                        return this.copySampleValue_( 0 );
                                    }
                                    if ( i1 === _giveUpAt ) break; // this loop
                                    t1 = t0;
                                    t0 = pp[ --i1 - 1 ];
                                    if ( t >= t0 ) { // we have arrived at the sought interval
                                        break seek;
                                    }
                                } // prepare binary search on the left side of the index
                                right = i1;
                                i1 = 0;
                                break linear_scan;
                            } // the interval is valid
                            break validate_interval;
                        } // linear scan
                        // binary search
                        while ( i1 < right ) {
                            var mid = i1 + right >>> 1;
                            if ( t < pp[ mid ] ) {
                                right = mid;
                            } else {
                                i1 = mid + 1;
                            }
                        }
                        t1 = pp[ i1 ];t0 = pp[ i1 - 1 ]; // check boundary cases, again
                        if ( t0 === undefined ) {
                            this._cachedIndex = 0;
                            return this.copySampleValue_( 0 );
                        }
                        if ( t1 === undefined ) {
                            i1 = pp.length;
                            this._cachedIndex = i1;
                            return this.copySampleValue_( i1 - 1 );
                        }
                    } // seek
                    this._cachedIndex = i1;this.intervalChanged_( i1, t0, t1 );
                } // validate_interval
                return this.interpolate_( i1, t0, t, t1 );
            }
        }, {
            key: "getSettings_",
            value: function getSettings_( ) {
                return this.settings || this.DefaultSettings_;
            }
        }, {
            key: "copySampleValue_",
            value: function copySampleValue_( index ) { // copies a sample value to the result buffer
                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,
                    offset = index * stride;
                for ( var _i194 = 0; _i194 !== stride; ++_i194 ) {
                    result[ _i194 ] = values[ offset + _i194 ];
                }
                return result;
            } // Template methods for derived classes:
        }, {
            key: "interpolate_",
            value: function /* i1, t0, t, t1 */ interpolate_( ) {
                throw new Error( 'call to abstract method' ); // implementations shall return this.resultBuffer
            }
        }, {
            key: "intervalChanged_",
            value: function /* i1, t0, t1 */ intervalChanged_( ) { // empty
            }
        } ] );
        return Interpolant;
    }( );
    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     */
    var CubicInterpolant = /*#__PURE__*/ function( _Interpolant ) {
        _inherits( CubicInterpolant, _Interpolant );
        var _super44 = _createSuper( CubicInterpolant );

        function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            var _this41;
            _classCallCheck( this, CubicInterpolant );
            _this41 = _super44.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
            _this41._weightPrev = -0;
            _this41._offsetPrev = -0;
            _this41._weightNext = -0;
            _this41._offsetNext = -0;
            _this41.DefaultSettings_ = {
                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding
            };
            return _this41;
        }
        _createClass( CubicInterpolant, [ {
            key: "intervalChanged_",
            value: function intervalChanged_( i1, t0, t1 ) {
                var pp = this.parameterPositions;
                var iPrev = i1 - 2,
                    iNext = i1 + 1,
                    tPrev = pp[ iPrev ],
                    tNext = pp[ iNext ];
                if ( tPrev === undefined ) {
                    switch ( this.getSettings_( ).endingStart ) {
                        case ZeroSlopeEnding: // f'(t0) = 0
                            iPrev = i1;
                            tPrev = 2 * t0 - t1;
                            break;
                        case WrapAroundEnding: // use the other end of the curve
                            iPrev = pp.length - 2;
                            tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
                            break;
                        default: // ZeroCurvatureEnding
                            // f''(t0) = 0 a.k.a. Natural Spline
                            iPrev = i1;
                            tPrev = t1;
                    }
                }
                if ( tNext === undefined ) {
                    switch ( this.getSettings_( ).endingEnd ) {
                        case ZeroSlopeEnding: // f'(tN) = 0
                            iNext = i1;
                            tNext = 2 * t1 - t0;
                            break;
                        case WrapAroundEnding: // use the other end of the curve
                            iNext = 1;
                            tNext = t1 + pp[ 1 ] - pp[ 0 ];
                            break;
                        default: // ZeroCurvatureEnding
                            // f''(tN) = 0, a.k.a. Natural Spline
                            iNext = i1 - 1;
                            tNext = t0;
                    }
                }
                var halfDt = ( t1 - t0 ) * 0.5,
                    stride = this.valueSize;
                this._weightPrev = halfDt / ( t0 - tPrev );
                this._weightNext = halfDt / ( tNext - t1 );
                this._offsetPrev = iPrev * stride;
                this._offsetNext = iNext * stride;
            }
        }, {
            key: "interpolate_",
            value: function interpolate_( i1, t0, t, t1 ) {
                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,
                    o1 = i1 * stride,
                    o0 = o1 - stride,
                    oP = this._offsetPrev,
                    oN = this._offsetNext,
                    wP = this._weightPrev,
                    wN = this._weightNext,
                    p = ( t - t0 ) / ( t1 - t0 ),
                    pp = p * p,
                    ppp = pp * p; // evaluate polynomials
                var sP = -wP * ppp + 2 * wP * pp - wP * p;
                var s0 = ( 1 + wP ) * ppp + ( -1.5 - 2 * wP ) * pp + ( -0.5 + wP ) * p + 1;
                var s1 = ( -1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
                var sN = wN * ppp - wN * pp; // combine data linearly
                for ( var _i195 = 0; _i195 !== stride; ++_i195 ) {
                    result[ _i195 ] = sP * values[ oP + _i195 ] + s0 * values[ o0 + _i195 ] + s1 * values[ o1 + _i195 ] + sN * values[ oN + _i195 ];
                }
                return result;
            }
        } ] );
        return CubicInterpolant;
    }( Interpolant );
    var LinearInterpolant = /*#__PURE__*/ function( _Interpolant2 ) {
        _inherits( LinearInterpolant, _Interpolant2 );
        var _super45 = _createSuper( LinearInterpolant );

        function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            _classCallCheck( this, LinearInterpolant );
            return _super45.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
        }
        _createClass( LinearInterpolant, [ {
            key: "interpolate_",
            value: function interpolate_( i1, t0, t, t1 ) {
                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,
                    offset1 = i1 * stride,
                    offset0 = offset1 - stride,
                    weight1 = ( t - t0 ) / ( t1 - t0 ),
                    weight0 = 1 - weight1;
                for ( var _i196 = 0; _i196 !== stride; ++_i196 ) {
                    result[ _i196 ] = values[ offset0 + _i196 ] * weight0 + values[ offset1 + _i196 ] * weight1;
                }
                return result;
            }
        } ] );
        return LinearInterpolant;
    }( Interpolant );
    /**
     *
     * Interpolant that evaluates to the sample value at the position preceding
     * the parameter.
     */
    var DiscreteInterpolant = /*#__PURE__*/ function( _Interpolant3 ) {
        _inherits( DiscreteInterpolant, _Interpolant3 );
        var _super46 = _createSuper( DiscreteInterpolant );

        function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            _classCallCheck( this, DiscreteInterpolant );
            return _super46.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
        }
        _createClass( DiscreteInterpolant, [ {
            key: "interpolate_",
            value: function interpolate_( i1 /*, t0, t, t1 */ ) {
                return this.copySampleValue_( i1 - 1 );
            }
        } ] );
        return DiscreteInterpolant;
    }( Interpolant );
    var KeyframeTrack = /*#__PURE__*/ function( ) {
        function KeyframeTrack( name, times, values, interpolation ) {
            _classCallCheck( this, KeyframeTrack );
            if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
            if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );
            this.name = name;
            this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
            this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
            this.setInterpolation( interpolation || this.DefaultInterpolation );
        } // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):
        _createClass( KeyframeTrack, [ {
            key: "InterpolantFactoryMethodDiscrete",
            value: function InterpolantFactoryMethodDiscrete( result ) {
                return new DiscreteInterpolant( this.times, this.values, this.getValueSize( ), result );
            }
        }, {
            key: "InterpolantFactoryMethodLinear",
            value: function InterpolantFactoryMethodLinear( result ) {
                return new LinearInterpolant( this.times, this.values, this.getValueSize( ), result );
            }
        }, {
            key: "InterpolantFactoryMethodSmooth",
            value: function InterpolantFactoryMethodSmooth( result ) {
                return new CubicInterpolant( this.times, this.values, this.getValueSize( ), result );
            }
        }, {
            key: "setInterpolation",
            value: function setInterpolation( interpolation ) {
                var factoryMethod;
                switch ( interpolation ) {
                    case InterpolateDiscrete:
                        factoryMethod = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case InterpolateLinear:
                        factoryMethod = this.InterpolantFactoryMethodLinear;
                        break;
                    case InterpolateSmooth:
                        factoryMethod = this.InterpolantFactoryMethodSmooth;
                        break;
                }
                if ( factoryMethod === undefined ) {
                    var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                    if ( this.createInterpolant === undefined ) { // fall back to default, unless the default itself is messed up
                        if ( interpolation !== this.DefaultInterpolation ) {
                            this.setInterpolation( this.DefaultInterpolation );
                        } else {
                            throw new Error( message ); // fatal, in this case
                        }
                    }
                    console.warn( 'THREE.KeyframeTrack:', message );
                    return this;
                }
                this.createInterpolant = factoryMethod;
                return this;
            }
        }, {
            key: "getInterpolation",
            value: function getInterpolation( ) {
                switch ( this.createInterpolant ) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return InterpolateDiscrete;
                    case this.InterpolantFactoryMethodLinear:
                        return InterpolateLinear;
                    case this.InterpolantFactoryMethodSmooth:
                        return InterpolateSmooth;
                }
            }
        }, {
            key: "getValueSize",
            value: function getValueSize( ) {
                return this.values.length / this.times.length;
            } // move all keyframes either forwards or backwards in time
        }, {
            key: "shift",
            value: function shift( timeOffset ) {
                if ( timeOffset !== 0.0 ) {
                    var times = this.times;
                    for ( var _i197 = 0, n = times.length; _i197 !== n; ++_i197 ) {
                        times[ _i197 ] += timeOffset;
                    }
                }
                return this;
            } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        }, {
            key: "scale",
            value: function scale( timeScale ) {
                if ( timeScale !== 1.0 ) {
                    var times = this.times;
                    for ( var _i198 = 0, n = times.length; _i198 !== n; ++_i198 ) {
                        times[ _i198 ] *= timeScale;
                    }
                }
                return this;
            } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
            // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        }, {
            key: "trim",
            value: function trim( startTime, endTime ) {
                var times = this.times,
                    nKeys = times.length;
                var from = 0,
                    to = nKeys - 1;
                while ( from !== nKeys && times[ from ] < startTime ) {
                    ++from;
                }
                while ( to !== -1 && times[ to ] > endTime ) {
                    --to;
                }++to; // inclusive -> exclusive bound
                if ( from !== 0 || to !== nKeys ) { // empty tracks are forbidden, so keep at least one keyframe
                    if ( from >= to ) {
                        to = Math.max( to, 1 );
                        from = to - 1;
                    }
                    var stride = this.getValueSize( );
                    this.times = AnimationUtils.arraySlice( times, from, to );
                    this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );
                }
                return this;
            } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        }, {
            key: "validate",
            value: function validate( ) {
                var valid = true;
                var valueSize = this.getValueSize( );
                if ( valueSize - Math.floor( valueSize ) !== 0 ) {
                    console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
                    valid = false;
                }
                var times = this.times,
                    values = this.values,
                    nKeys = times.length;
                if ( nKeys === 0 ) {
                    console.error( 'THREE.KeyframeTrack: Track is empty.', this );
                    valid = false;
                }
                var prevTime = null;
                for ( var _i199 = 0; _i199 !== nKeys; _i199++ ) {
                    var currTime = times[ _i199 ];
                    if ( typeof currTime === 'number' && isNaN( currTime ) ) {
                        console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, _i199, currTime );
                        valid = false;
                        break;
                    }
                    if ( prevTime !== null && prevTime > currTime ) {
                        console.error( 'THREE.KeyframeTrack: Out of order keys.', this, _i199, currTime, prevTime );
                        valid = false;
                        break;
                    }
                    prevTime = currTime;
                }
                if ( values !== undefined ) {
                    if ( AnimationUtils.isTypedArray( values ) ) {
                        for ( var _i200 = 0, n = values.length; _i200 !== n; ++_i200 ) {
                            var _value5 = values[ _i200 ];
                            if ( isNaN( _value5 ) ) {
                                console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, _i200, _value5 );
                                valid = false;
                                break;
                            }
                        }
                    }
                }
                return valid;
            } // removes equivalent sequential keys as common in morph target sequences
            // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        }, {
            key: "optimize",
            value: function optimize( ) { // times or values may be shared with other tracks, so overwriting is unsafe
                var times = AnimationUtils.arraySlice( this.times ),
                    values = AnimationUtils.arraySlice( this.values ),
                    stride = this.getValueSize( ),
                    smoothInterpolation = this.getInterpolation( ) === InterpolateSmooth,
                    lastIndex = times.length - 1;
                var writeIndex = 1;
                for ( var _i201 = 1; _i201 < lastIndex; ++_i201 ) {
                    var keep = false;
                    var time = times[ _i201 ];
                    var timeNext = times[ _i201 + 1 ]; // remove adjacent keyframes scheduled at the same time
                    if ( time !== timeNext && ( _i201 !== 1 || time !== times[ 0 ] ) ) {
                        if ( !smoothInterpolation ) { // remove unnecessary keyframes same as their neighbors
                            var offset = _i201 * stride,
                                offsetP = offset - stride,
                                offsetN = offset + stride;
                            for ( var j = 0; j !== stride; ++j ) {
                                var _value6 = values[ offset + j ];
                                if ( _value6 !== values[ offsetP + j ] || _value6 !== values[ offsetN + j ] ) {
                                    keep = true;
                                    break;
                                }
                            }
                        } else {
                            keep = true;
                        }
                    } // in-place compaction
                    if ( keep ) {
                        if ( _i201 !== writeIndex ) {
                            times[ writeIndex ] = times[ _i201 ];
                            var readOffset = _i201 * stride,
                                writeOffset = writeIndex * stride;
                            for ( var _j5 = 0; _j5 !== stride; ++_j5 ) {
                                values[ writeOffset + _j5 ] = values[ readOffset + _j5 ];
                            }
                        }++writeIndex;
                    }
                } // flush last keyframe (compaction looks ahead)
                if ( lastIndex > 0 ) {
                    times[ writeIndex ] = times[ lastIndex ];
                    for ( var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j6 = 0; _j6 !== stride; ++_j6 ) {
                        values[ _writeOffset + _j6 ] = values[ _readOffset + _j6 ];
                    }++writeIndex;
                }
                if ( writeIndex !== times.length ) {
                    this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
                    this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
                } else {
                    this.times = times;
                    this.values = values;
                }
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                var times = AnimationUtils.arraySlice( this.times, 0 );
                var values = AnimationUtils.arraySlice( this.values, 0 );
                var TypedKeyframeTrack = this.constructor;
                var track = new TypedKeyframeTrack( this.name, times, values ); // Interpolant argument to constructor is not saved, so copy the factory method directly.
                track.createInterpolant = this.createInterpolant;
                return track;
            }
        } ], [ {
            key: "toJSON",
            value: function toJSON( track ) {
                var trackType = track.constructor;
                var json; // derived classes can define a static toJSON method
                if ( trackType.toJSON !== this.toJSON ) {
                    json = trackType.toJSON( track );
                } else { // by default, we assume the data can be serialized as-is
                    json = {
                        'name': track.name,
                        'times': AnimationUtils.convertArray( track.times, Array ),
                        'values': AnimationUtils.convertArray( track.values, Array )
                    };
                    var interpolation = track.getInterpolation( );
                    if ( interpolation !== track.DefaultInterpolation ) {
                        json.interpolation = interpolation;
                    }
                }
                json.type = track.ValueTypeName; // mandatory
                return json;
            }
        } ] );
        return KeyframeTrack;
    }( );
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    /**
     * A Track of Boolean keyframe values.
     */
    var BooleanKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack ) {
        _inherits( BooleanKeyframeTrack, _KeyframeTrack );
        var _super47 = _createSuper( BooleanKeyframeTrack );

        function BooleanKeyframeTrack( ) {
            _classCallCheck( this, BooleanKeyframeTrack );
            return _super47.apply( this, arguments );
        }
        return _createClass( BooleanKeyframeTrack );
    }( KeyframeTrack );
    BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    /**
     * A Track of keyframe values that represent color.
     */
    var ColorKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack2 ) {
        _inherits( ColorKeyframeTrack, _KeyframeTrack2 );
        var _super48 = _createSuper( ColorKeyframeTrack );

        function ColorKeyframeTrack( ) {
            _classCallCheck( this, ColorKeyframeTrack );
            return _super48.apply( this, arguments );
        }
        return _createClass( ColorKeyframeTrack );
    }( KeyframeTrack );
    ColorKeyframeTrack.prototype.ValueTypeName = 'color';
    /**
     * A Track of numeric keyframe values.
     */
    var NumberKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack3 ) {
        _inherits( NumberKeyframeTrack, _KeyframeTrack3 );
        var _super49 = _createSuper( NumberKeyframeTrack );

        function NumberKeyframeTrack( ) {
            _classCallCheck( this, NumberKeyframeTrack );
            return _super49.apply( this, arguments );
        }
        return _createClass( NumberKeyframeTrack );
    }( KeyframeTrack );
    NumberKeyframeTrack.prototype.ValueTypeName = 'number';
    /**
     * Spherical linear unit quaternion interpolant.
     */
    var QuaternionLinearInterpolant = /*#__PURE__*/ function( _Interpolant4 ) {
        _inherits( QuaternionLinearInterpolant, _Interpolant4 );
        var _super50 = _createSuper( QuaternionLinearInterpolant );

        function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            _classCallCheck( this, QuaternionLinearInterpolant );
            return _super50.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
        }
        _createClass( QuaternionLinearInterpolant, [ {
            key: "interpolate_",
            value: function interpolate_( i1, t0, t, t1 ) {
                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,
                    alpha = ( t - t0 ) / ( t1 - t0 );
                var offset = i1 * stride;
                for ( var end = offset + stride; offset !== end; offset += 4 ) {
                    Quaternion$1.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );
                }
                return result;
            }
        } ] );
        return QuaternionLinearInterpolant;
    }( Interpolant );
    /**
     * A Track of quaternion keyframe values.
     */
    var QuaternionKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack4 ) {
        _inherits( QuaternionKeyframeTrack, _KeyframeTrack4 );
        var _super51 = _createSuper( QuaternionKeyframeTrack );

        function QuaternionKeyframeTrack( ) {
            _classCallCheck( this, QuaternionKeyframeTrack );
            return _super51.apply( this, arguments );
        }
        _createClass( QuaternionKeyframeTrack, [ {
            key: "InterpolantFactoryMethodLinear",
            value: function InterpolantFactoryMethodLinear( result ) {
                return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize( ), result );
            }
        } ] );
        return QuaternionKeyframeTrack;
    }( KeyframeTrack );
    QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited
    QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    /**
     * A Track that interpolates Strings
     */
    var StringKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack5 ) {
        _inherits( StringKeyframeTrack, _KeyframeTrack5 );
        var _super52 = _createSuper( StringKeyframeTrack );

        function StringKeyframeTrack( ) {
            _classCallCheck( this, StringKeyframeTrack );
            return _super52.apply( this, arguments );
        }
        return _createClass( StringKeyframeTrack );
    }( KeyframeTrack );
    StringKeyframeTrack.prototype.ValueTypeName = 'string';
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    /**
     * A Track of vectored keyframe values.
     */
    var VectorKeyframeTrack = /*#__PURE__*/ function( _KeyframeTrack6 ) {
        _inherits( VectorKeyframeTrack, _KeyframeTrack6 );
        var _super53 = _createSuper( VectorKeyframeTrack );

        function VectorKeyframeTrack( ) {
            _classCallCheck( this, VectorKeyframeTrack );
            return _super53.apply( this, arguments );
        }
        return _createClass( VectorKeyframeTrack );
    }( KeyframeTrack );
    VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
    var AnimationClip = /*#__PURE__*/ function( ) {
        function AnimationClip( name ) {
            var duration = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : -1;
            var tracks = arguments.length > 2 ? arguments[ 2 ] : undefined;
            var blendMode = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : NormalAnimationBlendMode;
            _classCallCheck( this, AnimationClip );
            this.name = name;
            this.tracks = tracks;
            this.duration = duration;
            this.blendMode = blendMode;
            this.uuid = generateUUID( ); // this means it should figure out its duration by scanning the tracks
            if ( this.duration < 0 ) {
                this.resetDuration( );
            }
        }
        _createClass( AnimationClip, [ {
            key: "resetDuration",
            value: function resetDuration( ) {
                var tracks = this.tracks;
                var duration = 0;
                for ( var _i202 = 0, n = tracks.length; _i202 !== n; ++_i202 ) {
                    var track = this.tracks[ _i202 ];
                    duration = Math.max( duration, track.times[ track.times.length - 1 ] );
                }
                this.duration = duration;
                return this;
            }
        }, {
            key: "trim",
            value: function trim( ) {
                for ( var _i203 = 0; _i203 < this.tracks.length; _i203++ ) {
                    this.tracks[ _i203 ].trim( 0, this.duration );
                }
                return this;
            }
        }, {
            key: "validate",
            value: function validate( ) {
                var valid = true;
                for ( var _i204 = 0; _i204 < this.tracks.length; _i204++ ) {
                    valid = valid && this.tracks[ _i204 ].validate( );
                }
                return valid;
            }
        }, {
            key: "optimize",
            value: function optimize( ) {
                for ( var _i205 = 0; _i205 < this.tracks.length; _i205++ ) {
                    this.tracks[ _i205 ].optimize( );
                }
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                var tracks = [ ];
                for ( var _i206 = 0; _i206 < this.tracks.length; _i206++ ) {
                    tracks.push( this.tracks[ _i206 ].clone( ) );
                }
                return new this.constructor( this.name, this.duration, tracks, this.blendMode );
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                return this.constructor.toJSON( this );
            }
        } ], [ {
            key: "parse",
            value: function parse( json ) {
                var tracks = [ ],
                    jsonTracks = json.tracks,
                    frameTime = 1.0 / ( json.fps || 1.0 );
                for ( var _i207 = 0, n = jsonTracks.length; _i207 !== n; ++_i207 ) {
                    tracks.push( parseKeyframeTrack( jsonTracks[ _i207 ] ).scale( frameTime ) );
                }
                var clip = new this( json.name, json.duration, tracks, json.blendMode );
                clip.uuid = json.uuid;
                return clip;
            }
        }, {
            key: "toJSON",
            value: function toJSON( clip ) {
                var tracks = [ ],
                    clipTracks = clip.tracks;
                var json = {
                    'name': clip.name,
                    'duration': clip.duration,
                    'tracks': tracks,
                    'uuid': clip.uuid,
                    'blendMode': clip.blendMode
                };
                for ( var _i208 = 0, n = clipTracks.length; _i208 !== n; ++_i208 ) {
                    tracks.push( KeyframeTrack.toJSON( clipTracks[ _i208 ] ) );
                }
                return json;
            }
        }, {
            key: "CreateFromMorphTargetSequence",
            value: function CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {
                var numMorphTargets = morphTargetSequence.length;
                var tracks = [ ];
                for ( var _i209 = 0; _i209 < numMorphTargets; _i209++ ) {
                    var times = [ ];
                    var values = [ ];
                    times.push( ( _i209 + numMorphTargets - 1 ) % numMorphTargets, _i209, ( _i209 + 1 ) % numMorphTargets );
                    values.push( 0, 1, 0 );
                    var order = AnimationUtils.getKeyframeOrder( times );
                    times = AnimationUtils.sortedArray( times, 1, order );
                    values = AnimationUtils.sortedArray( values, 1, order ); // if there is a key at the first frame, duplicate it as the
                    // last frame as well for perfect loop.
                    if ( !noLoop && times[ 0 ] === 0 ) {
                        times.push( numMorphTargets );
                        values.push( values[ 0 ] );
                    }
                    tracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[ _i209 ].name + ']', times, values ).scale( 1.0 / fps ) );
                }
                return new this( name, -1, tracks );
            }
        }, {
            key: "findByName",
            value: function findByName( objectOrClipArray, name ) {
                var clipArray = objectOrClipArray;
                if ( !Array.isArray( objectOrClipArray ) ) {
                    var o = objectOrClipArray;
                    clipArray = o.geometry && o.geometry.animations || o.animations;
                }
                for ( var _i210 = 0; _i210 < clipArray.length; _i210++ ) {
                    if ( clipArray[ _i210 ].name === name ) {
                        return clipArray[ _i210 ];
                    }
                }
                return null;
            }
        }, {
            key: "CreateClipsFromMorphTargetSequences",
            value: function CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {
                var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
                // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
                var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
                // patterns like Walk_001, Walk_002, Run_001, Run_002
                for ( var _i211 = 0, il = morphTargets.length; _i211 < il; _i211++ ) {
                    var morphTarget = morphTargets[ _i211 ];
                    var parts = morphTarget.name.match( pattern );
                    if ( parts && parts.length > 1 ) {
                        var name = parts[ 1 ];
                        var animationMorphTargets = animationToMorphTargets[ name ];
                        if ( !animationMorphTargets ) {
                            animationToMorphTargets[ name ] = animationMorphTargets = [ ];
                        }
                        animationMorphTargets.push( morphTarget );
                    }
                }
                var clips = [ ];
                for ( var _name4 in animationToMorphTargets ) {
                    clips.push( this.CreateFromMorphTargetSequence( _name4, animationToMorphTargets[ _name4 ], fps, noLoop ) );
                }
                return clips;
            } // parse the animation.hierarchy format
        }, {
            key: "parseAnimation",
            value: function parseAnimation( animation, bones ) {
                if ( !animation ) {
                    console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
                    return null;
                }
                var addNonemptyTrack = function addNonemptyTrack( trackType, trackName, animationKeys, propertyName, destTracks ) { // only return track if there are actually keys.
                    if ( animationKeys.length !== 0 ) {
                        var times = [ ];
                        var values = [ ];
                        AnimationUtils.flattenJSON( animationKeys, times, values, propertyName ); // empty keys are filtered out, so check again
                        if ( times.length !== 0 ) {
                            destTracks.push( new trackType( trackName, times, values ) );
                        }
                    }
                };
                var tracks = [ ];
                var clipName = animation.name || 'default';
                var fps = animation.fps || 30;
                var blendMode = animation.blendMode; // automatic length determination in AnimationClip.
                var duration = animation.length || -1;
                var hierarchyTracks = animation.hierarchy || [ ];
                for ( var h = 0; h < hierarchyTracks.length; h++ ) {
                    var animationKeys = hierarchyTracks[ h ].keys; // skip empty tracks
                    if ( !animationKeys || animationKeys.length === 0 ) continue; // process morph targets
                    if ( animationKeys[ 0 ].morphTargets ) { // figure out all morph targets used in this track
                        var morphTargetNames = {};
                        var k = void 0;
                        for ( k = 0; k < animationKeys.length; k++ ) {
                            if ( animationKeys[ k ].morphTargets ) {
                                for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m++ ) {
                                    morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = -1;
                                }
                            }
                        } // create a track for each morph target with all zero
                        // morphTargetInfluences except for the keys in which
                        // the morphTarget is named.
                        for ( var morphTargetName in morphTargetNames ) {
                            var times = [ ];
                            var values = [ ];
                            for ( var _m = 0; _m !== animationKeys[ k ].morphTargets.length; ++_m ) {
                                var animationKey = animationKeys[ k ];
                                times.push( animationKey.time );
                                values.push( animationKey.morphTarget === morphTargetName ? 1 : 0 );
                            }
                            tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
                        }
                        duration = morphTargetNames.length * fps;
                    } else { // ...assume skeletal animation
                        var boneName = '.bones[' + bones[ h ].name + ']';
                        addNonemptyTrack( VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks );
                        addNonemptyTrack( QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks );
                        addNonemptyTrack( VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks );
                    }
                }
                if ( tracks.length === 0 ) {
                    return null;
                }
                var clip = new this( clipName, duration, tracks, blendMode );
                return clip;
            }
        } ] );
        return AnimationClip;
    }( );

    function getTrackTypeForValueTypeName( typeName ) {
        switch ( typeName.toLowerCase( ) ) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
                return NumberKeyframeTrack;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
                return VectorKeyframeTrack;
            case 'color':
                return ColorKeyframeTrack;
            case 'quaternion':
                return QuaternionKeyframeTrack;
            case 'bool':
            case 'boolean':
                return BooleanKeyframeTrack;
            case 'string':
                return StringKeyframeTrack;
        }
        throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );
    }

    function parseKeyframeTrack( json ) {
        if ( json.type === undefined ) {
            throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );
        }
        var trackType = getTrackTypeForValueTypeName( json.type );
        if ( json.times === undefined ) {
            var times = [ ],
                values = [ ];
            AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
            json.times = times;
            json.values = values;
        } // derived classes can define a static parse method
        if ( trackType.parse !== undefined ) {
            return trackType.parse( json );
        } else { // by default, we assume a constructor compatible with the base
            return new trackType( json.name, json.times, json.values, json.interpolation );
        }
    }
    var Cache = {
        enabled: false,
        files: {},
        add: function add( key, file ) {
            if ( this.enabled === false ) return; // console.log( 'THREE.Cache', 'Adding key:', key );
            this.files[ key ] = file;
        },
        get: function get( key ) {
            if ( this.enabled === false ) return; // console.log( 'THREE.Cache', 'Checking key:', key );
            return this.files[ key ];
        },
        remove: function remove( key ) {
            delete this.files[ key ];
        },
        clear: function clear( ) {
            this.files = {};
        }
    };
    var LoadingManager = /*#__PURE__*/ _createClass( function LoadingManager( onLoad, onProgress, onError ) {
        _classCallCheck( this, LoadingManager );
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        var handlers = [ ]; // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function( url ) {
            itemsTotal++;
            if ( isLoading === false ) {
                if ( scope.onStart !== undefined ) {
                    scope.onStart( url, itemsLoaded, itemsTotal );
                }
            }
            isLoading = true;
        };
        this.itemEnd = function( url ) {
            itemsLoaded++;
            if ( scope.onProgress !== undefined ) {
                scope.onProgress( url, itemsLoaded, itemsTotal );
            }
            if ( itemsLoaded === itemsTotal ) {
                isLoading = false;
                if ( scope.onLoad !== undefined ) {
                    scope.onLoad( );
                }
            }
        };
        this.itemError = function( url ) {
            if ( scope.onError !== undefined ) {
                scope.onError( url );
            }
        };
        this.resolveURL = function( url ) {
            if ( urlModifier ) {
                return urlModifier( url );
            }
            return url;
        };
        this.setURLModifier = function( transform ) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function( regex, loader ) {
            handlers.push( regex, loader );
            return this;
        };
        this.removeHandler = function( regex ) {
            var index = handlers.indexOf( regex );
            if ( index !== -1 ) {
                handlers.splice( index, 2 );
            }
            return this;
        };
        this.getHandler = function( file ) {
            for ( var _i212 = 0, l = handlers.length; _i212 < l; _i212 += 2 ) {
                var regex = handlers[ _i212 ];
                var _loader = handlers[ _i212 + 1 ];
                if ( regex.global ) regex.lastIndex = 0; // see #17920
                if ( regex.test( file ) ) {
                    return _loader;
                }
            }
            return null;
        };
    } );
    var DefaultLoadingManager = new LoadingManager( );
    var Loader = /*#__PURE__*/ function( ) {
        function Loader( manager ) {
            _classCallCheck( this, Loader );
            this.manager = manager !== undefined ? manager : DefaultLoadingManager;
            this.crossOrigin = 'anonymous';
            this.withCredentials = false;
            this.path = '';
            this.resourcePath = '';
            this.requestHeader = {};
        }
        _createClass( Loader, [ {
            key: "load",
            value: function /* url, onLoad, onProgress, onError */ load( ) {}
        }, {
            key: "loadAsync",
            value: function loadAsync( url, onProgress ) {
                var scope = this;
                return new Promise( function( resolve, reject ) {
                    scope.load( url, resolve, onProgress, reject );
                } );
            }
        }, {
            key: "parse",
            value: function /* data */ parse( ) {}
        }, {
            key: "setCrossOrigin",
            value: function setCrossOrigin( crossOrigin ) {
                this.crossOrigin = crossOrigin;
                return this;
            }
        }, {
            key: "setWithCredentials",
            value: function setWithCredentials( value ) {
                this.withCredentials = value;
                return this;
            }
        }, {
            key: "setPath",
            value: function setPath( path ) {
                this.path = path;
                return this;
            }
        }, {
            key: "setResourcePath",
            value: function setResourcePath( resourcePath ) {
                this.resourcePath = resourcePath;
                return this;
            }
        }, {
            key: "setRequestHeader",
            value: function setRequestHeader( requestHeader ) {
                this.requestHeader = requestHeader;
                return this;
            }
        } ] );
        return Loader;
    }( );
    var loading = {};
    var FileLoader = /*#__PURE__*/ function( _Loader ) {
        _inherits( FileLoader, _Loader );
        var _super54 = _createSuper( FileLoader );

        function FileLoader( manager ) {
            _classCallCheck( this, FileLoader );
            return _super54.call( this, manager );
        }
        _createClass( FileLoader, [ {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                var _this42 = this;
                if ( url === undefined ) url = '';
                if ( this.path !== undefined ) url = this.path + url;
                url = this.manager.resolveURL( url );
                var cached = Cache.get( url );
                if ( cached !== undefined ) {
                    this.manager.itemStart( url );
                    setTimeout( function( ) {
                        if ( onLoad ) onLoad( cached );
                        _this42.manager.itemEnd( url );
                    }, 0 );
                    return cached;
                } // Check if request is duplicate
                if ( loading[ url ] !== undefined ) {
                    loading[ url ].push( {
                        onLoad: onLoad,
                        onProgress: onProgress,
                        onError: onError
                    } );
                    return;
                } // Initialise array for duplicate requests
                loading[ url ] = [ ];
                loading[ url ].push( {
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                } ); // create request
                var req = new Request( url, {
                    headers: new Headers( this.requestHeader ),
                    credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR
                } ); // record states ( avoid data race )
                var mimeType = this.mimeType;
                var responseType = this.responseType; // start the fetch
                fetch( req ).then( function( response ) {
                    if ( response.status === 200 || response.status === 0 ) { // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.
                        if ( response.status === 0 ) {
                            console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
                        } // Workaround: Checking if response.body === undefined for Alipay browser #23548
                        if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {
                            return response;
                        }
                        var callbacks = loading[ url ];
                        var reader = response.body.getReader( );
                        var contentLength = response.headers.get( 'Content-Length' );
                        var total = contentLength ? parseInt( contentLength ) : 0;
                        var lengthComputable = total !== 0;
                        var _loaded = 0; // periodically read data into the new stream tracking while download progress
                        var stream = new ReadableStream( {
                            start: function start( controller ) {
                                readData( );

                                function readData( ) {
                                    reader.read( ).then( function( _ref2 ) {
                                        var done = _ref2.done,
                                            value = _ref2.value;
                                        if ( done ) {
                                            controller.close( );
                                        } else {
                                            _loaded += value.byteLength;
                                            var event = new ProgressEvent( 'progress', {
                                                lengthComputable: lengthComputable,
                                                loaded: _loaded,
                                                total: total
                                            } );
                                            for ( var _i213 = 0, il = callbacks.length; _i213 < il; _i213++ ) {
                                                var callback = callbacks[ _i213 ];
                                                if ( callback.onProgress ) callback.onProgress( event );
                                            }
                                            controller.enqueue( value );
                                            readData( );
                                        }
                                    } );
                                }
                            }
                        } );
                        return new Response( stream );
                    } else {
                        throw Error( "fetch for \"".concat( response.url, "\" responded with " ).concat( response.status, ": " ).concat( response.statusText ) );
                    }
                } ).then( function( response ) {
                    switch ( responseType ) {
                        case 'arraybuffer':
                            return response.arrayBuffer( );
                        case 'blob':
                            return response.blob( );
                        case 'document':
                            return response.text( ).then( function( text ) {
                                var parser = new DOMParser( );
                                return parser.parseFromString( text, mimeType );
                            } );
                        case 'json':
                            return response.json( );
                        default:
                            if ( mimeType === undefined ) {
                                return response.text( );
                            } else { // sniff encoding
                                var re = /charset="?([^;"\s]*)"?/i;
                                var exec = re.exec( mimeType );
                                var label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase( ) : undefined;
                                var decoder = new TextDecoder( label );
                                return response.arrayBuffer( ).then( function( ab ) {
                                    return decoder.decode( ab );
                                } );
                            }
                    }
                } ).then( function( data ) { // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache.add( url, data );
                    var callbacks = loading[ url ];
                    delete loading[ url ];
                    for ( var _i214 = 0, il = callbacks.length; _i214 < il; _i214++ ) {
                        var callback = callbacks[ _i214 ];
                        if ( callback.onLoad ) callback.onLoad( data );
                    }
                } )[ "catch" ]( function( err ) { // Abort errors and other errors are handled the same
                    var callbacks = loading[ url ];
                    if ( callbacks === undefined ) { // When onLoad was called and url was deleted in `loading`
                        _this42.manager.itemError( url );
                        throw err;
                    }
                    delete loading[ url ];
                    for ( var _i215 = 0, il = callbacks.length; _i215 < il; _i215++ ) {
                        var callback = callbacks[ _i215 ];
                        if ( callback.onError ) callback.onError( err );
                    }
                    _this42.manager.itemError( url );
                } )[ "finally" ]( function( ) {
                    _this42.manager.itemEnd( url );
                } );
                this.manager.itemStart( url );
            }
        }, {
            key: "setResponseType",
            value: function setResponseType( value ) {
                this.responseType = value;
                return this;
            }
        }, {
            key: "setMimeType",
            value: function setMimeType( value ) {
                this.mimeType = value;
                return this;
            }
        } ] );
        return FileLoader;
    }( Loader );
    var ImageLoader = /*#__PURE__*/ function( _Loader2 ) {
        _inherits( ImageLoader, _Loader2 );
        var _super55 = _createSuper( ImageLoader );

        function ImageLoader( manager ) {
            _classCallCheck( this, ImageLoader );
            return _super55.call( this, manager );
        }
        _createClass( ImageLoader, [ {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                if ( this.path !== undefined ) url = this.path + url;
                url = this.manager.resolveURL( url );
                var scope = this;
                var cached = Cache.get( url );
                if ( cached !== undefined ) {
                    scope.manager.itemStart( url );
                    setTimeout( function( ) {
                        if ( onLoad ) onLoad( cached );
                        scope.manager.itemEnd( url );
                    }, 0 );
                    return cached;
                }
                var image = createElementNS( 'img' );

                function onImageLoad( ) {
                    removeEventListeners( );
                    Cache.add( url, this );
                    if ( onLoad ) onLoad( this );
                    scope.manager.itemEnd( url );
                }

                function onImageError( event ) {
                    removeEventListeners( );
                    if ( onError ) onError( event );
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
                }

                function removeEventListeners( ) {
                    image.removeEventListener( 'load', onImageLoad, false );
                    image.removeEventListener( 'error', onImageError, false );
                }
                image.addEventListener( 'load', onImageLoad, false );
                image.addEventListener( 'error', onImageError, false );
                if ( url.slice( 0, 5 ) !== 'data:' ) {
                    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
                }
                scope.manager.itemStart( url );
                image.src = url;
                return image;
            }
        } ] );
        return ImageLoader;
    }( Loader );
    /**
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     *
     * Sub classes have to implement the parse() method which will be used in load().
     */
    var DataTextureLoader = /*#__PURE__*/ function( _Loader3 ) {
        _inherits( DataTextureLoader, _Loader3 );
        var _super56 = _createSuper( DataTextureLoader );

        function DataTextureLoader( manager ) {
            _classCallCheck( this, DataTextureLoader );
            return _super56.call( this, manager );
        }
        _createClass( DataTextureLoader, [ {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                var scope = this;
                var texture = new DataTexture( );
                var loader = new FileLoader( this.manager );
                loader.setResponseType( 'arraybuffer' );
                loader.setRequestHeader( this.requestHeader );
                loader.setPath( this.path );
                loader.setWithCredentials( scope.withCredentials );
                loader.load( url, function( buffer ) {
                    var texData = scope.parse( buffer );
                    if ( !texData ) return;
                    if ( texData.image !== undefined ) {
                        texture.image = texData.image;
                    } else if ( texData.data !== undefined ) {
                        texture.image.width = texData.width;
                        texture.image.height = texData.height;
                        texture.image.data = texData.data;
                    }
                    texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                    texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                    texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                    texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                    texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                    if ( texData.encoding !== undefined ) {
                        texture.encoding = texData.encoding;
                    }
                    if ( texData.flipY !== undefined ) {
                        texture.flipY = texData.flipY;
                    }
                    if ( texData.format !== undefined ) {
                        texture.format = texData.format;
                    }
                    if ( texData.type !== undefined ) {
                        texture.type = texData.type;
                    }
                    if ( texData.mipmaps !== undefined ) {
                        texture.mipmaps = texData.mipmaps;
                        texture.minFilter = LinearMipmapLinearFilter; // presumably...
                    }
                    if ( texData.mipmapCount === 1 ) {
                        texture.minFilter = LinearFilter;
                    }
                    if ( texData.generateMipmaps !== undefined ) {
                        texture.generateMipmaps = texData.generateMipmaps;
                    }
                    texture.needsUpdate = true;
                    if ( onLoad ) onLoad( texture, texData );
                }, onProgress, onError );
                return texture;
            }
        } ] );
        return DataTextureLoader;
    }( Loader );
    var TextureLoader = /*#__PURE__*/ function( _Loader4 ) {
        _inherits( TextureLoader, _Loader4 );
        var _super57 = _createSuper( TextureLoader );

        function TextureLoader( manager ) {
            _classCallCheck( this, TextureLoader );
            return _super57.call( this, manager );
        }
        _createClass( TextureLoader, [ {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                var texture = new Texture( );
                var loader = new ImageLoader( this.manager );
                loader.setCrossOrigin( this.crossOrigin );
                loader.setPath( this.path );
                loader.load( url, function( image ) {
                    texture.image = image;
                    texture.needsUpdate = true;
                    if ( onLoad !== undefined ) {
                        onLoad( texture );
                    }
                }, onProgress, onError );
                return texture;
            }
        } ] );
        return TextureLoader;
    }( Loader );
    var Light = /*#__PURE__*/ function( _Object3D9 ) {
        _inherits( Light, _Object3D9 );
        var _super58 = _createSuper( Light );

        function Light( color ) {
            var _this43;
            var intensity = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 1;
            _classCallCheck( this, Light );
            _this43 = _super58.call( this );
            _this43.isLight = true;
            _this43.type = 'Light';
            _this43.color = new Color( color );
            _this43.intensity = intensity;
            return _this43;
        }
        _createClass( Light, [ {
            key: "dispose",
            value: function dispose( ) { // Empty here in base class; some subclasses override.
            }
        }, {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( Light.prototype ), "copy", this ).call( this, source, recursive );
                this.color.copy( source.color );
                this.intensity = source.intensity;
                return this;
            }
        }, {
            key: "toJSON",
            value: function toJSON( meta ) {
                var data = _get( _getPrototypeOf( Light.prototype ), "toJSON", this ).call( this, meta );
                data.object.color = this.color.getHex( );
                data.object.intensity = this.intensity;
                if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex( );
                if ( this.distance !== undefined ) data.object.distance = this.distance;
                if ( this.angle !== undefined ) data.object.angle = this.angle;
                if ( this.decay !== undefined ) data.object.decay = this.decay;
                if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
                if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON( );
                return data;
            }
        } ] );
        return Light;
    }( Object3D );
    var _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4( );
    var _lightPositionWorld$1 = /*@__PURE__*/ new Vector3( );
    var _lookTarget$1 = /*@__PURE__*/ new Vector3( );
    var LightShadow = /*#__PURE__*/ function( ) {
        function LightShadow( camera ) {
            _classCallCheck( this, LightShadow );
            this.camera = camera;
            this.bias = 0;
            this.normalBias = 0;
            this.radius = 1;
            this.blurSamples = 8;
            this.mapSize = new Vector2( 512, 512 );
            this.map = null;
            this.mapPass = null;
            this.matrix = new Matrix4( );
            this.autoUpdate = true;
            this.needsUpdate = false;
            this._frustum = new Frustum( );
            this._frameExtents = new Vector2( 1, 1 );
            this._viewportCount = 1;
            this._viewports = [ new Vector4( 0, 0, 1, 1 ) ];
        }
        _createClass( LightShadow, [ {
            key: "getViewportCount",
            value: function getViewportCount( ) {
                return this._viewportCount;
            }
        }, {
            key: "getFrustum",
            value: function getFrustum( ) {
                return this._frustum;
            }
        }, {
            key: "updateMatrices",
            value: function updateMatrices( light ) {
                var shadowCamera = this.camera;
                var shadowMatrix = this.matrix;
                _lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
                shadowCamera.position.copy( _lightPositionWorld$1 );
                _lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
                shadowCamera.lookAt( _lookTarget$1 );
                shadowCamera.updateMatrixWorld( );
                _projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
                this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );
                shadowMatrix.set( 0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0 );
                shadowMatrix.multiply( shadowCamera.projectionMatrix );
                shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
            }
        }, {
            key: "getViewport",
            value: function getViewport( viewportIndex ) {
                return this._viewports[ viewportIndex ];
            }
        }, {
            key: "getFrameExtents",
            value: function getFrameExtents( ) {
                return this._frameExtents;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                if ( this.map ) {
                    this.map.dispose( );
                }
                if ( this.mapPass ) {
                    this.mapPass.dispose( );
                }
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                this.camera = source.camera.clone( );
                this.bias = source.bias;
                this.radius = source.radius;
                this.mapSize.copy( source.mapSize );
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new this.constructor( ).copy( this );
            }
        }, {
            key: "toJSON",
            value: function toJSON( ) {
                var object = {};
                if ( this.bias !== 0 ) object.bias = this.bias;
                if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
                if ( this.radius !== 1 ) object.radius = this.radius;
                if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray( );
                object.camera = this.camera.toJSON( false ).object;
                delete object.camera.matrix;
                return object;
            }
        } ] );
        return LightShadow;
    }( );
    var SpotLightShadow = /*#__PURE__*/ function( _LightShadow ) {
        _inherits( SpotLightShadow, _LightShadow );
        var _super59 = _createSuper( SpotLightShadow );

        function SpotLightShadow( ) {
            var _this44;
            _classCallCheck( this, SpotLightShadow );
            _this44 = _super59.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
            _this44.isSpotLightShadow = true;
            _this44.focus = 1;
            return _this44;
        }
        _createClass( SpotLightShadow, [ {
            key: "updateMatrices",
            value: function updateMatrices( light ) {
                var camera = this.camera;
                var fov = RAD2DEG * 2 * light.angle * this.focus;
                var aspect = this.mapSize.width / this.mapSize.height;
                var far = light.distance || camera.far;
                if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
                    camera.fov = fov;
                    camera.aspect = aspect;
                    camera.far = far;
                    camera.updateProjectionMatrix( );
                }
                _get( _getPrototypeOf( SpotLightShadow.prototype ), "updateMatrices", this ).call( this, light );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( SpotLightShadow.prototype ), "copy", this ).call( this, source );
                this.focus = source.focus;
                return this;
            }
        } ] );
        return SpotLightShadow;
    }( LightShadow );
    var SpotLight = /*#__PURE__*/ function( _Light ) {
        _inherits( SpotLight, _Light );
        var _super60 = _createSuper( SpotLight );

        function SpotLight( color, intensity ) {
            var _this45;
            var distance = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var angle = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : Math.PI / 3;
            var penumbra = arguments.length > 4 && arguments[ 4 ] !== undefined ? arguments[ 4 ] : 0;
            var decay = arguments.length > 5 && arguments[ 5 ] !== undefined ? arguments[ 5 ] : 1;
            _classCallCheck( this, SpotLight );
            _this45 = _super60.call( this, color, intensity );
            _this45.isSpotLight = true;
            _this45.type = 'SpotLight';
            _this45.position.copy( Object3D.DefaultUp );
            _this45.updateMatrix( );
            _this45.target = new Object3D( );
            _this45.distance = distance;
            _this45.angle = angle;
            _this45.penumbra = penumbra;
            _this45.decay = decay; // for physically correct lights, should be 2.
            _this45.shadow = new SpotLightShadow( );
            return _this45;
        }
        _createClass( SpotLight, [ {
            key: "power",
            get: function get( ) { // compute the light's luminous power (in lumens) from its intensity (in candela)
                // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
                return this.intensity * Math.PI;
            },
            set: function set( power ) { // set the light's intensity (in candela) from the desired luminous power (in lumens)
                this.intensity = power / Math.PI;
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.shadow.dispose( );
            }
        }, {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( SpotLight.prototype ), "copy", this ).call( this, source, recursive );
                this.distance = source.distance;
                this.angle = source.angle;
                this.penumbra = source.penumbra;
                this.decay = source.decay;
                this.target = source.target.clone( );
                this.shadow = source.shadow.clone( );
                return this;
            }
        } ] );
        return SpotLight;
    }( Light );
    var _projScreenMatrix = /*@__PURE__*/ new Matrix4( );
    var _lightPositionWorld = /*@__PURE__*/ new Vector3( );
    var _lookTarget = /*@__PURE__*/ new Vector3( );
    var PointLightShadow = /*#__PURE__*/ function( _LightShadow2 ) {
        _inherits( PointLightShadow, _LightShadow2 );
        var _super61 = _createSuper( PointLightShadow );

        function PointLightShadow( ) {
            var _this46;
            _classCallCheck( this, PointLightShadow );
            _this46 = _super61.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );
            _this46.isPointLightShadow = true;
            _this46._frameExtents = new Vector2( 4, 2 );
            _this46._viewportCount = 6;
            _this46._viewports = [ // These viewports map a cube-map onto a 2D texture with the
                // following orientation:
                //
                //  xzXZ
                //   y Y
                //
                // X - Positive x direction
                // x - Negative x direction
                // Y - Positive y direction
                // y - Negative y direction
                // Z - Positive z direction
                // z - Negative z direction
                // positive X
                new Vector4( 2, 1, 1, 1 ), // negative X
                new Vector4( 0, 1, 1, 1 ), // positive Z
                new Vector4( 3, 1, 1, 1 ), // negative Z
                new Vector4( 1, 1, 1, 1 ), // positive Y
                new Vector4( 3, 0, 1, 1 ), // negative Y
                new Vector4( 1, 0, 1, 1 )
            ];
            _this46._cubeDirections = [ new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 ) ];
            _this46._cubeUps = [ new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, -1 ) ];
            return _this46;
        }
        _createClass( PointLightShadow, [ {
            key: "updateMatrices",
            value: function updateMatrices( light ) {
                var viewportIndex = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;
                var camera = this.camera;
                var shadowMatrix = this.matrix;
                var far = light.distance || camera.far;
                if ( far !== camera.far ) {
                    camera.far = far;
                    camera.updateProjectionMatrix( );
                }
                _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
                camera.position.copy( _lightPositionWorld );
                _lookTarget.copy( camera.position );
                _lookTarget.add( this._cubeDirections[ viewportIndex ] );
                camera.up.copy( this._cubeUps[ viewportIndex ] );
                camera.lookAt( _lookTarget );
                camera.updateMatrixWorld( );
                shadowMatrix.makeTranslation( -_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z );
                _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
                this._frustum.setFromProjectionMatrix( _projScreenMatrix );
            }
        } ] );
        return PointLightShadow;
    }( LightShadow );
    var PointLight = /*#__PURE__*/ function( _Light2 ) {
        _inherits( PointLight, _Light2 );
        var _super62 = _createSuper( PointLight );

        function PointLight( color, intensity ) {
            var _this47;
            var distance = arguments.length > 2 && arguments[ 2 ] !== undefined ? arguments[ 2 ] : 0;
            var decay = arguments.length > 3 && arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1;
            _classCallCheck( this, PointLight );
            _this47 = _super62.call( this, color, intensity );
            _this47.isPointLight = true;
            _this47.type = 'PointLight';
            _this47.distance = distance;
            _this47.decay = decay; // for physically correct lights, should be 2.
            _this47.shadow = new PointLightShadow( );
            return _this47;
        }
        _createClass( PointLight, [ {
            key: "power",
            get: function get( ) { // compute the light's luminous power (in lumens) from its intensity (in candela)
                // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
                return this.intensity * 4 * Math.PI;
            },
            set: function set( power ) { // set the light's intensity (in candela) from the desired luminous power (in lumens)
                this.intensity = power / ( 4 * Math.PI );
            }
        }, {
            key: "dispose",
            value: function dispose( ) {
                this.shadow.dispose( );
            }
        }, {
            key: "copy",
            value: function copy( source, recursive ) {
                _get( _getPrototypeOf( PointLight.prototype ), "copy", this ).call( this, source, recursive );
                this.distance = source.distance;
                this.decay = source.decay;
                this.shadow = source.shadow.clone( );
                return this;
            }
        } ] );
        return PointLight;
    }( Light );
    var DirectionalLightShadow = /*#__PURE__*/ function( _LightShadow3 ) {
        _inherits( DirectionalLightShadow, _LightShadow3 );
        var _super63 = _createSuper( DirectionalLightShadow );

        function DirectionalLightShadow( ) {
            var _this48;
            _classCallCheck( this, DirectionalLightShadow );
            _this48 = _super63.call( this, new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );
            _this48.isDirectionalLightShadow = true;
            return _this48;
        }
        return _createClass( DirectionalLightShadow );
    }( LightShadow );
    var DirectionalLight = /*#__PURE__*/ function( _Light3 ) {
        _inherits( DirectionalLight, _Light3 );
        var _super64 = _createSuper( DirectionalLight );

        function DirectionalLight( color, intensity ) {
            var _this49;
            _classCallCheck( this, DirectionalLight );
            _this49 = _super64.call( this, color, intensity );
            _this49.isDirectionalLight = true;
            _this49.type = 'DirectionalLight';
            _this49.position.copy( Object3D.DefaultUp );
            _this49.updateMatrix( );
            _this49.target = new Object3D( );
            _this49.shadow = new DirectionalLightShadow( );
            return _this49;
        }
        _createClass( DirectionalLight, [ {
            key: "dispose",
            value: function dispose( ) {
                this.shadow.dispose( );
            }
        }, {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( DirectionalLight.prototype ), "copy", this ).call( this, source );
                this.target = source.target.clone( );
                this.shadow = source.shadow.clone( );
                return this;
            }
        } ] );
        return DirectionalLight;
    }( Light );
    var LoaderUtils = /*#__PURE__*/ function( ) {
        function LoaderUtils( ) {
            _classCallCheck( this, LoaderUtils );
        }
        _createClass( LoaderUtils, null, [ {
            key: "decodeText",
            value: function decodeText( array ) {
                if ( typeof TextDecoder !== 'undefined' ) {
                    return new TextDecoder( ).decode( array );
                } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
                // throws a "maximum call stack size exceeded" error for large arrays.
                var s = '';
                for ( var _i216 = 0, il = array.length; _i216 < il; _i216++ ) { // Implicitly assumes little-endian.
                    s += String.fromCharCode( array[ _i216 ] );
                }
                try { // merges multi-byte utf-8 characters.
                    return decodeURIComponent( escape( s ) );
                } catch ( e ) { // see #16358
                    return s;
                }
            }
        }, {
            key: "extractUrlBase",
            value: function extractUrlBase( url ) {
                var index = url.lastIndexOf( '/' );
                if ( index === -1 ) return './';
                return url.slice( 0, index + 1 );
            }
        }, {
            key: "resolveURL",
            value: function resolveURL( url, path ) { // Invalid URL
                if ( typeof url !== 'string' || url === '' ) return ''; // Host Relative URL
                if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {
                    path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );
                } // Absolute URL http://,https://,//
                if ( /^(https?:)?\/\//i.test( url ) ) return url; // Data URI
                if ( /^data:.*,.*$/i.test( url ) ) return url; // Blob URL
                if ( /^blob:.*$/i.test( url ) ) return url; // Relative URL
                return path + url;
            }
        } ] );
        return LoaderUtils;
    }( );
    var ImageBitmapLoader = /*#__PURE__*/ function( _Loader5 ) {
        _inherits( ImageBitmapLoader, _Loader5 );
        var _super65 = _createSuper( ImageBitmapLoader );

        function ImageBitmapLoader( manager ) {
            var _this50;
            _classCallCheck( this, ImageBitmapLoader );
            _this50 = _super65.call( this, manager );
            _this50.isImageBitmapLoader = true;
            if ( typeof createImageBitmap === 'undefined' ) {
                console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );
            }
            if ( typeof fetch === 'undefined' ) {
                console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );
            }
            _this50.options = {
                premultiplyAlpha: 'none'
            };
            return _this50;
        }
        _createClass( ImageBitmapLoader, [ {
            key: "setOptions",
            value: function setOptions( options ) {
                this.options = options;
                return this;
            }
        }, {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                if ( url === undefined ) url = '';
                if ( this.path !== undefined ) url = this.path + url;
                url = this.manager.resolveURL( url );
                var scope = this;
                var cached = Cache.get( url );
                if ( cached !== undefined ) {
                    scope.manager.itemStart( url );
                    setTimeout( function( ) {
                        if ( onLoad ) onLoad( cached );
                        scope.manager.itemEnd( url );
                    }, 0 );
                    return cached;
                }
                var fetchOptions = {};
                fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
                fetchOptions.headers = this.requestHeader;
                fetch( url, fetchOptions ).then( function( res ) {
                    return res.blob( );
                } ).then( function( blob ) {
                    return createImageBitmap( blob, Object.assign( scope.options, {
                        colorSpaceConversion: 'none'
                    } ) );
                } ).then( function( imageBitmap ) {
                    Cache.add( url, imageBitmap );
                    if ( onLoad ) onLoad( imageBitmap );
                    scope.manager.itemEnd( url );
                } )[ "catch" ]( function( e ) {
                    if ( onError ) onError( e );
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
                } );
                scope.manager.itemStart( url );
            }
        } ] );
        return ImageBitmapLoader;
    }( Loader );
    var Clock = /*#__PURE__*/ function( ) {
        function Clock( ) {
            var autoStart = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : true;
            _classCallCheck( this, Clock );
            this.autoStart = autoStart;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }
        _createClass( Clock, [ {
            key: "start",
            value: function start( ) {
                this.startTime = now$2( );
                this.oldTime = this.startTime;
                this.elapsedTime = 0;
                this.running = true;
            }
        }, {
            key: "stop",
            value: function stop( ) {
                this.getElapsedTime( );
                this.running = false;
                this.autoStart = false;
            }
        }, {
            key: "getElapsedTime",
            value: function getElapsedTime( ) {
                this.getDelta( );
                return this.elapsedTime;
            }
        }, {
            key: "getDelta",
            value: function getDelta( ) {
                var diff = 0;
                if ( this.autoStart && !this.running ) {
                    this.start( );
                    return 0;
                }
                if ( this.running ) {
                    var newTime = now$2( );
                    diff = ( newTime - this.oldTime ) / 1000;
                    this.oldTime = newTime;
                    this.elapsedTime += diff;
                }
                return diff;
            }
        } ] );
        return Clock;
    }( );

    function now$2( ) {
        return ( typeof performance === 'undefined' ? Date : performance ).now( ); // see #10732
    } // Characters [].:/ are reserved for track binding syntax.
    var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' ); // Attempts to allow node names from any language. ES5's `\w` regexp matches
    // only latin characters, and the unicode \p{L} is not yet supported. So
    // instead, we exclude reserved characters and match everything else.
    var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
    var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
    // be matched to parse the rest of the track name.
    var _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar ); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
    var _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot ); // Object on target node, and accessor. May not contain reserved
    // characters. Accessor may contain any character except closing bracket.
    var _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar ); // Property and accessor. May not contain reserved characters. Accessor may
    // contain any non-bracket characters.
    var _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );
    var _trackRe = new RegExp( '' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$' );
    var _supportedObjectNames = [ 'material', 'materials', 'bones' ];
    var Composite = /*#__PURE__*/ function( ) {
        function Composite( targetGroup, path, optionalParsedPath ) {
            _classCallCheck( this, Composite );
            var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_( path, parsedPath );
        }
        _createClass( Composite, [ {
            key: "getValue",
            value: function getValue( array, offset ) {
                this.bind( ); // bind all binding
                var firstValidIndex = this._targetGroup.nCachedObjects_,
                    binding = this._bindings[ firstValidIndex ]; // and only call .getValue on the first
                if ( binding !== undefined ) binding.getValue( array, offset );
            }
        }, {
            key: "setValue",
            value: function setValue( array, offset ) {
                var bindings = this._bindings;
                for ( var _i217 = this._targetGroup.nCachedObjects_, n = bindings.length; _i217 !== n; ++_i217 ) {
                    bindings[ _i217 ].setValue( array, offset );
                }
            }
        }, {
            key: "bind",
            value: function bind( ) {
                var bindings = this._bindings;
                for ( var _i218 = this._targetGroup.nCachedObjects_, n = bindings.length; _i218 !== n; ++_i218 ) {
                    bindings[ _i218 ].bind( );
                }
            }
        }, {
            key: "unbind",
            value: function unbind( ) {
                var bindings = this._bindings;
                for ( var _i219 = this._targetGroup.nCachedObjects_, n = bindings.length; _i219 !== n; ++_i219 ) {
                    bindings[ _i219 ].unbind( );
                }
            }
        } ] );
        return Composite;
    }( ); // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
    var PropertyBinding = /*#__PURE__*/ function( ) {
        function PropertyBinding( rootNode, path, parsedPath ) {
            _classCallCheck( this, PropertyBinding );
            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
            this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
            this.rootNode = rootNode; // initial state of these methods that calls 'bind'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
        _createClass( PropertyBinding, [ {
            key: "_getValue_unavailable",
            value: // these are used to "bind" a nonexistent property
                function _getValue_unavailable( ) {}
        }, {
            key: "_setValue_unavailable",
            value: function _setValue_unavailable( ) {} // Getters
        }, {
            key: "_getValue_direct",
            value: function _getValue_direct( buffer, offset ) {
                buffer[ offset ] = this.targetObject[ this.propertyName ];
            }
        }, {
            key: "_getValue_array",
            value: function _getValue_array( buffer, offset ) {
                var source = this.resolvedProperty;
                for ( var _i220 = 0, n = source.length; _i220 !== n; ++_i220 ) {
                    buffer[ offset++ ] = source[ _i220 ];
                }
            }
        }, {
            key: "_getValue_arrayElement",
            value: function _getValue_arrayElement( buffer, offset ) {
                buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
            }
        }, {
            key: "_getValue_toArray",
            value: function _getValue_toArray( buffer, offset ) {
                this.resolvedProperty.toArray( buffer, offset );
            } // Direct
        }, {
            key: "_setValue_direct",
            value: function _setValue_direct( buffer, offset ) {
                this.targetObject[ this.propertyName ] = buffer[ offset ];
            }
        }, {
            key: "_setValue_direct_setNeedsUpdate",
            value: function _setValue_direct_setNeedsUpdate( buffer, offset ) {
                this.targetObject[ this.propertyName ] = buffer[ offset ];
                this.targetObject.needsUpdate = true;
            }
        }, {
            key: "_setValue_direct_setMatrixWorldNeedsUpdate",
            value: function _setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
                this.targetObject[ this.propertyName ] = buffer[ offset ];
                this.targetObject.matrixWorldNeedsUpdate = true;
            } // EntireArray
        }, {
            key: "_setValue_array",
            value: function _setValue_array( buffer, offset ) {
                var dest = this.resolvedProperty;
                for ( var _i221 = 0, n = dest.length; _i221 !== n; ++_i221 ) {
                    dest[ _i221 ] = buffer[ offset++ ];
                }
            }
        }, {
            key: "_setValue_array_setNeedsUpdate",
            value: function _setValue_array_setNeedsUpdate( buffer, offset ) {
                var dest = this.resolvedProperty;
                for ( var _i222 = 0, n = dest.length; _i222 !== n; ++_i222 ) {
                    dest[ _i222 ] = buffer[ offset++ ];
                }
                this.targetObject.needsUpdate = true;
            }
        }, {
            key: "_setValue_array_setMatrixWorldNeedsUpdate",
            value: function _setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
                var dest = this.resolvedProperty;
                for ( var _i223 = 0, n = dest.length; _i223 !== n; ++_i223 ) {
                    dest[ _i223 ] = buffer[ offset++ ];
                }
                this.targetObject.matrixWorldNeedsUpdate = true;
            } // ArrayElement
        }, {
            key: "_setValue_arrayElement",
            value: function _setValue_arrayElement( buffer, offset ) {
                this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
            }
        }, {
            key: "_setValue_arrayElement_setNeedsUpdate",
            value: function _setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
                this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
                this.targetObject.needsUpdate = true;
            }
        }, {
            key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
            value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
                this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
                this.targetObject.matrixWorldNeedsUpdate = true;
            } // HasToFromArray
        }, {
            key: "_setValue_fromArray",
            value: function _setValue_fromArray( buffer, offset ) {
                this.resolvedProperty.fromArray( buffer, offset );
            }
        }, {
            key: "_setValue_fromArray_setNeedsUpdate",
            value: function _setValue_fromArray_setNeedsUpdate( buffer, offset ) {
                this.resolvedProperty.fromArray( buffer, offset );
                this.targetObject.needsUpdate = true;
            }
        }, {
            key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
            value: function _setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
                this.resolvedProperty.fromArray( buffer, offset );
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        }, {
            key: "_getValue_unbound",
            value: function _getValue_unbound( targetArray, offset ) {
                this.bind( );
                this.getValue( targetArray, offset );
            }
        }, {
            key: "_setValue_unbound",
            value: function _setValue_unbound( sourceArray, offset ) {
                this.bind( );
                this.setValue( sourceArray, offset );
            } // create getter / setter pair for a property in the scene graph
        }, {
            key: "bind",
            value: function bind( ) {
                var targetObject = this.node;
                var parsedPath = this.parsedPath;
                var objectName = parsedPath.objectName;
                var propertyName = parsedPath.propertyName;
                var propertyIndex = parsedPath.propertyIndex;
                if ( !targetObject ) {
                    targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;
                    this.node = targetObject;
                } // set fail state so we can just 'return' on error
                this.getValue = this._getValue_unavailable;
                this.setValue = this._setValue_unavailable; // ensure there is a value node
                if ( !targetObject ) {
                    console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
                    return;
                }
                if ( objectName ) {
                    var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....
                    switch ( objectName ) {
                        case 'materials':
                            if ( !targetObject.material ) {
                                console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
                                return;
                            }
                            if ( !targetObject.material.materials ) {
                                console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
                                return;
                            }
                            targetObject = targetObject.material.materials;
                            break;
                        case 'bones':
                            if ( !targetObject.skeleton ) {
                                console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
                                return;
                            } // potential future optimization: skip this if propertyIndex is already an integer
                            // and convert the integer string to a true integer.
                            targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.
                            for ( var _i224 = 0; _i224 < targetObject.length; _i224++ ) {
                                if ( targetObject[ _i224 ].name === objectIndex ) {
                                    objectIndex = _i224;
                                    break;
                                }
                            }
                            break;
                        default:
                            if ( targetObject[ objectName ] === undefined ) {
                                console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
                                return;
                            }
                            targetObject = targetObject[ objectName ];
                    }
                    if ( objectIndex !== undefined ) {
                        if ( targetObject[ objectIndex ] === undefined ) {
                            console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
                            return;
                        }
                        targetObject = targetObject[ objectIndex ];
                    }
                } // resolve property
                var nodeProperty = targetObject[ propertyName ];
                if ( nodeProperty === undefined ) {
                    var nodeName = parsedPath.nodeName;
                    console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject );
                    return;
                } // determine versioning scheme
                var versioning = this.Versioning.None;
                this.targetObject = targetObject;
                if ( targetObject.needsUpdate !== undefined ) { // material
                    versioning = this.Versioning.NeedsUpdate;
                } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
                    versioning = this.Versioning.MatrixWorldNeedsUpdate;
                } // determine how the property gets bound
                var bindingType = this.BindingType.Direct;
                if ( propertyIndex !== undefined ) { // access a sub element of the property array (only primitives are supported right now)
                    if ( propertyName === 'morphTargetInfluences' ) { // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                        // support resolving morphTarget names into indices.
                        if ( !targetObject.geometry ) {
                            console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
                            return;
                        }
                        if ( !targetObject.geometry.morphAttributes ) {
                            console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
                            return;
                        }
                        if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {
                            propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];
                        }
                    }
                    bindingType = this.BindingType.ArrayElement;
                    this.resolvedProperty = nodeProperty;
                    this.propertyIndex = propertyIndex;
                } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) { // must use copy for Object3D.Euler/Quaternion
                    bindingType = this.BindingType.HasFromToArray;
                    this.resolvedProperty = nodeProperty;
                } else if ( Array.isArray( nodeProperty ) ) {
                    bindingType = this.BindingType.EntireArray;
                    this.resolvedProperty = nodeProperty;
                } else {
                    this.propertyName = propertyName;
                } // select getter / setter
                this.getValue = this.GetterByBindingType[ bindingType ];
                this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
            }
        }, {
            key: "unbind",
            value: function unbind( ) {
                this.node = null; // back to the prototype version of getValue / setValue
                // note: avoiding to mutate the shape of 'this' via 'delete'
                this.getValue = this._getValue_unbound;
                this.setValue = this._setValue_unbound;
            }
        } ], [ {
            key: "create",
            value: function create( root, path, parsedPath ) {
                if ( !( root && root.isAnimationObjectGroup ) ) {
                    return new PropertyBinding( root, path, parsedPath );
                } else {
                    return new PropertyBinding.Composite( root, path, parsedPath );
                }
            }
            /**
             * Replaces spaces with underscores and removes unsupported characters from
             * node names, to ensure compatibility with parseTrackName().
             *
             * @param {string} name Node name to be sanitized.
             * @return {string}
             */
        }, {
            key: "sanitizeNodeName",
            value: function sanitizeNodeName( name ) {
                return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );
            }
        }, {
            key: "parseTrackName",
            value: function parseTrackName( trackName ) {
                var matches = _trackRe.exec( trackName );
                if ( matches === null ) {
                    throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
                }
                var results = { // directoryName: matches[ 1 ], // (tschw) currently unused
                    nodeName: matches[ 2 ],
                    objectName: matches[ 3 ],
                    objectIndex: matches[ 4 ],
                    propertyName: matches[ 5 ], // required
                    propertyIndex: matches[ 6 ]
                };
                var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );
                if ( lastDot !== undefined && lastDot !== -1 ) {
                    var objectName = results.nodeName.substring( lastDot + 1 ); // Object names must be checked against an allowlist. Otherwise, there
                    // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                    // 'bar' could be the objectName, or part of a nodeName (which can
                    // include '.' characters).
                    if ( _supportedObjectNames.indexOf( objectName ) !== -1 ) {
                        results.nodeName = results.nodeName.substring( 0, lastDot );
                        results.objectName = objectName;
                    }
                }
                if ( results.propertyName === null || results.propertyName.length === 0 ) {
                    throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
                }
                return results;
            }
        }, {
            key: "findNode",
            value: function findNode( root, nodeName ) {
                if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
                    return root;
                } // search into skeleton bones.
                if ( root.skeleton ) {
                    var bone = root.skeleton.getBoneByName( nodeName );
                    if ( bone !== undefined ) {
                        return bone;
                    }
                } // search into node subtree.
                if ( root.children ) {
                    var searchNodeSubtree = function searchNodeSubtree( children ) {
                        for ( var _i225 = 0; _i225 < children.length; _i225++ ) {
                            var childNode = children[ _i225 ];
                            if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
                                return childNode;
                            }
                            var result = searchNodeSubtree( childNode.children );
                            if ( result ) return result;
                        }
                        return null;
                    };
                    var subTreeNode = searchNodeSubtree( root.children );
                    if ( subTreeNode ) {
                        return subTreeNode;
                    }
                }
                return null;
            }
        } ] );
        return PropertyBinding;
    }( );
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [ PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
        [ // Direct
            PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [ // EntireArray
            PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [ // ArrayElement
            PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [ // HasToFromArray
            PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
    ]; // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    var _generateTables2 = /*@__PURE__*/ _generateTables( ),
        _floatView = _generateTables2.floatView,
        _uint32View = _generateTables2.uint32View,
        _baseTable = _generateTables2.baseTable,
        _shiftTable = _generateTables2.shiftTable,
        _mantissaTable = _generateTables2.mantissaTable,
        _exponentTable = _generateTables2.exponentTable,
        _offsetTable = _generateTables2.offsetTable;

    function _generateTables( ) { // float32 to float16 helpers
        var buffer = new ArrayBuffer( 4 );
        var floatView = new Float32Array( buffer );
        var uint32View = new Uint32Array( buffer );
        var baseTable = new Uint32Array( 512 );
        var shiftTable = new Uint32Array( 512 );
        for ( var _i226 = 0; _i226 < 256; ++_i226 ) {
            var e = _i226 - 127; // very small number (0, -0)
            if ( e < -27 ) {
                baseTable[ _i226 ] = 0x0000;
                baseTable[ _i226 | 0x100 ] = 0x8000;
                shiftTable[ _i226 ] = 24;
                shiftTable[ _i226 | 0x100 ] = 24; // small number (denorm)
            } else if ( e < -14 ) {
                baseTable[ _i226 ] = 0x0400 >> -e - 14;
                baseTable[ _i226 | 0x100 ] = 0x0400 >> -e - 14 | 0x8000;
                shiftTable[ _i226 ] = -e - 1;
                shiftTable[ _i226 | 0x100 ] = -e - 1; // normal number
            } else if ( e <= 15 ) {
                baseTable[ _i226 ] = e + 15 << 10;
                baseTable[ _i226 | 0x100 ] = e + 15 << 10 | 0x8000;
                shiftTable[ _i226 ] = 13;
                shiftTable[ _i226 | 0x100 ] = 13; // large number (Infinity, -Infinity)
            } else if ( e < 128 ) {
                baseTable[ _i226 ] = 0x7c00;
                baseTable[ _i226 | 0x100 ] = 0xfc00;
                shiftTable[ _i226 ] = 24;
                shiftTable[ _i226 | 0x100 ] = 24; // stay (NaN, Infinity, -Infinity)
            } else {
                baseTable[ _i226 ] = 0x7c00;
                baseTable[ _i226 | 0x100 ] = 0xfc00;
                shiftTable[ _i226 ] = 13;
                shiftTable[ _i226 | 0x100 ] = 13;
            }
        } // float16 to float32 helpers
        var mantissaTable = new Uint32Array( 2048 );
        var exponentTable = new Uint32Array( 64 );
        var offsetTable = new Uint32Array( 64 );
        for ( var _i227 = 1; _i227 < 1024; ++_i227 ) {
            var m = _i227 << 13; // zero pad mantissa bits
            var _e2 = 0; // zero exponent
            // normalized
            while ( ( m & 0x00800000 ) === 0 ) {
                m <<= 1;
                _e2 -= 0x00800000; // decrement exponent
            }
            m &= ~0x00800000; // clear leading 1 bit
            _e2 += 0x38800000; // adjust bias
            mantissaTable[ _i227 ] = m | _e2;
        }
        for ( var _i228 = 1024; _i228 < 2048; ++_i228 ) {
            mantissaTable[ _i228 ] = 0x38000000 + ( _i228 - 1024 << 13 );
        }
        for ( var _i229 = 1; _i229 < 31; ++_i229 ) {
            exponentTable[ _i229 ] = _i229 << 23;
        }
        exponentTable[ 31 ] = 0x47800000;
        exponentTable[ 32 ] = 0x80000000;
        for ( var _i230 = 33; _i230 < 63; ++_i230 ) {
            exponentTable[ _i230 ] = 0x80000000 + ( _i230 - 32 << 23 );
        }
        exponentTable[ 63 ] = 0xc7800000;
        for ( var _i231 = 1; _i231 < 64; ++_i231 ) {
            if ( _i231 !== 32 ) {
                offsetTable[ _i231 ] = 1024;
            }
        }
        return {
            floatView: floatView,
            uint32View: uint32View,
            baseTable: baseTable,
            shiftTable: shiftTable,
            mantissaTable: mantissaTable,
            exponentTable: exponentTable,
            offsetTable: offsetTable
        };
    } // float32 to float16
    function toHalfFloat( val ) {
        if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );
        val = clamp( val, -65504, 65504 );
        _floatView[ 0 ] = val;
        var f = _uint32View[ 0 ];
        var e = f >> 23 & 0x1ff;
        return _baseTable[ e ] + ( ( f & 0x007fffff ) >> _shiftTable[ e ] );
    } // float16 to float32
    function fromHalfFloat( val ) {
        var m = val >> 10;
        _uint32View[ 0 ] = _mantissaTable[ _offsetTable[ m ] + ( val & 0x3ff ) ] + _exponentTable[ m ];
        return _floatView[ 0 ];
    }
    var DataUtils = /*#__PURE__*/ Object.freeze( {
        __proto__: null,
        toHalfFloat: toHalfFloat,
        fromHalfFloat: fromHalfFloat
    } );
    if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
        __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', {
            detail: {
                revision: REVISION
            }
        } ) );
    }
    if ( typeof window !== 'undefined' ) {
        if ( window.__THREE__ ) {
            console.warn( 'WARNING: Multiple instances of Three.js being imported.' );
        } else {
            window.__THREE__ = REVISION;
        }
    }
    var GLTFLoader = /*#__PURE__*/ function( _Loader6 ) {
        _inherits( GLTFLoader, _Loader6 );
        var _super66 = _createSuper( GLTFLoader );

        function GLTFLoader( manager ) {
            var _this51;
            _classCallCheck( this, GLTFLoader );
            _this51 = _super66.call( this, manager );
            _this51.dracoLoader = null;
            _this51.ktx2Loader = null;
            _this51.meshoptDecoder = null;
            _this51.pluginCallbacks = [ ];
            _this51.register( function( parser ) {
                return new GLTFMaterialsClearcoatExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFTextureBasisUExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFTextureWebPExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsSheenExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsTransmissionExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsVolumeExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsIorExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsEmissiveStrengthExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsSpecularExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMaterialsIridescenceExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFLightsExtension( parser );
            } );
            _this51.register( function( parser ) {
                return new GLTFMeshoptCompression( parser );
            } );
            return _this51;
        }
        _createClass( GLTFLoader, [ {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                var scope = this;
                var resourcePath;
                if ( this.resourcePath !== '' ) {
                    resourcePath = this.resourcePath;
                } else if ( this.path !== '' ) {
                    resourcePath = this.path;
                } else {
                    resourcePath = LoaderUtils.extractUrlBase( url );
                } // Tells the LoadingManager to track an extra item, which resolves after
                // the model is fully loaded. This means the count of items loaded will
                // be incorrect, but ensures manager.onLoad() does not fire early.
                this.manager.itemStart( url );
                var _onError = function _onError( e ) {
                    if ( onError ) {
                        onError( e );
                    } else {
                        console.error( e );
                    }
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
                };
                var loader = new FileLoader( this.manager );
                loader.setPath( this.path );
                loader.setResponseType( 'arraybuffer' );
                loader.setRequestHeader( this.requestHeader );
                loader.setWithCredentials( this.withCredentials );
                loader.load( url, function( data ) {
                    try {
                        scope.parse( data, resourcePath, function( gltf ) {
                            onLoad( gltf );
                            scope.manager.itemEnd( url );
                        }, _onError );
                    } catch ( e ) {
                        _onError( e );
                    }
                }, onProgress, _onError );
            }
        }, {
            key: "setDRACOLoader",
            value: function setDRACOLoader( dracoLoader ) {
                this.dracoLoader = dracoLoader;
                return this;
            }
        }, {
            key: "setDDSLoader",
            value: function setDDSLoader( ) {
                throw new Error( 'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".' );
            }
        }, {
            key: "setKTX2Loader",
            value: function setKTX2Loader( ktx2Loader ) {
                this.ktx2Loader = ktx2Loader;
                return this;
            }
        }, {
            key: "setMeshoptDecoder",
            value: function setMeshoptDecoder( meshoptDecoder ) {
                this.meshoptDecoder = meshoptDecoder;
                return this;
            }
        }, {
            key: "register",
            value: function register( callback ) {
                if ( this.pluginCallbacks.indexOf( callback ) === -1 ) {
                    this.pluginCallbacks.push( callback );
                }
                return this;
            }
        }, {
            key: "unregister",
            value: function unregister( callback ) {
                if ( this.pluginCallbacks.indexOf( callback ) !== -1 ) {
                    this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );
                }
                return this;
            }
        }, {
            key: "parse",
            value: function parse( data, path, onLoad, onError ) {
                var content;
                var extensions = {};
                var plugins = {};
                if ( typeof data === 'string' ) {
                    content = data;
                } else {
                    var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );
                    if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {
                        try {
                            extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );
                        } catch ( error ) {
                            if ( onError ) onError( error );
                            return;
                        }
                        content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;
                    } else {
                        content = LoaderUtils.decodeText( new Uint8Array( data ) );
                    }
                }
                var json = JSON.parse( content );
                if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {
                    if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
                    return;
                }
                var parser = new GLTFParser( json, {
                    path: path || this.resourcePath || '',
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                } );
                parser.fileLoader.setRequestHeader( this.requestHeader );
                for ( var _i232 = 0; _i232 < this.pluginCallbacks.length; _i232++ ) {
                    var plugin = this.pluginCallbacks[ _i232 ]( parser );
                    plugins[ plugin.name ] = plugin; // Workaround to avoid determining as unknown extension
                    // in addUnknownExtensionsToUserData().
                    // Remove this workaround if we move all the existing
                    // extension handlers to plugin system
                    extensions[ plugin.name ] = true;
                }
                if ( json.extensionsUsed ) {
                    for ( var _i233 = 0; _i233 < json.extensionsUsed.length; ++_i233 ) {
                        var extensionName = json.extensionsUsed[ _i233 ];
                        var extensionsRequired = json.extensionsRequired || [ ];
                        switch ( extensionName ) {
                            case EXTENSIONS.KHR_MATERIALS_UNLIT:
                                extensions[ extensionName ] = new GLTFMaterialsUnlitExtension( );
                                break;
                            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension( );
                                break;
                            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                                extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
                                break;
                            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                                extensions[ extensionName ] = new GLTFTextureTransformExtension( );
                                break;
                            case EXTENSIONS.KHR_MESH_QUANTIZATION:
                                extensions[ extensionName ] = new GLTFMeshQuantizationExtension( );
                                break;
                            default:
                                if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {
                                    console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );
                                }
                        }
                    }
                }
                parser.setExtensions( extensions );
                parser.setPlugins( plugins );
                parser.parse( onLoad, onError );
            }
        }, {
            key: "parseAsync",
            value: function parseAsync( data, path ) {
                var scope = this;
                return new Promise( function( resolve, reject ) {
                    scope.parse( data, path, resolve, reject );
                } );
            }
        } ] );
        return GLTFLoader;
    }( Loader ); /* GLTFREGISTRY */
    function GLTFRegistry( ) {
        var objects = {};
        return {
            get: function get( key ) {
                return objects[ key ];
            },
            add: function add( key, object ) {
                objects[ key ] = object;
            },
            remove: function remove( key ) {
                delete objects[ key ];
            },
            removeAll: function removeAll( ) {
                objects = {};
            }
        };
    } /*********************************/ /********** EXTENSIONS ***********/ /*********************************/
    var EXTENSIONS = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_IOR: 'KHR_materials_ior',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
        KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
        EXT_TEXTURE_WEBP: 'EXT_texture_webp',
        EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
    };
    /**
     * Punctual Lights Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
     */
    var GLTFLightsExtension = /*#__PURE__*/ function( ) {
        function GLTFLightsExtension( parser ) {
            _classCallCheck( this, GLTFLightsExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches
            this.cache = {
                refs: {},
                uses: {}
            };
        }
        _createClass( GLTFLightsExtension, [ {
            key: "_markDefs",
            value: function _markDefs( ) {
                var parser = this.parser;
                var nodeDefs = this.parser.json.nodes || [ ];
                for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++ ) {
                    var nodeDef = nodeDefs[ nodeIndex ];
                    if ( nodeDef.extensions && nodeDef.extensions[ this.name ] && nodeDef.extensions[ this.name ].light !== undefined ) {
                        parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );
                    }
                }
            }
        }, {
            key: "_loadLight",
            value: function _loadLight( lightIndex ) {
                var parser = this.parser;
                var cacheKey = 'light:' + lightIndex;
                var dependency = parser.cache.get( cacheKey );
                if ( dependency ) return dependency;
                var json = parser.json;
                var extensions = json.extensions && json.extensions[ this.name ] || {};
                var lightDefs = extensions.lights || [ ];
                var lightDef = lightDefs[ lightIndex ];
                var lightNode;
                var color = new Color( 0xffffff );
                if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );
                var range = lightDef.range !== undefined ? lightDef.range : 0;
                switch ( lightDef.type ) {
                    case 'directional':
                        lightNode = new DirectionalLight( color );
                        lightNode.target.position.set( 0, 0, -1 );
                        lightNode.add( lightNode.target );
                        break;
                    case 'point':
                        lightNode = new PointLight( color );
                        lightNode.distance = range;
                        break;
                    case 'spot':
                        lightNode = new SpotLight( color );
                        lightNode.distance = range; // Handle spotlight properties.
                        lightDef.spot = lightDef.spot || {};
                        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                        lightNode.angle = lightDef.spot.outerConeAngle;
                        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                        lightNode.target.position.set( 0, 0, -1 );
                        lightNode.add( lightNode.target );
                        break;
                    default:
                        throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );
                } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
                // here, because node-level parsing will only override position if explicitly specified.
                lightNode.position.set( 0, 0, 0 );
                lightNode.decay = 2;
                if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;
                lightNode.name = parser.createUniqueName( lightDef.name || 'light_' + lightIndex );
                dependency = Promise.resolve( lightNode );
                parser.cache.add( cacheKey, dependency );
                return dependency;
            }
        }, {
            key: "createNodeAttachment",
            value: function createNodeAttachment( nodeIndex ) {
                var self = this;
                var parser = this.parser;
                var json = parser.json;
                var nodeDef = json.nodes[ nodeIndex ];
                var lightDef = nodeDef.extensions && nodeDef.extensions[ this.name ] || {};
                var lightIndex = lightDef.light;
                if ( lightIndex === undefined ) return null;
                return this._loadLight( lightIndex ).then( function( light ) {
                    return parser._getNodeRef( self.cache, lightIndex, light );
                } );
            }
        } ] );
        return GLTFLightsExtension;
    }( );
    /**
     * Unlit Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
     */
    var GLTFMaterialsUnlitExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsUnlitExtension( ) {
            _classCallCheck( this, GLTFMaterialsUnlitExtension );
            this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
        }
        _createClass( GLTFMaterialsUnlitExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( ) {
                return MeshBasicMaterial;
            }
        }, {
            key: "extendParams",
            value: function extendParams( materialParams, materialDef, parser ) {
                var pending = [ ];
                materialParams.color = new Color( 1.0, 1.0, 1.0 );
                materialParams.opacity = 1.0;
                var metallicRoughness = materialDef.pbrMetallicRoughness;
                if ( metallicRoughness ) {
                    if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {
                        var array = metallicRoughness.baseColorFactor;
                        materialParams.color.fromArray( array );
                        materialParams.opacity = array[ 3 ];
                    }
                    if ( metallicRoughness.baseColorTexture !== undefined ) {
                        pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );
                    }
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsUnlitExtension;
    }( );
    /**
     * Materials Emissive Strength Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
     */
    var GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsEmissiveStrengthExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsEmissiveStrengthExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        _createClass( GLTFMaterialsEmissiveStrengthExtension, [ {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;
                if ( emissiveStrength !== undefined ) {
                    materialParams.emissiveIntensity = emissiveStrength;
                }
                return Promise.resolve( );
            }
        } ] );
        return GLTFMaterialsEmissiveStrengthExtension;
    }( );
    /**
     * Clearcoat Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
    var GLTFMaterialsClearcoatExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsClearcoatExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsClearcoatExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
        }
        _createClass( GLTFMaterialsClearcoatExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                var extension = materialDef.extensions[ this.name ];
                if ( extension.clearcoatFactor !== undefined ) {
                    materialParams.clearcoat = extension.clearcoatFactor;
                }
                if ( extension.clearcoatTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );
                }
                if ( extension.clearcoatRoughnessFactor !== undefined ) {
                    materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
                }
                if ( extension.clearcoatRoughnessTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );
                }
                if ( extension.clearcoatNormalTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );
                    if ( extension.clearcoatNormalTexture.scale !== undefined ) {
                        var scale = extension.clearcoatNormalTexture.scale;
                        materialParams.clearcoatNormalScale = new Vector2( scale, scale );
                    }
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsClearcoatExtension;
    }( );
    /**
     * Iridescence Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
     */
    var GLTFMaterialsIridescenceExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsIridescenceExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsIridescenceExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
        }
        _createClass( GLTFMaterialsIridescenceExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                var extension = materialDef.extensions[ this.name ];
                if ( extension.iridescenceFactor !== undefined ) {
                    materialParams.iridescence = extension.iridescenceFactor;
                }
                if ( extension.iridescenceTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );
                }
                if ( extension.iridescenceIor !== undefined ) {
                    materialParams.iridescenceIOR = extension.iridescenceIor;
                }
                if ( materialParams.iridescenceThicknessRange === undefined ) {
                    materialParams.iridescenceThicknessRange = [ 100, 400 ];
                }
                if ( extension.iridescenceThicknessMinimum !== undefined ) {
                    materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;
                }
                if ( extension.iridescenceThicknessMaximum !== undefined ) {
                    materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;
                }
                if ( extension.iridescenceThicknessTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsIridescenceExtension;
    }( );
    /**
     * Sheen Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
     */
    var GLTFMaterialsSheenExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsSheenExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsSheenExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
        }
        _createClass( GLTFMaterialsSheenExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                materialParams.sheenColor = new Color( 0, 0, 0 );
                materialParams.sheenRoughness = 0;
                materialParams.sheen = 1;
                var extension = materialDef.extensions[ this.name ];
                if ( extension.sheenColorFactor !== undefined ) {
                    materialParams.sheenColor.fromArray( extension.sheenColorFactor );
                }
                if ( extension.sheenRoughnessFactor !== undefined ) {
                    materialParams.sheenRoughness = extension.sheenRoughnessFactor;
                }
                if ( extension.sheenColorTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );
                }
                if ( extension.sheenRoughnessTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsSheenExtension;
    }( );
    /**
     * Transmission Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
     * Draft: https://github.com/KhronosGroup/glTF/pull/1698
     */
    var GLTFMaterialsTransmissionExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsTransmissionExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsTransmissionExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
        }
        _createClass( GLTFMaterialsTransmissionExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                var extension = materialDef.extensions[ this.name ];
                if ( extension.transmissionFactor !== undefined ) {
                    materialParams.transmission = extension.transmissionFactor;
                }
                if ( extension.transmissionTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsTransmissionExtension;
    }( );
    /**
     * Materials Volume Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
     */
    var GLTFMaterialsVolumeExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsVolumeExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsVolumeExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
        }
        _createClass( GLTFMaterialsVolumeExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                var extension = materialDef.extensions[ this.name ];
                materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;
                if ( extension.thicknessTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );
                }
                materialParams.attenuationDistance = extension.attenuationDistance || 0;
                var colorArray = extension.attenuationColor || [ 1, 1, 1 ];
                materialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsVolumeExtension;
    }( );
    /**
     * Materials ior Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
     */
    var GLTFMaterialsIorExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsIorExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsIorExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_IOR;
        }
        _createClass( GLTFMaterialsIorExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var extension = materialDef.extensions[ this.name ];
                materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
                return Promise.resolve( );
            }
        } ] );
        return GLTFMaterialsIorExtension;
    }( );
    /**
     * Materials specular Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
     */
    var GLTFMaterialsSpecularExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsSpecularExtension( parser ) {
            _classCallCheck( this, GLTFMaterialsSpecularExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
        }
        _createClass( GLTFMaterialsSpecularExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( materialIndex ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) return null;
                return MeshPhysicalMaterial;
            }
        }, {
            key: "extendMaterialParams",
            value: function extendMaterialParams( materialIndex, materialParams ) {
                var parser = this.parser;
                var materialDef = parser.json.materials[ materialIndex ];
                if ( !materialDef.extensions || !materialDef.extensions[ this.name ] ) {
                    return Promise.resolve( );
                }
                var pending = [ ];
                var extension = materialDef.extensions[ this.name ];
                materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;
                if ( extension.specularTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );
                }
                var colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
                materialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );
                if ( extension.specularColorTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );
                }
                return Promise.all( pending );
            }
        } ] );
        return GLTFMaterialsSpecularExtension;
    }( );
    /**
     * BasisU Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
     */
    var GLTFTextureBasisUExtension = /*#__PURE__*/ function( ) {
        function GLTFTextureBasisUExtension( parser ) {
            _classCallCheck( this, GLTFTextureBasisUExtension );
            this.parser = parser;
            this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
        }
        _createClass( GLTFTextureBasisUExtension, [ {
            key: "loadTexture",
            value: function loadTexture( textureIndex ) {
                var parser = this.parser;
                var json = parser.json;
                var textureDef = json.textures[ textureIndex ];
                if ( !textureDef.extensions || !textureDef.extensions[ this.name ] ) {
                    return null;
                }
                var extension = textureDef.extensions[ this.name ];
                var loader = parser.options.ktx2Loader;
                if ( !loader ) {
                    if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {
                        throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );
                    } else { // Assumes that the extension is optional and that a fallback texture is present
                        return null;
                    }
                }
                return parser.loadTextureImage( textureIndex, extension.source, loader );
            }
        } ] );
        return GLTFTextureBasisUExtension;
    }( );
    /**
     * WebP Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
     */
    var GLTFTextureWebPExtension = /*#__PURE__*/ function( ) {
        function GLTFTextureWebPExtension( parser ) {
            _classCallCheck( this, GLTFTextureWebPExtension );
            this.parser = parser;
            this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
            this.isSupported = null;
        }
        _createClass( GLTFTextureWebPExtension, [ {
            key: "loadTexture",
            value: function loadTexture( textureIndex ) {
                var name = this.name;
                var parser = this.parser;
                var json = parser.json;
                var textureDef = json.textures[ textureIndex ];
                if ( !textureDef.extensions || !textureDef.extensions[ name ] ) {
                    return null;
                }
                var extension = textureDef.extensions[ name ];
                var source = json.images[ extension.source ];
                var loader = parser.textureLoader;
                if ( source.uri ) {
                    var handler = parser.options.manager.getHandler( source.uri );
                    if ( handler !== null ) loader = handler;
                }
                return this.detectSupport( ).then( function( isSupported ) {
                    if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );
                    if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {
                        throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );
                    } // Fall back to PNG or JPEG.
                    return parser.loadTexture( textureIndex );
                } );
            }
        }, {
            key: "detectSupport",
            value: function detectSupport( ) {
                if ( !this.isSupported ) {
                    this.isSupported = new Promise( function( resolve ) {
                        var image = new Image( ); // Lossy test image. Support for lossy images doesn't guarantee support for all
                        // WebP images, unfortunately.
                        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
                        image.onload = image.onerror = function( ) {
                            resolve( image.height === 1 );
                        };
                    } );
                }
                return this.isSupported;
            }
        } ] );
        return GLTFTextureWebPExtension;
    }( );
    /**
     * meshopt BufferView Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
     */
    var GLTFMeshoptCompression = /*#__PURE__*/ function( ) {
        function GLTFMeshoptCompression( parser ) {
            _classCallCheck( this, GLTFMeshoptCompression );
            this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
            this.parser = parser;
        }
        _createClass( GLTFMeshoptCompression, [ {
            key: "loadBufferView",
            value: function loadBufferView( index ) {
                var json = this.parser.json;
                var bufferView = json.bufferViews[ index ];
                if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {
                    var extensionDef = bufferView.extensions[ this.name ];
                    var buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
                    var decoder = this.parser.options.meshoptDecoder;
                    if ( !decoder || !decoder.supported ) {
                        if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {
                            throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );
                        } else { // Assumes that the extension is optional and that fallback buffer data is present
                            return null;
                        }
                    }
                    return Promise.all( [ buffer, decoder.ready ] ).then( function( res ) {
                        var byteOffset = extensionDef.byteOffset || 0;
                        var byteLength = extensionDef.byteLength || 0;
                        var count = extensionDef.count;
                        var stride = extensionDef.byteStride;
                        var result = new ArrayBuffer( count * stride );
                        var source = new Uint8Array( res[ 0 ], byteOffset, byteLength );
                        decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
                        return result;
                    } );
                } else {
                    return null;
                }
            }
        } ] );
        return GLTFMeshoptCompression;
    }( ); /* BINARY EXTENSION */
    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = {
        JSON: 0x4E4F534A,
        BIN: 0x004E4942
    };
    var GLTFBinaryExtension = /*#__PURE__*/ _createClass( function GLTFBinaryExtension( data ) {
        _classCallCheck( this, GLTFBinaryExtension );
        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;
        var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
        this.header = {
            magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
            version: headerView.getUint32( 4, true ),
            length: headerView.getUint32( 8, true )
        };
        if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {
            throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );
        } else if ( this.header.version < 2.0 ) {
            throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );
        }
        var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
        var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
        var chunkIndex = 0;
        while ( chunkIndex < chunkContentsLength ) {
            var chunkLength = chunkView.getUint32( chunkIndex, true );
            chunkIndex += 4;
            var chunkType = chunkView.getUint32( chunkIndex, true );
            chunkIndex += 4;
            if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {
                var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
                this.content = LoaderUtils.decodeText( contentArray );
            } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {
                var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                this.body = data.slice( byteOffset, byteOffset + chunkLength );
            } // Clients must ignore chunks with unknown types.
            chunkIndex += chunkLength;
        }
        if ( this.content === null ) {
            throw new Error( 'THREE.GLTFLoader: JSON content not found.' );
        }
    } );
    /**
     * DRACO Mesh Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
     */
    var GLTFDracoMeshCompressionExtension = /*#__PURE__*/ function( ) {
        function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {
            _classCallCheck( this, GLTFDracoMeshCompressionExtension );
            if ( !dracoLoader ) {
                throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );
            }
            this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
            this.json = json;
            this.dracoLoader = dracoLoader;
            this.dracoLoader.preload( );
        }
        _createClass( GLTFDracoMeshCompressionExtension, [ {
            key: "decodePrimitive",
            value: function decodePrimitive( primitive, parser ) {
                var json = this.json;
                var dracoLoader = this.dracoLoader;
                var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
                var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
                var threeAttributeMap = {};
                var attributeNormalizedMap = {};
                var attributeTypeMap = {};
                for ( var attributeName in gltfAttributeMap ) {
                    var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase( );
                    threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];
                }
                for ( var _attributeName in primitive.attributes ) {
                    var _threeAttributeName = ATTRIBUTES[ _attributeName ] || _attributeName.toLowerCase( );
                    if ( gltfAttributeMap[ _attributeName ] !== undefined ) {
                        var accessorDef = json.accessors[ primitive.attributes[ _attributeName ] ];
                        var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
                        attributeTypeMap[ _threeAttributeName ] = componentType;
                        attributeNormalizedMap[ _threeAttributeName ] = accessorDef.normalized === true;
                    }
                }
                return parser.getDependency( 'bufferView', bufferViewIndex ).then( function( bufferView ) {
                    return new Promise( function( resolve ) {
                        dracoLoader.decodeDracoFile( bufferView, function( geometry ) {
                            for ( var _attributeName2 in geometry.attributes ) {
                                var attribute = geometry.attributes[ _attributeName2 ];
                                var normalized = attributeNormalizedMap[ _attributeName2 ];
                                if ( normalized !== undefined ) attribute.normalized = normalized;
                            }
                            resolve( geometry );
                        }, threeAttributeMap, attributeTypeMap );
                    } );
                } );
            }
        } ] );
        return GLTFDracoMeshCompressionExtension;
    }( );
    /**
     * Texture Transform Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
     */
    var GLTFTextureTransformExtension = /*#__PURE__*/ function( ) {
        function GLTFTextureTransformExtension( ) {
            _classCallCheck( this, GLTFTextureTransformExtension );
            this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
        }
        _createClass( GLTFTextureTransformExtension, [ {
            key: "extendTexture",
            value: function extendTexture( texture, transform ) {
                if ( transform.texCoord !== undefined ) {
                    console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );
                }
                if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) { // See https://github.com/mrdoob/three.js/issues/21819.
                    return texture;
                }
                texture = texture.clone( );
                if ( transform.offset !== undefined ) {
                    texture.offset.fromArray( transform.offset );
                }
                if ( transform.rotation !== undefined ) {
                    texture.rotation = transform.rotation;
                }
                if ( transform.scale !== undefined ) {
                    texture.repeat.fromArray( transform.scale );
                }
                texture.needsUpdate = true;
                return texture;
            }
        } ] );
        return GLTFTextureTransformExtension;
    }( );
    /**
     * Specular-Glossiness Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
     */
    /**
     * A sub class of StandardMaterial with some of the functionality
     * changed via the `onBeforeCompile` callback
     * @pailhead
     */
    var GLTFMeshStandardSGMaterial = /*#__PURE__*/ function( _MeshStandardMaterial2 ) {
        _inherits( GLTFMeshStandardSGMaterial, _MeshStandardMaterial2 );
        var _super67 = _createSuper( GLTFMeshStandardSGMaterial );

        function GLTFMeshStandardSGMaterial( params ) {
            var _this52;
            _classCallCheck( this, GLTFMeshStandardSGMaterial );
            _this52 = _super67.call( this );
            _this52.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing
            var specularMapParsFragmentChunk = [ '#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif' ].join( '\n' );
            var glossinessMapParsFragmentChunk = [ '#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif' ].join( '\n' );
            var specularMapFragmentChunk = [ 'vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif' ].join( '\n' );
            var glossinessMapFragmentChunk = [ 'float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif' ].join( '\n' );
            var lightPhysicalFragmentChunk = [ 'PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;' ].join( '\n' );
            var uniforms = {
                specular: {
                    value: new Color( ).setHex( 0xffffff )
                },
                glossiness: {
                    value: 1
                },
                specularMap: {
                    value: null
                },
                glossinessMap: {
                    value: null
                }
            };
            _this52._extraUniforms = uniforms;
            _this52.onBeforeCompile = function( shader ) {
                for ( var uniformName in uniforms ) {
                    shader.uniforms[ uniformName ] = uniforms[ uniformName ];
                }
                shader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' ).replace( 'uniform float metalness;', 'uniform float glossiness;' ).replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk ).replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk ).replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk ).replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk ).replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );
            };
            Object.defineProperties( _assertThisInitialized( _this52 ), {
                specular: {
                    get: function get( ) {
                        return uniforms.specular.value;
                    },
                    set: function set( v ) {
                        uniforms.specular.value = v;
                    }
                },
                specularMap: {
                    get: function get( ) {
                        return uniforms.specularMap.value;
                    },
                    set: function set( v ) {
                        uniforms.specularMap.value = v;
                        if ( v ) {
                            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
                        } else {
                            delete this.defines.USE_SPECULARMAP;
                        }
                    }
                },
                glossiness: {
                    get: function get( ) {
                        return uniforms.glossiness.value;
                    },
                    set: function set( v ) {
                        uniforms.glossiness.value = v;
                    }
                },
                glossinessMap: {
                    get: function get( ) {
                        return uniforms.glossinessMap.value;
                    },
                    set: function set( v ) {
                        uniforms.glossinessMap.value = v;
                        if ( v ) {
                            this.defines.USE_GLOSSINESSMAP = '';
                            this.defines.USE_UV = '';
                        } else {
                            delete this.defines.USE_GLOSSINESSMAP;
                            delete this.defines.USE_UV;
                        }
                    }
                }
            } );
            delete _this52.metalness;
            delete _this52.roughness;
            delete _this52.metalnessMap;
            delete _this52.roughnessMap;
            _this52.setValues( params );
            return _this52;
        }
        _createClass( GLTFMeshStandardSGMaterial, [ {
            key: "copy",
            value: function copy( source ) {
                _get( _getPrototypeOf( GLTFMeshStandardSGMaterial.prototype ), "copy", this ).call( this, source );
                this.specularMap = source.specularMap;
                this.specular.copy( source.specular );
                this.glossinessMap = source.glossinessMap;
                this.glossiness = source.glossiness;
                delete this.metalness;
                delete this.roughness;
                delete this.metalnessMap;
                delete this.roughnessMap;
                return this;
            }
        } ] );
        return GLTFMeshStandardSGMaterial;
    }( MeshStandardMaterial );
    var GLTFMaterialsPbrSpecularGlossinessExtension = /*#__PURE__*/ function( ) {
        function GLTFMaterialsPbrSpecularGlossinessExtension( ) {
            _classCallCheck( this, GLTFMaterialsPbrSpecularGlossinessExtension );
            this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
            this.specularGlossinessParams = [ 'color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity' ];
        }
        _createClass( GLTFMaterialsPbrSpecularGlossinessExtension, [ {
            key: "getMaterialType",
            value: function getMaterialType( ) {
                return GLTFMeshStandardSGMaterial;
            }
        }, {
            key: "extendParams",
            value: function extendParams( materialParams, materialDef, parser ) {
                var pbrSpecularGlossiness = materialDef.extensions[ this.name ];
                materialParams.color = new Color( 1.0, 1.0, 1.0 );
                materialParams.opacity = 1.0;
                var pending = [ ];
                if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {
                    var array = pbrSpecularGlossiness.diffuseFactor;
                    materialParams.color.fromArray( array );
                    materialParams.opacity = array[ 3 ];
                }
                if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {
                    pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding ) );
                }
                materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
                materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
                materialParams.specular = new Color( 1.0, 1.0, 1.0 );
                if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {
                    materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );
                }
                if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {
                    var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
                    pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
                    pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, sRGBEncoding ) );
                }
                return Promise.all( pending );
            }
        }, {
            key: "createMaterial",
            value: function createMaterial( materialParams ) {
                var material = new GLTFMeshStandardSGMaterial( materialParams );
                material.fog = true;
                material.color = materialParams.color;
                material.map = materialParams.map === undefined ? null : materialParams.map;
                material.lightMap = null;
                material.lightMapIntensity = 1.0;
                material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
                material.aoMapIntensity = 1.0;
                material.emissive = materialParams.emissive;
                material.emissiveIntensity = materialParams.emissiveIntensity === undefined ? 1.0 : materialParams.emissiveIntensity;
                material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
                material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
                material.bumpScale = 1;
                material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
                material.normalMapType = TangentSpaceNormalMap;
                if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;
                material.displacementMap = null;
                material.displacementScale = 1;
                material.displacementBias = 0;
                material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
                material.specular = materialParams.specular;
                material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
                material.glossiness = materialParams.glossiness;
                material.alphaMap = null;
                material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
                material.envMapIntensity = 1.0;
                return material;
            }
        } ] );
        return GLTFMaterialsPbrSpecularGlossinessExtension;
    }( );
    /**
     * Mesh Quantization Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
     */
    var GLTFMeshQuantizationExtension = /*#__PURE__*/ _createClass( function GLTFMeshQuantizationExtension( ) {
        _classCallCheck( this, GLTFMeshQuantizationExtension );
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    } ); /*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
    var GLTFCubicSplineInterpolant = /*#__PURE__*/ function( _Interpolant5 ) {
        _inherits( GLTFCubicSplineInterpolant, _Interpolant5 );
        var _super68 = _createSuper( GLTFCubicSplineInterpolant );

        function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
            _classCallCheck( this, GLTFCubicSplineInterpolant );
            return _super68.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
        }
        _createClass( GLTFCubicSplineInterpolant, [ {
            key: "copySampleValue_",
            value: function copySampleValue_( index ) { // Copies a sample value to the result buffer. See description of glTF
                // CUBICSPLINE values layout in interpolate_() function below.
                var result = this.resultBuffer,
                    values = this.sampleValues,
                    valueSize = this.valueSize,
                    offset = index * valueSize * 3 + valueSize;
                for ( var _i234 = 0; _i234 !== valueSize; _i234++ ) {
                    result[ _i234 ] = values[ offset + _i234 ];
                }
                return result;
            }
        }, {
            key: "interpolate_",
            value: function interpolate_( i1, t0, t, t1 ) {
                var result = this.resultBuffer;
                var values = this.sampleValues;
                var stride = this.valueSize;
                var stride2 = stride * 2;
                var stride3 = stride * 3;
                var td = t1 - t0;
                var p = ( t - t0 ) / td;
                var pp = p * p;
                var ppp = pp * p;
                var offset1 = i1 * stride3;
                var offset0 = offset1 - stride3;
                var s2 = -2 * ppp + 3 * pp;
                var s3 = ppp - pp;
                var s0 = 1 - s2;
                var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
                //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
                for ( var _i235 = 0; _i235 !== stride; _i235++ ) {
                    var p0 = values[ offset0 + _i235 + stride ]; // splineVertex_k
                    var m0 = values[ offset0 + _i235 + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
                    var p1 = values[ offset1 + _i235 + stride ]; // splineVertex_k+1
                    var m1 = values[ offset1 + _i235 ] * td; // inTangent_k+1 * (t_k+1 - t_k)
                    result[ _i235 ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
                }
                return result;
            }
        } ] );
        return GLTFCubicSplineInterpolant;
    }( Interpolant );
    var _q = new Quaternion$1( );
    var GLTFCubicSplineQuaternionInterpolant = /*#__PURE__*/ function( _GLTFCubicSplineInter ) {
        _inherits( GLTFCubicSplineQuaternionInterpolant, _GLTFCubicSplineInter );
        var _super69 = _createSuper( GLTFCubicSplineQuaternionInterpolant );

        function GLTFCubicSplineQuaternionInterpolant( ) {
            _classCallCheck( this, GLTFCubicSplineQuaternionInterpolant );
            return _super69.apply( this, arguments );
        }
        _createClass( GLTFCubicSplineQuaternionInterpolant, [ {
            key: "interpolate_",
            value: function interpolate_( i1, t0, t, t1 ) {
                var result = _get( _getPrototypeOf( GLTFCubicSplineQuaternionInterpolant.prototype ), "interpolate_", this ).call( this, i1, t0, t, t1 );
                _q.fromArray( result ).normalize( ).toArray( result );
                return result;
            }
        } ] );
        return GLTFCubicSplineQuaternionInterpolant;
    }( GLTFCubicSplineInterpolant ); /*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */
    var WEBGL_CONSTANTS = {
        FLOAT: 5126, //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    };
    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };
    var WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
    };
    var WEBGL_WRAPPINGS = {
        33071: ClampToEdgeWrapping,
        33648: MirroredRepeatWrapping,
        10497: RepeatWrapping
    };
    var WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };
    var ATTRIBUTES = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex'
    };
    var PATH_PROPERTIES = {
        scale: 'scale',
        translation: 'position',
        rotation: 'quaternion',
        weights: 'morphTargetInfluences'
    };
    var INTERPOLATION = {
        CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
        // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: InterpolateLinear,
        STEP: InterpolateDiscrete
    };
    var ALPHA_MODES = {
        OPAQUE: 'OPAQUE',
        MASK: 'MASK',
        BLEND: 'BLEND'
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
     */
    function createDefaultMaterial( cache ) {
        if ( cache[ 'DefaultMaterial' ] === undefined ) {
            cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
                color: 0xFFFFFF,
                emissive: 0x000000,
                metalness: 1,
                roughness: 1,
                transparent: false,
                depthTest: true,
                side: FrontSide
            } );
        }
        return cache[ 'DefaultMaterial' ];
    }

    function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) { // Add unknown glTF extensions to an object's userData.
        for ( var name in objectDef.extensions ) {
            if ( knownExtensions[ name ] === undefined ) {
                object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];
            }
        }
    }
    /**
     * @param {Object3D|Material|BufferGeometry} object
     * @param {GLTF.definition} gltfDef
     */
    function assignExtrasToUserData( object, gltfDef ) {
        if ( gltfDef.extras !== undefined ) {
            if ( _typeof( gltfDef.extras ) === 'object' ) {
                Object.assign( object.userData, gltfDef.extras );
            } else {
                console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );
            }
        }
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
     *
     * @param {BufferGeometry} geometry
     * @param {Array<GLTF.Target>} targets
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */
    function addMorphTargets( geometry, targets, parser ) {
        var hasMorphPosition = false;
        var hasMorphNormal = false;
        var hasMorphColor = false;
        for ( var _i236 = 0, il = targets.length; _i236 < il; _i236++ ) {
            var target = targets[ _i236 ];
            if ( target.POSITION !== undefined ) hasMorphPosition = true;
            if ( target.NORMAL !== undefined ) hasMorphNormal = true;
            if ( target.COLOR_0 !== undefined ) hasMorphColor = true;
            if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;
        }
        if ( !hasMorphPosition && !hasMorphNormal && !hasMorphColor ) return Promise.resolve( geometry );
        var pendingPositionAccessors = [ ];
        var pendingNormalAccessors = [ ];
        var pendingColorAccessors = [ ];
        for ( var _i237 = 0, _il13 = targets.length; _i237 < _il13; _i237++ ) {
            var _target2 = targets[ _i237 ];
            if ( hasMorphPosition ) {
                var pendingAccessor = _target2.POSITION !== undefined ? parser.getDependency( 'accessor', _target2.POSITION ) : geometry.attributes.position;
                pendingPositionAccessors.push( pendingAccessor );
            }
            if ( hasMorphNormal ) {
                var _pendingAccessor = _target2.NORMAL !== undefined ? parser.getDependency( 'accessor', _target2.NORMAL ) : geometry.attributes.normal;
                pendingNormalAccessors.push( _pendingAccessor );
            }
            if ( hasMorphColor ) {
                var _pendingAccessor2 = _target2.COLOR_0 !== undefined ? parser.getDependency( 'accessor', _target2.COLOR_0 ) : geometry.attributes.color;
                pendingColorAccessors.push( _pendingAccessor2 );
            }
        }
        return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ), Promise.all( pendingColorAccessors ) ] ).then( function( accessors ) {
            var morphPositions = accessors[ 0 ];
            var morphNormals = accessors[ 1 ];
            var morphColors = accessors[ 2 ];
            if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
            if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
            if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
            geometry.morphTargetsRelative = true;
            return geometry;
        } );
    }
    /**
     * @param {Mesh} mesh
     * @param {GLTF.Mesh} meshDef
     */
    function updateMorphTargets( mesh, meshDef ) {
        mesh.updateMorphTargets( );
        if ( meshDef.weights !== undefined ) {
            for ( var _i238 = 0, il = meshDef.weights.length; _i238 < il; _i238++ ) {
                mesh.morphTargetInfluences[ _i238 ] = meshDef.weights[ _i238 ];
            }
        } // .extras has user-defined data, so check that .extras.targetNames is an array.
        if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {
            var targetNames = meshDef.extras.targetNames;
            if ( mesh.morphTargetInfluences.length === targetNames.length ) {
                mesh.morphTargetDictionary = {};
                for ( var _i239 = 0, _il14 = targetNames.length; _i239 < _il14; _i239++ ) {
                    mesh.morphTargetDictionary[ targetNames[ _i239 ] ] = _i239;
                }
            } else {
                console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );
            }
        }
    }

    function createPrimitiveKey( primitiveDef ) {
        var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
        var geometryKey;
        if ( dracoExtension ) {
            geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey( dracoExtension.attributes );
        } else {
            geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;
        }
        return geometryKey;
    }

    function createAttributesKey( attributes ) {
        var attributesKey = '';
        var keys = Object.keys( attributes ).sort( );
        for ( var _i240 = 0, il = keys.length; _i240 < il; _i240++ ) {
            attributesKey += keys[ _i240 ] + ':' + attributes[ keys[ _i240 ] ] + ';';
        }
        return attributesKey;
    }

    function getNormalizedComponentScale( constructor ) { // Reference:
        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
        switch ( constructor ) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );
        }
    }

    function getImageURIMimeType( uri ) {
        if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
        if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';
        return 'image/png';
    } /* GLTF PARSER */
    var GLTFParser = /*#__PURE__*/ function( ) {
        function GLTFParser( ) {
            var json = arguments.length > 0 && arguments[ 0 ] !== undefined ? arguments[ 0 ] : {};
            var options = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : {};
            _classCallCheck( this, GLTFParser );
            this.json = json;
            this.extensions = {};
            this.plugins = {};
            this.options = options; // loader object cache
            this.cache = new GLTFRegistry( ); // associations between Three.js objects and glTF elements
            this.associations = new Map( ); // BufferGeometry caching
            this.primitiveCache = {}; // Object3D instance caches
            this.meshCache = {
                refs: {},
                uses: {}
            };
            this.cameraCache = {
                refs: {},
                uses: {}
            };
            this.lightCache = {
                refs: {},
                uses: {}
            };
            this.sourceCache = {};
            this.textureCache = {}; // Track node names, to ensure no duplicates
            this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
            // expensive work of uploading a texture to the GPU off the main thread.
            var isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
            var isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > -1;
            var firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : -1;
            if ( typeof createImageBitmap === 'undefined' || isSafari || isFirefox && firefoxVersion < 98 ) {
                this.textureLoader = new TextureLoader( this.options.manager );
            } else {
                this.textureLoader = new ImageBitmapLoader( this.options.manager );
            }
            this.textureLoader.setCrossOrigin( this.options.crossOrigin );
            this.textureLoader.setRequestHeader( this.options.requestHeader );
            this.fileLoader = new FileLoader( this.options.manager );
            this.fileLoader.setResponseType( 'arraybuffer' );
            if ( this.options.crossOrigin === 'use-credentials' ) {
                this.fileLoader.setWithCredentials( true );
            }
        }
        _createClass( GLTFParser, [ {
            key: "setExtensions",
            value: function setExtensions( extensions ) {
                this.extensions = extensions;
            }
        }, {
            key: "setPlugins",
            value: function setPlugins( plugins ) {
                this.plugins = plugins;
            }
        }, {
            key: "parse",
            value: function parse( onLoad, onError ) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions; // Clear the loader cache
                this.cache.removeAll( ); // Mark the special nodes/meshes in json for efficient parse
                this._invokeAll( function( ext ) {
                    return ext._markDefs && ext._markDefs( );
                } );
                Promise.all( this._invokeAll( function( ext ) {
                    return ext.beforeRoot && ext.beforeRoot( );
                } ) ).then( function( ) {
                    return Promise.all( [ parser.getDependencies( 'scene' ), parser.getDependencies( 'animation' ), parser.getDependencies( 'camera' ) ] );
                } ).then( function( dependencies ) {
                    var result = {
                        scene: dependencies[ 0 ][ json.scene || 0 ],
                        scenes: dependencies[ 0 ],
                        animations: dependencies[ 1 ],
                        cameras: dependencies[ 2 ],
                        asset: json.asset,
                        parser: parser,
                        userData: {}
                    };
                    addUnknownExtensionsToUserData( extensions, result, json );
                    assignExtrasToUserData( result, json );
                    Promise.all( parser._invokeAll( function( ext ) {
                        return ext.afterRoot && ext.afterRoot( result );
                    } ) ).then( function( ) {
                        onLoad( result );
                    } );
                } )[ "catch" ]( onError );
            }
            /**
             * Marks the special nodes/meshes in json for efficient parse.
             */
        }, {
            key: "_markDefs",
            value: function _markDefs( ) {
                var nodeDefs = this.json.nodes || [ ];
                var skinDefs = this.json.skins || [ ];
                var meshDefs = this.json.meshes || [ ]; // Nothing in the node definition indicates whether it is a Bone or an
                // Object3D. Use the skins' joint references to mark bones.
                for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++ ) {
                    var joints = skinDefs[ skinIndex ].joints;
                    for ( var _i241 = 0, il = joints.length; _i241 < il; _i241++ ) {
                        nodeDefs[ joints[ _i241 ] ].isBone = true;
                    }
                } // Iterate over all nodes, marking references to shared resources,
                // as well as skeleton joints.
                for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++ ) {
                    var nodeDef = nodeDefs[ nodeIndex ];
                    if ( nodeDef.mesh !== undefined ) {
                        this._addNodeRef( this.meshCache, nodeDef.mesh ); // Nothing in the mesh definition indicates whether it is
                        // a SkinnedMesh or Mesh. Use the node's mesh reference
                        // to mark SkinnedMesh if node has skin.
                        if ( nodeDef.skin !== undefined ) {
                            meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;
                        }
                    }
                    if ( nodeDef.camera !== undefined ) {
                        this._addNodeRef( this.cameraCache, nodeDef.camera );
                    }
                }
            }
            /**
             * Counts references to shared node / Object3D resources. These resources
             * can be reused, or "instantiated", at multiple nodes in the scene
             * hierarchy. Mesh, Camera, and Light instances are instantiated and must
             * be marked. Non-scenegraph resources (like Materials, Geometries, and
             * Textures) can be reused directly and are not marked here.
             *
             * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
             */
        }, {
            key: "_addNodeRef",
            value: function _addNodeRef( cache, index ) {
                if ( index === undefined ) return;
                if ( cache.refs[ index ] === undefined ) {
                    cache.refs[ index ] = cache.uses[ index ] = 0;
                }
                cache.refs[ index ]++;
            } /** Returns a reference to a shared resource, cloning it if necessary. */
        }, {
            key: "_getNodeRef",
            value: function _getNodeRef( cache, index, object ) {
                var _this53 = this;
                if ( cache.refs[ index ] <= 1 ) return object;
                var ref = object.clone( ); // Propagates mappings to the cloned object, prevents mappings on the
                // original object from being lost.
                var updateMappings = function updateMappings( original, clone ) {
                    var mappings = _this53.associations.get( original );
                    if ( mappings != null ) {
                        _this53.associations.set( clone, mappings );
                    }
                    var _iterator3 = _createForOfIteratorHelper( original.children.entries( ) ),
                        _step3;
                    try {
                        for ( _iterator3.s( ); !( _step3 = _iterator3.n( ) ).done; ) {
                            var _step3$value = _slicedToArray( _step3.value, 2 ),
                                _i242 = _step3$value[ 0 ],
                                child = _step3$value[ 1 ];
                            updateMappings( child, clone.children[ _i242 ] );
                        }
                    } catch ( err ) {
                        _iterator3.e( err );
                    } finally {
                        _iterator3.f( );
                    }
                };
                updateMappings( object, ref );
                ref.name += '_instance_' + cache.uses[ index ]++;
                return ref;
            }
        }, {
            key: "_invokeOne",
            value: function _invokeOne( func ) {
                var extensions = Object.values( this.plugins );
                extensions.push( this );
                for ( var _i243 = 0; _i243 < extensions.length; _i243++ ) {
                    var result = func( extensions[ _i243 ] );
                    if ( result ) return result;
                }
                return null;
            }
        }, {
            key: "_invokeAll",
            value: function _invokeAll( func ) {
                var extensions = Object.values( this.plugins );
                extensions.unshift( this );
                var pending = [ ];
                for ( var _i244 = 0; _i244 < extensions.length; _i244++ ) {
                    var result = func( extensions[ _i244 ] );
                    if ( result ) pending.push( result );
                }
                return pending;
            }
            /**
             * Requests the specified dependency asynchronously, with caching.
             * @param {string} type
             * @param {number} index
             * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
             */
        }, {
            key: "getDependency",
            value: function getDependency( type, index ) {
                var cacheKey = type + ':' + index;
                var dependency = this.cache.get( cacheKey );
                if ( !dependency ) {
                    switch ( type ) {
                        case 'scene':
                            dependency = this.loadScene( index );
                            break;
                        case 'node':
                            dependency = this.loadNode( index );
                            break;
                        case 'mesh':
                            dependency = this._invokeOne( function( ext ) {
                                return ext.loadMesh && ext.loadMesh( index );
                            } );
                            break;
                        case 'accessor':
                            dependency = this.loadAccessor( index );
                            break;
                        case 'bufferView':
                            dependency = this._invokeOne( function( ext ) {
                                return ext.loadBufferView && ext.loadBufferView( index );
                            } );
                            break;
                        case 'buffer':
                            dependency = this.loadBuffer( index );
                            break;
                        case 'material':
                            dependency = this._invokeOne( function( ext ) {
                                return ext.loadMaterial && ext.loadMaterial( index );
                            } );
                            break;
                        case 'texture':
                            dependency = this._invokeOne( function( ext ) {
                                return ext.loadTexture && ext.loadTexture( index );
                            } );
                            break;
                        case 'skin':
                            dependency = this.loadSkin( index );
                            break;
                        case 'animation':
                            dependency = this._invokeOne( function( ext ) {
                                return ext.loadAnimation && ext.loadAnimation( index );
                            } );
                            break;
                        case 'camera':
                            dependency = this.loadCamera( index );
                            break;
                        default:
                            throw new Error( 'Unknown type: ' + type );
                    }
                    this.cache.add( cacheKey, dependency );
                }
                return dependency;
            }
            /**
             * Requests all dependencies of the specified type asynchronously, with caching.
             * @param {string} type
             * @return {Promise<Array<Object>>}
             */
        }, {
            key: "getDependencies",
            value: function getDependencies( type ) {
                var dependencies = this.cache.get( type );
                if ( !dependencies ) {
                    var parser = this;
                    var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [ ];
                    dependencies = Promise.all( defs.map( function( def, index ) {
                        return parser.getDependency( type, index );
                    } ) );
                    this.cache.add( type, dependencies );
                }
                return dependencies;
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
             * @param {number} bufferIndex
             * @return {Promise<ArrayBuffer>}
             */
        }, {
            key: "loadBuffer",
            value: function loadBuffer( bufferIndex ) {
                var bufferDef = this.json.buffers[ bufferIndex ];
                var loader = this.fileLoader;
                if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {
                    throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );
                } // If present, GLB container is required to be the first buffer.
                if ( bufferDef.uri === undefined && bufferIndex === 0 ) {
                    return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );
                }
                var options = this.options;
                return new Promise( function( resolve, reject ) {
                    loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function( ) {
                        reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );
                    } );
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
             * @param {number} bufferViewIndex
             * @return {Promise<ArrayBuffer>}
             */
        }, {
            key: "loadBufferView",
            value: function loadBufferView( bufferViewIndex ) {
                var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];
                return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function( buffer ) {
                    var byteLength = bufferViewDef.byteLength || 0;
                    var byteOffset = bufferViewDef.byteOffset || 0;
                    return buffer.slice( byteOffset, byteOffset + byteLength );
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
             * @param {number} accessorIndex
             * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
             */
        }, {
            key: "loadAccessor",
            value: function loadAccessor( accessorIndex ) {
                var parser = this;
                var json = this.json;
                var accessorDef = this.json.accessors[ accessorIndex ];
                if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) { // Ignore empty accessors, which may be used to declare runtime
                    // information about attributes coming from another source (e.g. Draco
                    // compression extension).
                    return Promise.resolve( null );
                }
                var pendingBufferViews = [ ];
                if ( accessorDef.bufferView !== undefined ) {
                    pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );
                } else {
                    pendingBufferViews.push( null );
                }
                if ( accessorDef.sparse !== undefined ) {
                    pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
                    pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );
                }
                return Promise.all( pendingBufferViews ).then( function( bufferViews ) {
                    var bufferView = bufferViews[ 0 ];
                    var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
                    var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
                    var elementBytes = TypedArray.BYTES_PER_ELEMENT;
                    var itemBytes = elementBytes * itemSize;
                    var byteOffset = accessorDef.byteOffset || 0;
                    var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
                    var normalized = accessorDef.normalized === true;
                    var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.
                    if ( byteStride && byteStride !== itemBytes ) { // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
                        // This makes sure that IBA.count reflects accessor.count properly
                        var ibSlice = Math.floor( byteOffset / byteStride );
                        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                        var ib = parser.cache.get( ibCacheKey );
                        if ( !ib ) {
                            array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes ); // Integer parameters to IB/IBA are in array elements, not bytes.
                            ib = new InterleavedBuffer( array, byteStride / elementBytes );
                            parser.cache.add( ibCacheKey, ib );
                        }
                        bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, byteOffset % byteStride / elementBytes, normalized );
                    } else {
                        if ( bufferView === null ) {
                            array = new TypedArray( accessorDef.count * itemSize );
                        } else {
                            array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );
                        }
                        bufferAttribute = new BufferAttribute( array, itemSize, normalized );
                    } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
                    if ( accessorDef.sparse !== undefined ) {
                        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];
                        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
                        var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
                        var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );
                        if ( bufferView !== null ) { // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                            bufferAttribute = new BufferAttribute( bufferAttribute.array.slice( ), bufferAttribute.itemSize, bufferAttribute.normalized );
                        }
                        for ( var _i245 = 0, il = sparseIndices.length; _i245 < il; _i245++ ) {
                            var index = sparseIndices[ _i245 ];
                            bufferAttribute.setX( index, sparseValues[ _i245 * itemSize ] );
                            if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ _i245 * itemSize + 1 ] );
                            if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ _i245 * itemSize + 2 ] );
                            if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ _i245 * itemSize + 3 ] );
                            if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );
                        }
                    }
                    return bufferAttribute;
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
             * @param {number} textureIndex
             * @return {Promise<THREE.Texture>}
             */
        }, {
            key: "loadTexture",
            value: function loadTexture( textureIndex ) {
                var json = this.json;
                var options = this.options;
                var textureDef = json.textures[ textureIndex ];
                var sourceIndex = textureDef.source;
                var sourceDef = json.images[ sourceIndex ];
                var loader = this.textureLoader;
                if ( sourceDef.uri ) {
                    var handler = options.manager.getHandler( sourceDef.uri );
                    if ( handler !== null ) loader = handler;
                }
                return this.loadTextureImage( textureIndex, sourceIndex, loader );
            }
        }, {
            key: "loadTextureImage",
            value: function loadTextureImage( textureIndex, sourceIndex, loader ) {
                var parser = this;
                var json = this.json;
                var textureDef = json.textures[ textureIndex ];
                var sourceDef = json.images[ sourceIndex ];
                var cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;
                if ( this.textureCache[ cacheKey ] ) { // See https://github.com/mrdoob/three.js/issues/21559.
                    return this.textureCache[ cacheKey ];
                }
                var promise = this.loadImageSource( sourceIndex, loader ).then( function( texture ) {
                    texture.flipY = false;
                    if ( textureDef.name ) texture.name = textureDef.name;
                    var samplers = json.samplers || {};
                    var sampler = samplers[ textureDef.sampler ] || {};
                    texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
                    texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
                    texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
                    texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;
                    parser.associations.set( texture, {
                        textures: textureIndex
                    } );
                    return texture;
                } )[ "catch" ]( function( ) {
                    return null;
                } );
                this.textureCache[ cacheKey ] = promise;
                return promise;
            }
        }, {
            key: "loadImageSource",
            value: function loadImageSource( sourceIndex, loader ) {
                var parser = this;
                var json = this.json;
                var options = this.options;
                if ( this.sourceCache[ sourceIndex ] !== undefined ) {
                    return this.sourceCache[ sourceIndex ].then( function( texture ) {
                        return texture.clone( );
                    } );
                }
                var sourceDef = json.images[ sourceIndex ];
                var URL = self.URL || self.webkitURL;
                var sourceURI = sourceDef.uri || '';
                var isObjectURL = false;
                if ( sourceDef.bufferView !== undefined ) { // Load binary image data from bufferView, if provided.
                    sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function( bufferView ) {
                        isObjectURL = true;
                        var blob = new Blob( [ bufferView ], {
                            type: sourceDef.mimeType
                        } );
                        sourceURI = URL.createObjectURL( blob );
                        return sourceURI;
                    } );
                } else if ( sourceDef.uri === undefined ) {
                    throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );
                }
                var promise = Promise.resolve( sourceURI ).then( function( sourceURI ) {
                    return new Promise( function( resolve, reject ) {
                        var onLoad = resolve;
                        if ( loader.isImageBitmapLoader === true ) {
                            onLoad = function onLoad( imageBitmap ) {
                                var texture = new Texture( imageBitmap );
                                texture.needsUpdate = true;
                                resolve( texture );
                            };
                        }
                        loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );
                    } );
                } ).then( function( texture ) { // Clean up resources and configure Texture.
                    if ( isObjectURL === true ) {
                        URL.revokeObjectURL( sourceURI );
                    }
                    texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );
                    return texture;
                } )[ "catch" ]( function( error ) {
                    console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
                    throw error;
                } );
                this.sourceCache[ sourceIndex ] = promise;
                return promise;
            }
            /**
             * Asynchronously assigns a texture to the given material parameters.
             * @param {Object} materialParams
             * @param {string} mapName
             * @param {Object} mapDef
             * @return {Promise<Texture>}
             */
        }, {
            key: "assignTexture",
            value: function assignTexture( materialParams, mapName, mapDef, encoding ) {
                var parser = this;
                return this.getDependency( 'texture', mapDef.index ).then( function( texture ) { // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
                    // However, we will copy UV set 0 to UV set 1 on demand for aoMap
                    if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {
                        console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );
                    }
                    if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {
                        var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;
                        if ( transform ) {
                            var gltfReference = parser.associations.get( texture );
                            texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
                            parser.associations.set( texture, gltfReference );
                        }
                    }
                    if ( encoding !== undefined ) {
                        texture.encoding = encoding;
                    }
                    materialParams[ mapName ] = texture;
                    return texture;
                } );
            }
            /**
             * Assigns final material to a Mesh, Line, or Points instance. The instance
             * already has a material (generated from the glTF material options alone)
             * but reuse of the same glTF material may require multiple threejs materials
             * to accommodate different primitive types, defines, etc. New materials will
             * be created if necessary, and reused from a cache.
             * @param  {Object3D} mesh Mesh, Line, or Points instance.
             */
        }, {
            key: "assignFinalMaterial",
            value: function assignFinalMaterial( mesh ) {
                var geometry = mesh.geometry;
                var material = mesh.material;
                var useDerivativeTangents = geometry.attributes.tangent === undefined;
                var useVertexColors = geometry.attributes.color !== undefined;
                var useFlatShading = geometry.attributes.normal === undefined;
                if ( mesh.isPoints ) {
                    var cacheKey = 'PointsMaterial:' + material.uuid;
                    var pointsMaterial = this.cache.get( cacheKey );
                    if ( !pointsMaterial ) {
                        pointsMaterial = new PointsMaterial( );
                        Material$1.prototype.copy.call( pointsMaterial, material );
                        pointsMaterial.color.copy( material.color );
                        pointsMaterial.map = material.map;
                        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px
                        this.cache.add( cacheKey, pointsMaterial );
                    }
                    material = pointsMaterial;
                } else if ( mesh.isLine ) {
                    var _cacheKey = 'LineBasicMaterial:' + material.uuid;
                    var lineMaterial = this.cache.get( _cacheKey );
                    if ( !lineMaterial ) {
                        lineMaterial = new LineBasicMaterial( );
                        Material$1.prototype.copy.call( lineMaterial, material );
                        lineMaterial.color.copy( material.color );
                        this.cache.add( _cacheKey, lineMaterial );
                    }
                    material = lineMaterial;
                } // Clone the material if it will be modified
                if ( useDerivativeTangents || useVertexColors || useFlatShading ) {
                    var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';
                    if ( material.isGLTFSpecularGlossinessMaterial ) _cacheKey2 += 'specular-glossiness:';
                    if ( useDerivativeTangents ) _cacheKey2 += 'derivative-tangents:';
                    if ( useVertexColors ) _cacheKey2 += 'vertex-colors:';
                    if ( useFlatShading ) _cacheKey2 += 'flat-shading:';
                    var cachedMaterial = this.cache.get( _cacheKey2 );
                    if ( !cachedMaterial ) {
                        cachedMaterial = material.clone( );
                        if ( useVertexColors ) cachedMaterial.vertexColors = true;
                        if ( useFlatShading ) cachedMaterial.flatShading = true;
                        if ( useDerivativeTangents ) { // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
                            if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= -1;
                            if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= -1;
                        }
                        this.cache.add( _cacheKey2, cachedMaterial );
                        this.associations.set( cachedMaterial, this.associations.get( material ) );
                    }
                    material = cachedMaterial;
                } // workarounds for mesh and geometry
                if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {
                    geometry.setAttribute( 'uv2', geometry.attributes.uv );
                }
                mesh.material = material;
            }
        }, {
            key: "getMaterialType",
            value: function /* materialIndex */ getMaterialType( ) {
                return MeshStandardMaterial;
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
             * @param {number} materialIndex
             * @return {Promise<Material>}
             */
        }, {
            key: "loadMaterial",
            value: function loadMaterial( materialIndex ) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions;
                var materialDef = json.materials[ materialIndex ];
                var materialType;
                var materialParams = {};
                var materialExtensions = materialDef.extensions || {};
                var pending = [ ];
                if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {
                    var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
                    materialType = sgExtension.getMaterialType( );
                    pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );
                } else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {
                    var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
                    materialType = kmuExtension.getMaterialType( );
                    pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );
                } else { // Specification:
                    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
                    var metallicRoughness = materialDef.pbrMetallicRoughness || {};
                    materialParams.color = new Color( 1.0, 1.0, 1.0 );
                    materialParams.opacity = 1.0;
                    if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {
                        var array = metallicRoughness.baseColorFactor;
                        materialParams.color.fromArray( array );
                        materialParams.opacity = array[ 3 ];
                    }
                    if ( metallicRoughness.baseColorTexture !== undefined ) {
                        pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );
                    }
                    materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
                    materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
                    if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {
                        pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
                        pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );
                    }
                    materialType = this._invokeOne( function( ext ) {
                        return ext.getMaterialType && ext.getMaterialType( materialIndex );
                    } );
                    pending.push( Promise.all( this._invokeAll( function( ext ) {
                        return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );
                    } ) ) );
                }
                if ( materialDef.doubleSided === true ) {
                    materialParams.side = DoubleSide;
                }
                var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
                if ( alphaMode === ALPHA_MODES.BLEND ) {
                    materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706
                    materialParams.depthWrite = false;
                } else {
                    materialParams.transparent = false;
                    if ( alphaMode === ALPHA_MODES.MASK ) {
                        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
                    }
                }
                if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {
                    pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );
                    materialParams.normalScale = new Vector2( 1, 1 );
                    if ( materialDef.normalTexture.scale !== undefined ) {
                        var scale = materialDef.normalTexture.scale;
                        materialParams.normalScale.set( scale, scale );
                    }
                }
                if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {
                    pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );
                    if ( materialDef.occlusionTexture.strength !== undefined ) {
                        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
                    }
                }
                if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {
                    materialParams.emissive = new Color( ).fromArray( materialDef.emissiveFactor );
                }
                if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {
                    pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );
                }
                return Promise.all( pending ).then( function( ) {
                    var material;
                    if ( materialType === GLTFMeshStandardSGMaterial ) {
                        material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );
                    } else {
                        material = new materialType( materialParams );
                    }
                    if ( materialDef.name ) material.name = materialDef.name;
                    assignExtrasToUserData( material, materialDef );
                    parser.associations.set( material, {
                        materials: materialIndex
                    } );
                    if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );
                    return material;
                } );
            } /** When Object3D instances are targeted by animation, they need unique names. */
        }, {
            key: "createUniqueName",
            value: function createUniqueName( originalName ) {
                var sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );
                var name = sanitizedName;
                for ( var _i246 = 1; this.nodeNamesUsed[ name ]; ++_i246 ) {
                    name = sanitizedName + '_' + _i246;
                }
                this.nodeNamesUsed[ name ] = true;
                return name;
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
             *
             * Creates BufferGeometries from primitives.
             *
             * @param {Array<GLTF.Primitive>} primitives
             * @return {Promise<Array<BufferGeometry>>}
             */
        }, {
            key: "loadGeometries",
            value: function loadGeometries( primitives ) {
                var parser = this;
                var extensions = this.extensions;
                var cache = this.primitiveCache;

                function createDracoPrimitive( primitive ) {
                    return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ].decodePrimitive( primitive, parser ).then( function( geometry ) {
                        return addPrimitiveAttributes( geometry, primitive, parser );
                    } );
                }
                var pending = [ ];
                for ( var _i247 = 0, il = primitives.length; _i247 < il; _i247++ ) {
                    var primitive = primitives[ _i247 ];
                    var cacheKey = createPrimitiveKey( primitive ); // See if we've already created this geometry
                    var cached = cache[ cacheKey ];
                    if ( cached ) { // Use the cached geometry if it exists
                        pending.push( cached.promise );
                    } else {
                        var geometryPromise = void 0;
                        if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) { // Use DRACO geometry if available
                            geometryPromise = createDracoPrimitive( primitive );
                        } else { // Otherwise create a new geometry
                            geometryPromise = addPrimitiveAttributes( new BufferGeometry( ), primitive, parser );
                        } // Cache this geometry
                        cache[ cacheKey ] = {
                            primitive: primitive,
                            promise: geometryPromise
                        };
                        pending.push( geometryPromise );
                    }
                }
                return Promise.all( pending );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
             * @param {number} meshIndex
             * @return {Promise<Group|Mesh|SkinnedMesh>}
             */
        }, {
            key: "loadMesh",
            value: function loadMesh( meshIndex ) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions;
                var meshDef = json.meshes[ meshIndex ];
                var primitives = meshDef.primitives;
                var pending = [ ];
                for ( var _i248 = 0, il = primitives.length; _i248 < il; _i248++ ) {
                    var material = primitives[ _i248 ].material === undefined ? createDefaultMaterial( this.cache ) : this.getDependency( 'material', primitives[ _i248 ].material );
                    pending.push( material );
                }
                pending.push( parser.loadGeometries( primitives ) );
                return Promise.all( pending ).then( function( results ) {
                    var materials = results.slice( 0, results.length - 1 );
                    var geometries = results[ results.length - 1 ];
                    var meshes = [ ];
                    for ( var _i249 = 0, _il15 = geometries.length; _i249 < _il15; _i249++ ) {
                        var geometry = geometries[ _i249 ];
                        var primitive = primitives[ _i249 ]; // 1. create Mesh
                        var mesh = void 0;
                        var _material2 = materials[ _i249 ];
                        if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) { // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
                            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh( geometry, _material2 ) : new Mesh( geometry, _material2 );
                            if ( mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized ) { // we normalize floating point skin weight array to fix malformed assets (see #15319)
                                // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                                mesh.normalizeSkinWeights( );
                            }
                            if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {
                                mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );
                            } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {
                                mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );
                            }
                        } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {
                            mesh = new LineSegments( geometry, _material2 );
                        } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {
                            mesh = new Line( geometry, _material2 );
                        } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {
                            mesh = new LineLoop( geometry, _material2 );
                        } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {
                            mesh = new Points( geometry, _material2 );
                        } else {
                            throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );
                        }
                        if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {
                            updateMorphTargets( mesh, meshDef );
                        }
                        mesh.name = parser.createUniqueName( meshDef.name || 'mesh_' + meshIndex );
                        assignExtrasToUserData( mesh, meshDef );
                        if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );
                        parser.assignFinalMaterial( mesh );
                        meshes.push( mesh );
                    }
                    for ( var _i250 = 0, _il16 = meshes.length; _i250 < _il16; _i250++ ) {
                        parser.associations.set( meshes[ _i250 ], {
                            meshes: meshIndex,
                            primitives: _i250
                        } );
                    }
                    if ( meshes.length === 1 ) {
                        return meshes[ 0 ];
                    }
                    var group = new Group$1( );
                    parser.associations.set( group, {
                        meshes: meshIndex
                    } );
                    for ( var _i251 = 0, _il17 = meshes.length; _i251 < _il17; _i251++ ) {
                        group.add( meshes[ _i251 ] );
                    }
                    return group;
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
             * @param {number} cameraIndex
             * @return {Promise<THREE.Camera>}
             */
        }, {
            key: "loadCamera",
            value: function loadCamera( cameraIndex ) {
                var camera;
                var cameraDef = this.json.cameras[ cameraIndex ];
                var params = cameraDef[ cameraDef.type ];
                if ( !params ) {
                    console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
                    return;
                }
                if ( cameraDef.type === 'perspective' ) {
                    camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );
                } else if ( cameraDef.type === 'orthographic' ) {
                    camera = new OrthographicCamera( -params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar );
                }
                if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );
                assignExtrasToUserData( camera, cameraDef );
                return Promise.resolve( camera );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
             * @param {number} skinIndex
             * @return {Promise<Object>}
             */
        }, {
            key: "loadSkin",
            value: function loadSkin( skinIndex ) {
                var skinDef = this.json.skins[ skinIndex ];
                var skinEntry = {
                    joints: skinDef.joints
                };
                if ( skinDef.inverseBindMatrices === undefined ) {
                    return Promise.resolve( skinEntry );
                }
                return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function( accessor ) {
                    skinEntry.inverseBindMatrices = accessor;
                    return skinEntry;
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
             * @param {number} animationIndex
             * @return {Promise<AnimationClip>}
             */
        }, {
            key: "loadAnimation",
            value: function loadAnimation( animationIndex ) {
                var json = this.json;
                var animationDef = json.animations[ animationIndex ];
                var pendingNodes = [ ];
                var pendingInputAccessors = [ ];
                var pendingOutputAccessors = [ ];
                var pendingSamplers = [ ];
                var pendingTargets = [ ];
                for ( var _i252 = 0, il = animationDef.channels.length; _i252 < il; _i252++ ) {
                    var channel = animationDef.channels[ _i252 ];
                    var sampler = animationDef.samplers[ channel.sampler ];
                    var target = channel.target;
                    var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
                    var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
                    var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;
                    pendingNodes.push( this.getDependency( 'node', name ) );
                    pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
                    pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
                    pendingSamplers.push( sampler );
                    pendingTargets.push( target );
                }
                return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function( dependencies ) {
                    var nodes = dependencies[ 0 ];
                    var inputAccessors = dependencies[ 1 ];
                    var outputAccessors = dependencies[ 2 ];
                    var samplers = dependencies[ 3 ];
                    var targets = dependencies[ 4 ];
                    var tracks = [ ];
                    var _loop2 = function _loop2( _i253, _il18 ) {
                        var node = nodes[ _i253 ];
                        var inputAccessor = inputAccessors[ _i253 ];
                        var outputAccessor = outputAccessors[ _i253 ];
                        var sampler = samplers[ _i253 ];
                        var target = targets[ _i253 ];
                        if ( node === undefined ) return "continue";
                        node.updateMatrix( );
                        node.matrixAutoUpdate = true;
                        var TypedKeyframeTrack = void 0;
                        switch ( PATH_PROPERTIES[ target.path ] ) {
                            case PATH_PROPERTIES.weights:
                                TypedKeyframeTrack = NumberKeyframeTrack;
                                break;
                            case PATH_PROPERTIES.rotation:
                                TypedKeyframeTrack = QuaternionKeyframeTrack;
                                break;
                            case PATH_PROPERTIES.position:
                            case PATH_PROPERTIES.scale:
                            default:
                                TypedKeyframeTrack = VectorKeyframeTrack;
                                break;
                        }
                        var targetName = node.name ? node.name : node.uuid;
                        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;
                        var targetNames = [ ];
                        if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {
                            node.traverse( function( object ) {
                                if ( object.morphTargetInfluences ) {
                                    targetNames.push( object.name ? object.name : object.uuid );
                                }
                            } );
                        } else {
                            targetNames.push( targetName );
                        }
                        var outputArray = outputAccessor.array;
                        if ( outputAccessor.normalized ) {
                            var scale = getNormalizedComponentScale( outputArray.constructor );
                            var scaled = new Float32Array( outputArray.length );
                            for ( var j = 0, jl = outputArray.length; j < jl; j++ ) {
                                scaled[ j ] = outputArray[ j ] * scale;
                            }
                            outputArray = scaled;
                        }
                        for ( var _j7 = 0, _jl3 = targetNames.length; _j7 < _jl3; _j7++ ) {
                            var track = new TypedKeyframeTrack( targetNames[ _j7 ] + '.' + PATH_PROPERTIES[ target.path ], inputAccessor.array, outputArray, interpolation ); // Override interpolation with custom factory method.
                            if ( sampler.interpolation === 'CUBICSPLINE' ) {
                                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) { // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                                    // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                                    // must be divided by three to get the interpolant's sampleSize argument.
                                    var interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                                    return new interpolantType( this.times, this.values, this.getValueSize( ) / 3, result );
                                }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
                            }
                            tracks.push( track );
                        }
                    };
                    for ( var _i253 = 0, _il18 = nodes.length; _i253 < _il18; _i253++ ) {
                        var _ret2 = _loop2( _i253, _il18 );
                        if ( _ret2 === "continue" ) continue;
                    }
                    var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
                    return new AnimationClip( name, undefined, tracks );
                } );
            }
        }, {
            key: "createNodeMesh",
            value: function createNodeMesh( nodeIndex ) {
                var json = this.json;
                var parser = this;
                var nodeDef = json.nodes[ nodeIndex ];
                if ( nodeDef.mesh === undefined ) return null;
                return parser.getDependency( 'mesh', nodeDef.mesh ).then( function( mesh ) {
                    var node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh ); // if weights are provided on the node, override weights on the mesh.
                    if ( nodeDef.weights !== undefined ) {
                        node.traverse( function( o ) {
                            if ( !o.isMesh ) return;
                            for ( var _i254 = 0, il = nodeDef.weights.length; _i254 < il; _i254++ ) {
                                o.morphTargetInfluences[ _i254 ] = nodeDef.weights[ _i254 ];
                            }
                        } );
                    }
                    return node;
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
             * @param {number} nodeIndex
             * @return {Promise<Object3D>}
             */
        }, {
            key: "loadNode",
            value: function loadNode( nodeIndex ) {
                var json = this.json;
                var extensions = this.extensions;
                var parser = this;
                var nodeDef = json.nodes[ nodeIndex ]; // reserve node's name before its dependencies, so the root has the intended name.
                var nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';
                return function( ) {
                    var pending = [ ];
                    var meshPromise = parser._invokeOne( function( ext ) {
                        return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );
                    } );
                    if ( meshPromise ) {
                        pending.push( meshPromise );
                    }
                    if ( nodeDef.camera !== undefined ) {
                        pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function( camera ) {
                            return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );
                        } ) );
                    }
                    parser._invokeAll( function( ext ) {
                        return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );
                    } ).forEach( function( promise ) {
                        pending.push( promise );
                    } );
                    return Promise.all( pending );
                }( ).then( function( objects ) {
                    var node; // .isBone isn't in glTF spec. See ._markDefs
                    if ( nodeDef.isBone === true ) {
                        node = new Bone( );
                    } else if ( objects.length > 1 ) {
                        node = new Group$1( );
                    } else if ( objects.length === 1 ) {
                        node = objects[ 0 ];
                    } else {
                        node = new Object3D( );
                    }
                    if ( node !== objects[ 0 ] ) {
                        for ( var _i255 = 0, il = objects.length; _i255 < il; _i255++ ) {
                            node.add( objects[ _i255 ] );
                        }
                    }
                    if ( nodeDef.name ) {
                        node.userData.name = nodeDef.name;
                        node.name = nodeName;
                    }
                    assignExtrasToUserData( node, nodeDef );
                    if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );
                    if ( nodeDef.matrix !== undefined ) {
                        var matrix = new Matrix4( );
                        matrix.fromArray( nodeDef.matrix );
                        node.applyMatrix4( matrix );
                    } else {
                        if ( nodeDef.translation !== undefined ) {
                            node.position.fromArray( nodeDef.translation );
                        }
                        if ( nodeDef.rotation !== undefined ) {
                            node.quaternion.fromArray( nodeDef.rotation );
                        }
                        if ( nodeDef.scale !== undefined ) {
                            node.scale.fromArray( nodeDef.scale );
                        }
                    }
                    if ( !parser.associations.has( node ) ) {
                        parser.associations.set( node, {} );
                    }
                    parser.associations.get( node ).nodes = nodeIndex;
                    return node;
                } );
            }
            /**
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
             * @param {number} sceneIndex
             * @return {Promise<Group>}
             */
        }, {
            key: "loadScene",
            value: function loadScene( sceneIndex ) {
                var json = this.json;
                var extensions = this.extensions;
                var sceneDef = this.json.scenes[ sceneIndex ];
                var parser = this; // Loader returns Group, not Scene.
                // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
                var scene = new Group$1( );
                if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );
                assignExtrasToUserData( scene, sceneDef );
                if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );
                var nodeIds = sceneDef.nodes || [ ];
                var pending = [ ];
                for ( var _i256 = 0, il = nodeIds.length; _i256 < il; _i256++ ) {
                    pending.push( buildNodeHierarchy( nodeIds[ _i256 ], scene, json, parser ) );
                }
                return Promise.all( pending ).then( function( ) { // Removes dangling associations, associations that reference a node that
                    // didn't make it into the scene.
                    var reduceAssociations = function reduceAssociations( node ) {
                        var reducedAssociations = new Map( );
                        var _iterator4 = _createForOfIteratorHelper( parser.associations ),
                            _step4;
                        try {
                            for ( _iterator4.s( ); !( _step4 = _iterator4.n( ) ).done; ) {
                                var _step4$value = _slicedToArray( _step4.value, 2 ),
                                    key = _step4$value[ 0 ],
                                    _value7 = _step4$value[ 1 ];
                                if ( key instanceof Material$1 || key instanceof Texture ) {
                                    reducedAssociations.set( key, _value7 );
                                }
                            }
                        } catch ( err ) {
                            _iterator4.e( err );
                        } finally {
                            _iterator4.f( );
                        }
                        node.traverse( function( node ) {
                            var mappings = parser.associations.get( node );
                            if ( mappings != null ) {
                                reducedAssociations.set( node, mappings );
                            }
                        } );
                        return reducedAssociations;
                    };
                    parser.associations = reduceAssociations( scene );
                    return scene;
                } );
            }
        } ] );
        return GLTFParser;
    }( );

    function buildNodeHierarchy( nodeId, parentObject, json, parser ) {
        var nodeDef = json.nodes[ nodeId ];
        return parser.getDependency( 'node', nodeId ).then( function( node ) {
            if ( nodeDef.skin === undefined ) return node; // build skeleton here as well
            var skinEntry;
            return parser.getDependency( 'skin', nodeDef.skin ).then( function( skin ) {
                skinEntry = skin;
                var pendingJoints = [ ];
                for ( var _i257 = 0, il = skinEntry.joints.length; _i257 < il; _i257++ ) {
                    pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ _i257 ] ) );
                }
                return Promise.all( pendingJoints );
            } ).then( function( jointNodes ) {
                node.traverse( function( mesh ) {
                    if ( !mesh.isMesh ) return;
                    var bones = [ ];
                    var boneInverses = [ ];
                    for ( var j = 0, jl = jointNodes.length; j < jl; j++ ) {
                        var jointNode = jointNodes[ j ];
                        if ( jointNode ) {
                            bones.push( jointNode );
                            var mat = new Matrix4( );
                            if ( skinEntry.inverseBindMatrices !== undefined ) {
                                mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );
                            }
                            boneInverses.push( mat );
                        } else {
                            console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );
                        }
                    }
                    mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );
                } );
                return node;
            } );
        } ).then( function( node ) { // build node hierachy
            parentObject.add( node );
            var pending = [ ];
            if ( nodeDef.children ) {
                var children = nodeDef.children;
                for ( var _i258 = 0, il = children.length; _i258 < il; _i258++ ) {
                    var child = children[ _i258 ];
                    pending.push( buildNodeHierarchy( child, node, json, parser ) );
                }
            }
            return Promise.all( pending );
        } );
    }
    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     */
    function computeBounds( geometry, primitiveDef, parser ) {
        var attributes = primitiveDef.attributes;
        var box = new Box3( );
        if ( attributes.POSITION !== undefined ) {
            var accessor = parser.json.accessors[ attributes.POSITION ];
            var min = accessor.min;
            var _max2 = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
            if ( min !== undefined && _max2 !== undefined ) {
                box.set( new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ), new Vector3( _max2[ 0 ], _max2[ 1 ], _max2[ 2 ] ) );
                if ( accessor.normalized ) {
                    var boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
                    box.min.multiplyScalar( boxScale );
                    box.max.multiplyScalar( boxScale );
                }
            } else {
                console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );
                return;
            }
        } else {
            return;
        }
        var targets = primitiveDef.targets;
        if ( targets !== undefined ) {
            var maxDisplacement = new Vector3( );
            var vector = new Vector3( );
            for ( var _i259 = 0, il = targets.length; _i259 < il; _i259++ ) {
                var target = targets[ _i259 ];
                if ( target.POSITION !== undefined ) {
                    var _accessor = parser.json.accessors[ target.POSITION ];
                    var _min = _accessor.min;
                    var _max3 = _accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
                    if ( _min !== undefined && _max3 !== undefined ) { // we need to get max of absolute components because target weight is [-1,1]
                        vector.setX( Math.max( Math.abs( _min[ 0 ] ), Math.abs( _max3[ 0 ] ) ) );
                        vector.setY( Math.max( Math.abs( _min[ 1 ] ), Math.abs( _max3[ 1 ] ) ) );
                        vector.setZ( Math.max( Math.abs( _min[ 2 ] ), Math.abs( _max3[ 2 ] ) ) );
                        if ( _accessor.normalized ) {
                            var _boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ _accessor.componentType ] );
                            vector.multiplyScalar( _boxScale );
                        } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
                        // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
                        // are used to implement key-frame animations and as such only two are active at a time - this results in very large
                        // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
                        maxDisplacement.max( vector );
                    } else {
                        console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );
                    }
                }
            } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
            box.expandByVector( maxDisplacement );
        }
        geometry.boundingBox = box;
        var sphere = new Sphere( );
        box.getCenter( sphere.center );
        sphere.radius = box.min.distanceTo( box.max ) / 2;
        geometry.boundingSphere = sphere;
    }
    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */
    function addPrimitiveAttributes( geometry, primitiveDef, parser ) {
        var attributes = primitiveDef.attributes;
        var pending = [ ];

        function assignAttributeAccessor( accessorIndex, attributeName ) {
            return parser.getDependency( 'accessor', accessorIndex ).then( function( accessor ) {
                geometry.setAttribute( attributeName, accessor );
            } );
        }
        for ( var gltfAttributeName in attributes ) {
            var threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase( ); // Skip attributes already provided by e.g. Draco extension.
            if ( threeAttributeName in geometry.attributes ) continue;
            pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );
        }
        if ( primitiveDef.indices !== undefined && !geometry.index ) {
            var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function( accessor ) {
                geometry.setIndex( accessor );
            } );
            pending.push( accessor );
        }
        assignExtrasToUserData( geometry, primitiveDef );
        computeBounds( geometry, primitiveDef, parser );
        return Promise.all( pending ).then( function( ) {
            return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry;
        } );
    }
    /**
     * @param {BufferGeometry} geometry
     * @param {Number} drawMode
     * @return {BufferGeometry}
     */
    function toTrianglesDrawMode( geometry, drawMode ) {
        var index = geometry.getIndex( ); // generate index if not present
        if ( index === null ) {
            var indices = [ ];
            var position = geometry.getAttribute( 'position' );
            if ( position !== undefined ) {
                for ( var _i260 = 0; _i260 < position.count; _i260++ ) {
                    indices.push( _i260 );
                }
                geometry.setIndex( indices );
                index = geometry.getIndex( );
            } else {
                console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
                return geometry;
            }
        } //
        var numberOfTriangles = index.count - 2;
        var newIndices = [ ];
        if ( drawMode === TriangleFanDrawMode ) { // gl.TRIANGLE_FAN
            for ( var _i261 = 1; _i261 <= numberOfTriangles; _i261++ ) {
                newIndices.push( index.getX( 0 ) );
                newIndices.push( index.getX( _i261 ) );
                newIndices.push( index.getX( _i261 + 1 ) );
            }
        } else { // gl.TRIANGLE_STRIP
            for ( var _i262 = 0; _i262 < numberOfTriangles; _i262++ ) {
                if ( _i262 % 2 === 0 ) {
                    newIndices.push( index.getX( _i262 ) );
                    newIndices.push( index.getX( _i262 + 1 ) );
                    newIndices.push( index.getX( _i262 + 2 ) );
                } else {
                    newIndices.push( index.getX( _i262 + 2 ) );
                    newIndices.push( index.getX( _i262 + 1 ) );
                    newIndices.push( index.getX( _i262 ) );
                }
            }
        }
        if ( newIndices.length / 3 !== numberOfTriangles ) {
            console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );
        } // build final geometry
        var newGeometry = geometry.clone( );
        newGeometry.setIndex( newIndices );
        return newGeometry;
    }
    /*!
    	fflate - fast JavaScript compression/decompression
    	<https://101arrowz.github.io/fflate>
    	Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
    	version 0.6.9
    	*/ // DEFLATE is a complex format; to read this code, you should probably check the RFC first:
    // https://tools.ietf.org/html/rfc1951
    // You may also wish to take a look at the guide I made about this program:
    // https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
    // Some of the following code is similar to that of UZIP.js:
    // https://github.com/photopea/UZIP.js
    // However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
    // Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
    // is better for memory in most engines (I *think*).
    var ch2 = {};
    var durl = function durl( c ) {
        return URL.createObjectURL( new Blob( [ c ], {
            type: 'text/javascript'
        } ) );
    };
    var cwk = function cwk( u ) {
        return new Worker( u );
    };
    try {
        URL.revokeObjectURL( durl( '' ) );
    } catch ( e ) { // We're in Deno or a very old browser
        durl = function durl( c ) {
            return 'data:application/javascript;charset=UTF-8,' + encodeURI( c );
        }; // If Deno, this is necessary; if not, this changes nothing
        cwk = function cwk( u ) {
            return new Worker( u, {
                type: 'module'
            } );
        };
    }
    var wk = function wk( c, id, msg, transfer, cb ) {
        var w = cwk( ch2[ id ] || ( ch2[ id ] = durl( c ) ) );
        w.onerror = function( e ) {
            return cb( e.error, null );
        };
        w.onmessage = function( e ) {
            return cb( null, e.data );
        };
        w.postMessage( msg, transfer );
        return w;
    }; // aliases for shorter compressed code (most minifers don't do this)
    var u8 = Uint8Array,
        u16 = Uint16Array,
        u32 = Uint32Array; // fixed length extra bits
    var fleb = new u8( [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0 ] ); // fixed distance extra bits
    // see fleb note
    var fdeb = new u8( [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0 ] ); // code length index map
    var clim = new u8( [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ] ); // get base, reverse index map from extra bits
    var freb = function freb( eb, start ) {
        var b = new u16( 31 );
        for ( var i = 0; i < 31; ++i ) {
            b[ i ] = start += 1 << eb[ i - 1 ];
        } // numbers here are at max 18 bits
        var r = new u32( b[ 30 ] );
        for ( var i = 1; i < 30; ++i ) {
            for ( var j = b[ i ]; j < b[ i + 1 ]; ++j ) {
                r[ j ] = j - b[ i ] << 5 | i;
            }
        }
        return [ b, r ];
    };
    var _a = freb( fleb, 2 ),
        fl = _a[ 0 ],
        revfl = _a[ 1 ]; // we can ignore the fact that the other numbers are wrong; they never happen anyway
    fl[ 28 ] = 258, revfl[ 258 ] = 28;
    var _b = freb( fdeb, 0 ),
        fd = _b[ 0 ],
        revfd = _b[ 1 ]; // map of value to reverse (assuming 16 bits)
    var rev = new u16( 32768 );
    for ( var i = 0; i < 32768; ++i ) { // reverse table algorithm from SO
        var x = ( i & 0xAAAA ) >>> 1 | ( i & 0x5555 ) << 1;
        x = ( x & 0xCCCC ) >>> 2 | ( x & 0x3333 ) << 2;
        x = ( x & 0xF0F0 ) >>> 4 | ( x & 0x0F0F ) << 4;
        rev[ i ] = ( ( x & 0xFF00 ) >>> 8 | ( x & 0x00FF ) << 8 ) >>> 1;
    } // create huffman tree from u8 "map": index -> code length for code index
    // mb (max bits) must be at most 15
    // TODO: optimize/split up?
    var hMap = function hMap( cd, mb, r ) {
        var s = cd.length; // index
        var i = 0; // u16 "map": index -> # of codes with bit length = index
        var l = new u16( mb ); // length of cd must be 288 (total # of codes)
        for ( ; i < s; ++i ) {
            ++l[ cd[ i ] - 1 ];
        } // u16 "map": index -> minimum code for bit length = index
        var le = new u16( mb );
        for ( i = 0; i < mb; ++i ) {
            le[ i ] = le[ i - 1 ] + l[ i - 1 ] << 1;
        }
        var co;
        if ( r ) { // u16 "map": index -> number of actual bits, symbol for code
            co = new u16( 1 << mb ); // bits to remove for reverser
            var rvb = 15 - mb;
            for ( i = 0; i < s; ++i ) { // ignore 0 lengths
                if ( cd[ i ] ) { // num encoding both symbol and bits read
                    var sv = i << 4 | cd[ i ]; // free bits
                    var r_1 = mb - cd[ i ]; // start value
                    var v = le[ cd[ i ] - 1 ]++ << r_1; // m is end value
                    for ( var m = v | ( 1 << r_1 ) - 1; v <= m; ++v ) { // every 16 bit value starting with the code yields the same result
                        co[ rev[ v ] >>> rvb ] = sv;
                    }
                }
            }
        } else {
            co = new u16( s );
            for ( i = 0; i < s; ++i ) {
                if ( cd[ i ] ) {
                    co[ i ] = rev[ le[ cd[ i ] - 1 ]++ ] >>> 15 - cd[ i ];
                }
            }
        }
        return co;
    }; // fixed length tree
    var flt = new u8( 288 );
    for ( var i = 0; i < 144; ++i ) {
        flt[ i ] = 8;
    }
    for ( var i = 144; i < 256; ++i ) {
        flt[ i ] = 9;
    }
    for ( var i = 256; i < 280; ++i ) {
        flt[ i ] = 7;
    }
    for ( var i = 280; i < 288; ++i ) {
        flt[ i ] = 8;
    } // fixed distance tree
    var fdt = new u8( 32 );
    for ( var i = 0; i < 32; ++i ) {
        fdt[ i ] = 5;
    } // fixed length map
    var flm = /*#__PURE__*/ hMap( flt, 9, 0 ),
        flrm = /*#__PURE__*/ hMap( flt, 9, 1 ); // fixed distance map
    var fdm = /*#__PURE__*/ hMap( fdt, 5, 0 ),
        fdrm = /*#__PURE__*/ hMap( fdt, 5, 1 ); // find max of array
    var max = function max( a ) {
        var m = a[ 0 ];
        for ( var i = 1; i < a.length; ++i ) {
            if ( a[ i ] > m ) m = a[ i ];
        }
        return m;
    }; // read d, starting at bit p and mask with m
    var bits = function bits( d, p, m ) {
        var o = p / 8 | 0;
        return ( d[ o ] | d[ o + 1 ] << 8 ) >> ( p & 7 ) & m;
    }; // read d, starting at bit p continuing for at least 16 bits
    var bits16 = function bits16( d, p ) {
        var o = p / 8 | 0;
        return ( d[ o ] | d[ o + 1 ] << 8 | d[ o + 2 ] << 16 ) >> ( p & 7 );
    }; // get end of byte
    var shft = function shft( p ) {
        return ( p / 8 | 0 ) + ( p & 7 && 1 );
    }; // typed array slice - allows garbage collector to free original reference,
    // while being more compatible than .slice
    var slc = function slc( v, s, e ) {
        if ( s == null || s < 0 ) s = 0;
        if ( e == null || e > v.length ) e = v.length; // can't use .constructor in case user-supplied
        var n = new( v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8 )( e - s );
        n.set( v.subarray( s, e ) );
        return n;
    }; // expands raw DEFLATE data
    var inflt = function inflt( dat, buf, st ) { // source length
        var sl = dat.length;
        if ( !sl || st && !st.l && sl < 5 ) return buf || new u8( 0 ); // have to estimate size
        var noBuf = !buf || st; // no state
        var noSt = !st || st.i;
        if ( !st ) st = {}; // Assumes roughly 33% compression ratio average
        if ( !buf ) buf = new u8( sl * 3 ); // ensure buffer can fit at least l elements
        var cbuf = function cbuf( l ) {
            var bl = buf.length; // need to increase size to fit
            if ( l > bl ) { // Double or set to necessary, whichever is greater
                var nbuf = new u8( Math.max( bl * 2, l ) );
                nbuf.set( buf );
                buf = nbuf;
            }
        }; //  last chunk         bitpos           bytes
        var _final = st.f || 0,
            pos = st.p || 0,
            bt = st.b || 0,
            lm = st.l,
            dm = st.d,
            lbt = st.m,
            dbt = st.n; // total bits
        var tbts = sl * 8;
        do {
            if ( !lm ) { // BFINAL - this is only 1 when last chunk is next
                st.f = _final = bits( dat, pos, 1 ); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
                var type = bits( dat, pos + 1, 3 );
                pos += 3;
                if ( !type ) { // go to end of byte boundary
                    var s = shft( pos ) + 4,
                        l = dat[ s - 4 ] | dat[ s - 3 ] << 8,
                        t = s + l;
                    if ( t > sl ) {
                        if ( noSt ) throw 'unexpected EOF';
                        break;
                    } // ensure size
                    if ( noBuf ) cbuf( bt + l ); // Copy over uncompressed data
                    buf.set( dat.subarray( s, t ), bt ); // Get new bitpos, update byte count
                    st.b = bt += l, st.p = pos = t * 8;
                    continue;
                } else if ( type == 1 ) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
                else if ( type == 2 ) { //  literal                            lengths
                    var hLit = bits( dat, pos, 31 ) + 257,
                        hcLen = bits( dat, pos + 10, 15 ) + 4;
                    var tl = hLit + bits( dat, pos + 5, 31 ) + 1;
                    pos += 14; // length+distance tree
                    var ldt = new u8( tl ); // code length tree
                    var clt = new u8( 19 );
                    for ( var i = 0; i < hcLen; ++i ) { // use index map to get real code
                        clt[ clim[ i ] ] = bits( dat, pos + i * 3, 7 );
                    }
                    pos += hcLen * 3; // code lengths bits
                    var clb = max( clt ),
                        clbmsk = ( 1 << clb ) - 1; // code lengths map
                    var clm = hMap( clt, clb, 1 );
                    for ( var i = 0; i < tl; ) {
                        var r = clm[ bits( dat, pos, clbmsk ) ]; // bits read
                        pos += r & 15; // symbol
                        var s = r >>> 4; // code length to copy
                        if ( s < 16 ) {
                            ldt[ i++ ] = s;
                        } else { //  copy   count
                            var c = 0,
                                n = 0;
                            if ( s == 16 ) n = 3 + bits( dat, pos, 3 ), pos += 2, c = ldt[ i - 1 ];
                            else if ( s == 17 ) n = 3 + bits( dat, pos, 7 ), pos += 3;
                            else if ( s == 18 ) n = 11 + bits( dat, pos, 127 ), pos += 7;
                            while ( n-- ) {
                                ldt[ i++ ] = c;
                            }
                        }
                    } //    length tree                 distance tree
                    var lt = ldt.subarray( 0, hLit ),
                        dt = ldt.subarray( hLit ); // max length bits
                    lbt = max( lt ); // max dist bits
                    dbt = max( dt );
                    lm = hMap( lt, lbt, 1 );
                    dm = hMap( dt, dbt, 1 );
                } else throw 'invalid block type';
                if ( pos > tbts ) {
                    if ( noSt ) throw 'unexpected EOF';
                    break;
                }
            } // Make sure the buffer can hold this + the largest possible addition
            // Maximum chunk size (practically, theoretically infinite) is 2^17;
            if ( noBuf ) cbuf( bt + 131072 );
            var lms = ( 1 << lbt ) - 1,
                dms = ( 1 << dbt ) - 1;
            var lpos = pos;
            for ( ;; lpos = pos ) { // bits read, code
                var c = lm[ bits16( dat, pos ) & lms ],
                    sym = c >>> 4;
                pos += c & 15;
                if ( pos > tbts ) {
                    if ( noSt ) throw 'unexpected EOF';
                    break;
                }
                if ( !c ) throw 'invalid length/literal';
                if ( sym < 256 ) buf[ bt++ ] = sym;
                else if ( sym == 256 ) {
                    lpos = pos, lm = null;
                    break;
                } else {
                    var add = sym - 254; // no extra bits needed if less
                    if ( sym > 264 ) { // index
                        var i = sym - 257,
                            b = fleb[ i ];
                        add = bits( dat, pos, ( 1 << b ) - 1 ) + fl[ i ];
                        pos += b;
                    } // dist
                    var d = dm[ bits16( dat, pos ) & dms ],
                        dsym = d >>> 4;
                    if ( !d ) throw 'invalid distance';
                    pos += d & 15;
                    var dt = fd[ dsym ];
                    if ( dsym > 3 ) {
                        var b = fdeb[ dsym ];
                        dt += bits16( dat, pos ) & ( 1 << b ) - 1, pos += b;
                    }
                    if ( pos > tbts ) {
                        if ( noSt ) throw 'unexpected EOF';
                        break;
                    }
                    if ( noBuf ) cbuf( bt + 131072 );
                    var end = bt + add;
                    for ( ; bt < end; bt += 4 ) {
                        buf[ bt ] = buf[ bt - dt ];
                        buf[ bt + 1 ] = buf[ bt + 1 - dt ];
                        buf[ bt + 2 ] = buf[ bt + 2 - dt ];
                        buf[ bt + 3 ] = buf[ bt + 3 - dt ];
                    }
                    bt = end;
                }
            }
            st.l = lm, st.p = lpos, st.b = bt;
            if ( lm ) _final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while ( !_final );
        return bt == buf.length ? buf : slc( buf, 0, bt );
    }; // starting at p, write the minimum number of bits that can hold v to d
    var wbits = function wbits( d, p, v ) {
        v <<= p & 7;
        var o = p / 8 | 0;
        d[ o ] |= v;
        d[ o + 1 ] |= v >>> 8;
    }; // starting at p, write the minimum number of bits (>8) that can hold v to d
    var wbits16 = function wbits16( d, p, v ) {
        v <<= p & 7;
        var o = p / 8 | 0;
        d[ o ] |= v;
        d[ o + 1 ] |= v >>> 8;
        d[ o + 2 ] |= v >>> 16;
    }; // creates code lengths from a frequency table
    var hTree = function hTree( d, mb ) { // Need extra info to make a tree
        var t = [ ];
        for ( var i = 0; i < d.length; ++i ) {
            if ( d[ i ] ) t.push( {
                s: i,
                f: d[ i ]
            } );
        }
        var s = t.length;
        var t2 = t.slice( );
        if ( !s ) return [ et, 0 ];
        if ( s == 1 ) {
            var v = new u8( t[ 0 ].s + 1 );
            v[ t[ 0 ].s ] = 1;
            return [ v, 1 ];
        }
        t.sort( function( a, b ) {
            return a.f - b.f;
        } ); // after i2 reaches last ind, will be stopped
        // freq must be greater than largest possible number of symbols
        t.push( {
            s: -1,
            f: 25001
        } );
        var l = t[ 0 ],
            r = t[ 1 ],
            i0 = 0,
            i1 = 1,
            i2 = 2;
        t[ 0 ] = {
            s: -1,
            f: l.f + r.f,
            l: l,
            r: r
        }; // efficient algorithm from UZIP.js
        // i0 is lookbehind, i2 is lookahead - after processing two low-freq
        // symbols that combined have high freq, will start processing i2 (high-freq,
        // non-composite) symbols instead
        // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
        while ( i1 != s - 1 ) {
            l = t[ t[ i0 ].f < t[ i2 ].f ? i0++ : i2++ ];
            r = t[ i0 != i1 && t[ i0 ].f < t[ i2 ].f ? i0++ : i2++ ];
            t[ i1++ ] = {
                s: -1,
                f: l.f + r.f,
                l: l,
                r: r
            };
        }
        var maxSym = t2[ 0 ].s;
        for ( var i = 1; i < s; ++i ) {
            if ( t2[ i ].s > maxSym ) maxSym = t2[ i ].s;
        } // code lengths
        var tr = new u16( maxSym + 1 ); // max bits in tree
        var mbt = ln( t[ i1 - 1 ], tr, 0 );
        if ( mbt > mb ) { // more algorithms from UZIP.js
            // TODO: find out how this code works (debt)
            //  ind    debt
            var i = 0,
                dt = 0; //    left            cost
            var lft = mbt - mb,
                cst = 1 << lft;
            t2.sort( function( a, b ) {
                return tr[ b.s ] - tr[ a.s ] || a.f - b.f;
            } );
            for ( ; i < s; ++i ) {
                var i2_1 = t2[ i ].s;
                if ( tr[ i2_1 ] > mb ) {
                    dt += cst - ( 1 << mbt - tr[ i2_1 ] );
                    tr[ i2_1 ] = mb;
                } else break;
            }
            dt >>>= lft;
            while ( dt > 0 ) {
                var i2_2 = t2[ i ].s;
                if ( tr[ i2_2 ] < mb ) dt -= 1 << mb - tr[ i2_2 ]++ - 1;
                else ++i;
            }
            for ( ; i >= 0 && dt; --i ) {
                var i2_3 = t2[ i ].s;
                if ( tr[ i2_3 ] == mb ) {
                    --tr[ i2_3 ];
                    ++dt;
                }
            }
            mbt = mb;
        }
        return [ new u8( tr ), mbt ];
    }; // get the max length and assign length codes
    var ln = function ln( n, l, d ) {
        return n.s == -1 ? Math.max( ln( n.l, l, d + 1 ), ln( n.r, l, d + 1 ) ) : l[ n.s ] = d;
    }; // length codes generation
    var lc = function lc( c ) {
        var s = c.length; // Note that the semicolon was intentional
        while ( s && !c[ --s ] ) {
            ;
        }
        var cl = new u16( ++s ); //  ind      num         streak
        var cli = 0,
            cln = c[ 0 ],
            cls = 1;
        var w = function w( v ) {
            cl[ cli++ ] = v;
        };
        for ( var i = 1; i <= s; ++i ) {
            if ( c[ i ] == cln && i != s ) ++cls;
            else {
                if ( !cln && cls > 2 ) {
                    for ( ; cls > 138; cls -= 138 ) {
                        w( 32754 );
                    }
                    if ( cls > 2 ) {
                        w( cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305 );
                        cls = 0;
                    }
                } else if ( cls > 3 ) {
                    w( cln ), --cls;
                    for ( ; cls > 6; cls -= 6 ) {
                        w( 8304 );
                    }
                    if ( cls > 2 ) w( cls - 3 << 5 | 8208 ), cls = 0;
                }
                while ( cls-- ) {
                    w( cln );
                }
                cls = 1;
                cln = c[ i ];
            }
        }
        return [ cl.subarray( 0, cli ), s ];
    }; // calculate the length of output from tree, code lengths
    var clen = function clen( cf, cl ) {
        var l = 0;
        for ( var i = 0; i < cl.length; ++i ) {
            l += cf[ i ] * cl[ i ];
        }
        return l;
    }; // writes a fixed block
    // returns the new bit pos
    var wfblk = function wfblk( out, pos, dat ) { // no need to write 00 as type: TypedArray defaults to 0
        var s = dat.length;
        var o = shft( pos + 2 );
        out[ o ] = s & 255;
        out[ o + 1 ] = s >>> 8;
        out[ o + 2 ] = out[ o ] ^ 255;
        out[ o + 3 ] = out[ o + 1 ] ^ 255;
        for ( var i = 0; i < s; ++i ) {
            out[ o + i + 4 ] = dat[ i ];
        }
        return ( o + 4 + s ) * 8;
    }; // writes a block
    var wblk = function wblk( dat, out, _final2, syms, lf, df, eb, li, bs, bl, p ) {
        wbits( out, p++, _final2 );
        ++lf[ 256 ];
        var _a = hTree( lf, 15 ),
            dlt = _a[ 0 ],
            mlb = _a[ 1 ];
        var _b = hTree( df, 15 ),
            ddt = _b[ 0 ],
            mdb = _b[ 1 ];
        var _c = lc( dlt ),
            lclt = _c[ 0 ],
            nlc = _c[ 1 ];
        var _d = lc( ddt ),
            lcdt = _d[ 0 ],
            ndc = _d[ 1 ];
        var lcfreq = new u16( 19 );
        for ( var i = 0; i < lclt.length; ++i ) {
            lcfreq[ lclt[ i ] & 31 ]++;
        }
        for ( var i = 0; i < lcdt.length; ++i ) {
            lcfreq[ lcdt[ i ] & 31 ]++;
        }
        var _e = hTree( lcfreq, 7 ),
            lct = _e[ 0 ],
            mlcb = _e[ 1 ];
        var nlcc = 19;
        for ( ; nlcc > 4 && !lct[ clim[ nlcc - 1 ] ]; --nlcc ) {
            ;
        }
        var flen = bl + 5 << 3;
        var ftlen = clen( lf, flt ) + clen( df, fdt ) + eb;
        var dtlen = clen( lf, dlt ) + clen( df, ddt ) + eb + 14 + 3 * nlcc + clen( lcfreq, lct ) + ( 2 * lcfreq[ 16 ] + 3 * lcfreq[ 17 ] + 7 * lcfreq[ 18 ] );
        if ( flen <= ftlen && flen <= dtlen ) return wfblk( out, p, dat.subarray( bs, bs + bl ) );
        var lm, ll, dm, dl;
        wbits( out, p, 1 + ( dtlen < ftlen ) ), p += 2;
        if ( dtlen < ftlen ) {
            lm = hMap( dlt, mlb, 0 ), ll = dlt, dm = hMap( ddt, mdb, 0 ), dl = ddt;
            var llm = hMap( lct, mlcb, 0 );
            wbits( out, p, nlc - 257 );
            wbits( out, p + 5, ndc - 1 );
            wbits( out, p + 10, nlcc - 4 );
            p += 14;
            for ( var i = 0; i < nlcc; ++i ) {
                wbits( out, p + 3 * i, lct[ clim[ i ] ] );
            }
            p += 3 * nlcc;
            var lcts = [ lclt, lcdt ];
            for ( var it = 0; it < 2; ++it ) {
                var clct = lcts[ it ];
                for ( var i = 0; i < clct.length; ++i ) {
                    var len = clct[ i ] & 31;
                    wbits( out, p, llm[ len ] ), p += lct[ len ];
                    if ( len > 15 ) wbits( out, p, clct[ i ] >>> 5 & 127 ), p += clct[ i ] >>> 12;
                }
            }
        } else {
            lm = flm, ll = flt, dm = fdm, dl = fdt;
        }
        for ( var i = 0; i < li; ++i ) {
            if ( syms[ i ] > 255 ) {
                var len = syms[ i ] >>> 18 & 31;
                wbits16( out, p, lm[ len + 257 ] ), p += ll[ len + 257 ];
                if ( len > 7 ) wbits( out, p, syms[ i ] >>> 23 & 31 ), p += fleb[ len ];
                var dst = syms[ i ] & 31;
                wbits16( out, p, dm[ dst ] ), p += dl[ dst ];
                if ( dst > 3 ) wbits16( out, p, syms[ i ] >>> 5 & 8191 ), p += fdeb[ dst ];
            } else {
                wbits16( out, p, lm[ syms[ i ] ] ), p += ll[ syms[ i ] ];
            }
        }
        wbits16( out, p, lm[ 256 ] );
        return p + ll[ 256 ];
    }; // deflate options (nice << 13) | chain
    var deo = /*#__PURE__*/ new u32( [ 65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632 ] ); // empty
    var et = /*#__PURE__*/ new u8( 0 ); // compresses data into a raw DEFLATE buffer
    var dflt = function dflt( dat, lvl, plvl, pre, post, lst ) {
        var s = dat.length;
        var o = new u8( pre + s + 5 * ( 1 + Math.ceil( s / 7000 ) ) + post ); // writing to this writes to the output buffer
        var w = o.subarray( pre, o.length - post );
        var pos = 0;
        if ( !lvl || s < 8 ) {
            for ( var i = 0; i <= s; i += 65535 ) { // end
                var e = i + 65535;
                if ( e < s ) { // write full block
                    pos = wfblk( w, pos, dat.subarray( i, e ) );
                } else { // write final block
                    w[ i ] = lst;
                    pos = wfblk( w, pos, dat.subarray( i, s ) );
                }
            }
        } else {
            var opt = deo[ lvl - 1 ];
            var n = opt >>> 13,
                c = opt & 8191;
            var msk_1 = ( 1 << plvl ) - 1; //    prev 2-byte val map    curr 2-byte val map
            var prev = new u16( 32768 ),
                head = new u16( msk_1 + 1 );
            var bs1_1 = Math.ceil( plvl / 3 ),
                bs2_1 = 2 * bs1_1;
            var hsh = function hsh( i ) {
                return ( dat[ i ] ^ dat[ i + 1 ] << bs1_1 ^ dat[ i + 2 ] << bs2_1 ) & msk_1;
            }; // 24576 is an arbitrary number of maximum symbols per block
            // 424 buffer for last block
            var syms = new u32( 25000 ); // length/literal freq   distance freq
            var lf = new u16( 288 ),
                df = new u16( 32 ); //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
            var lc_1 = 0,
                eb = 0,
                i = 0,
                li = 0,
                wi = 0,
                bs = 0;
            for ( ; i < s; ++i ) { // hash value
                // deopt when i > s - 3 - at end, deopt acceptable
                var hv = hsh( i ); // index mod 32768    previous index mod
                var imod = i & 32767,
                    pimod = head[ hv ];
                prev[ imod ] = pimod;
                head[ hv ] = imod; // We always should modify head and prev, but only add symbols if
                // this data is not yet processed ("wait" for wait index)
                if ( wi <= i ) { // bytes remaining
                    var rem = s - i;
                    if ( ( lc_1 > 7000 || li > 24576 ) && rem > 423 ) {
                        pos = wblk( dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos );
                        li = lc_1 = eb = 0, bs = i;
                        for ( var j = 0; j < 286; ++j ) {
                            lf[ j ] = 0;
                        }
                        for ( var j = 0; j < 30; ++j ) {
                            df[ j ] = 0;
                        }
                    } //  len    dist   chain
                    var l = 2,
                        d = 0,
                        ch_1 = c,
                        dif = imod - pimod & 32767;
                    if ( rem > 2 && hv == hsh( i - dif ) ) {
                        var maxn = Math.min( n, rem ) - 1;
                        var maxd = Math.min( 32767, i ); // max possible length
                        // not capped at dif because decompressors implement "rolling" index population
                        var ml = Math.min( 258, rem );
                        while ( dif <= maxd && --ch_1 && imod != pimod ) {
                            if ( dat[ i + l ] == dat[ i + l - dif ] ) {
                                var nl = 0;
                                for ( ; nl < ml && dat[ i + nl ] == dat[ i + nl - dif ]; ++nl ) {
                                    ;
                                }
                                if ( nl > l ) {
                                    l = nl, d = dif; // break out early when we reach "nice" (we are satisfied enough)
                                    if ( nl > maxn ) break; // now, find the rarest 2-byte sequence within this
                                    // length of literals and search for that instead.
                                    // Much faster than just using the start
                                    var mmd = Math.min( dif, nl - 2 );
                                    var md = 0;
                                    for ( var j = 0; j < mmd; ++j ) {
                                        var ti = i - dif + j + 32768 & 32767;
                                        var pti = prev[ ti ];
                                        var cd = ti - pti + 32768 & 32767;
                                        if ( cd > md ) md = cd, pimod = ti;
                                    }
                                }
                            } // check the previous match
                            imod = pimod, pimod = prev[ imod ];
                            dif += imod - pimod + 32768 & 32767;
                        }
                    } // d will be nonzero only when a match was found
                    if ( d ) { // store both dist and len data in one Uint32
                        // Make sure this is recognized as a len/dist with 28th bit (2^28)
                        syms[ li++ ] = 268435456 | revfl[ l ] << 18 | revfd[ d ];
                        var lin = revfl[ l ] & 31,
                            din = revfd[ d ] & 31;
                        eb += fleb[ lin ] + fdeb[ din ];
                        ++lf[ 257 + lin ];
                        ++df[ din ];
                        wi = i + l;
                        ++lc_1;
                    } else {
                        syms[ li++ ] = dat[ i ];
                        ++lf[ dat[ i ] ];
                    }
                }
            }
            pos = wblk( dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos ); // this is the easiest way to avoid needing to maintain state
            if ( !lst && pos & 7 ) pos = wfblk( w, pos + 1, et );
        }
        return slc( o, 0, pre + shft( pos ) + post );
    }; // CRC32 table
    var crct = /*#__PURE__*/ function( ) {
        var t = new u32( 256 );
        for ( var i = 0; i < 256; ++i ) {
            var c = i,
                k = 9;
            while ( --k ) {
                c = ( c & 1 && 0xEDB88320 ) ^ c >>> 1;
            }
            t[ i ] = c;
        }
        return t;
    }( ); // CRC32
    var crc = function crc( ) {
        var c = -1;
        return {
            p: function p( d ) { // closures have awful performance
                var cr = c;
                for ( var i = 0; i < d.length; ++i ) {
                    cr = crct[ cr & 255 ^ d[ i ] ] ^ cr >>> 8;
                }
                c = cr;
            },
            d: function d( ) {
                return ~c;
            }
        };
    }; // Alder32
    var adler = function adler( ) {
        var a = 1,
            b = 0;
        return {
            p: function p( d ) { // closures have awful performance
                var n = a,
                    m = b;
                var l = d.length;
                for ( var i = 0; i != l; ) {
                    var e = Math.min( i + 2655, l );
                    for ( ; i < e; ++i ) {
                        m += n += d[ i ];
                    }
                    n = ( n & 65535 ) + 15 * ( n >> 16 ), m = ( m & 65535 ) + 15 * ( m >> 16 );
                }
                a = n, b = m;
            },
            d: function d( ) {
                a %= 65521, b %= 65521;
                return ( a & 255 ) << 24 | a >>> 8 << 16 | ( b & 255 ) << 8 | b >>> 8;
            }
        };
    }; // deflate with opts
    var dopt = function dopt( dat, opt, pre, post, st ) {
        return dflt( dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil( Math.max( 8, Math.min( 13, Math.log( dat.length ) ) ) * 1.5 ) : 12 + opt.mem, pre, post, !st );
    }; // Walmart object spread
    var mrg = function mrg( a, b ) {
        var o = {};
        for ( var k in a ) {
            o[ k ] = a[ k ];
        }
        for ( var k in b ) {
            o[ k ] = b[ k ];
        }
        return o;
    }; // worker clone
    // This is possibly the craziest part of the entire codebase, despite how simple it may seem.
    // The only parameter to this function is a closure that returns an array of variables outside of the function scope.
    // We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
    // We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
    // The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
    // This took me three weeks to figure out how to do.
    var wcln = function wcln( fn, fnStr, td ) {
        var dt = fn( );
        var st = fn.toString( );
        var ks = st.slice( st.indexOf( '[' ) + 1, st.lastIndexOf( ']' ) ).replace( / /g, '' ).split( ',' );
        for ( var i = 0; i < dt.length; ++i ) {
            var v = dt[ i ],
                k = ks[ i ];
            if ( typeof v == 'function' ) {
                fnStr += ';' + k + '=';
                var st_1 = v.toString( );
                if ( v.prototype ) { // for global objects
                    if ( st_1.indexOf( '[native code]' ) != -1 ) {
                        var spInd = st_1.indexOf( ' ', 8 ) + 1;
                        fnStr += st_1.slice( spInd, st_1.indexOf( '(', spInd ) );
                    } else {
                        fnStr += st_1;
                        for ( var t in v.prototype ) {
                            fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[ t ].toString( );
                        }
                    }
                } else fnStr += st_1;
            } else td[ k ] = v;
        }
        return [ fnStr, td ];
    };
    var ch = [ ]; // clone bufs
    var cbfs = function cbfs( v ) {
        var tl = [ ];
        for ( var k in v ) {
            if ( v[ k ] instanceof u8 || v[ k ] instanceof u16 || v[ k ] instanceof u32 ) tl.push( ( v[ k ] = new v[ k ].constructor( v[ k ] ) ).buffer );
        }
        return tl;
    }; // use a worker to execute code
    var wrkr = function wrkr( fns, init, id, cb ) {
        var _a;
        if ( !ch[ id ] ) {
            var fnStr = '',
                td_1 = {},
                m = fns.length - 1;
            for ( var i = 0; i < m; ++i ) {
                _a = wcln( fns[ i ], fnStr, td_1 ), fnStr = _a[ 0 ], td_1 = _a[ 1 ];
            }
            ch[ id ] = wcln( fns[ m ], fnStr, td_1 );
        }
        var td = mrg( {}, ch[ id ][ 1 ] );
        return wk( ch[ id ][ 0 ] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString( ) + '}', id, td, cbfs( td ), cb );
    }; // base async inflate fn
    var bInflt = function bInflt( ) {
        return [ u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8 ];
    };
    var bDflt = function bDflt( ) {
        return [ u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf ];
    }; // gzip extra
    var gze = function gze( ) {
        return [ gzh, gzhl, wbytes, crc, crct ];
    }; // gunzip extra
    var guze = function guze( ) {
        return [ gzs, gzl ];
    }; // zlib extra
    var zle = function zle( ) {
        return [ zlh, wbytes, adler ];
    }; // unzlib extra
    var zule = function zule( ) {
        return [ zlv ];
    }; // post buf
    var pbf = function pbf( msg ) {
        return postMessage( msg, [ msg.buffer ] );
    }; // get u8
    var gu8 = function gu8( o ) {
        return o && o.size && new u8( o.size );
    }; // async helper
    var cbify = function cbify( dat, opts, fns, init, id, cb ) {
        var w = wrkr( fns, init, id, function( err, dat ) {
            w.terminate( );
            cb( err, dat );
        } );
        w.postMessage( [ dat, opts ], opts.consume ? [ dat.buffer ] : [ ] );
        return function( ) {
            w.terminate( );
        };
    }; // auto stream
    var astrm = function astrm( strm ) {
        strm.ondata = function( dat, _final3 ) {
            return postMessage( [ dat, _final3 ], [ dat.buffer ] );
        };
        return function( ev ) {
            return strm.push( ev.data[ 0 ], ev.data[ 1 ] );
        };
    }; // async stream attach
    var astrmify = function astrmify( fns, strm, opts, init, id ) {
        var t;
        var w = wrkr( fns, init, id, function( err, dat ) {
            if ( err ) w.terminate( ), strm.ondata.call( strm, err );
            else {
                if ( dat[ 1 ] ) w.terminate( );
                strm.ondata.call( strm, err, dat[ 0 ], dat[ 1 ] );
            }
        } );
        w.postMessage( opts );
        strm.push = function( d, f ) {
            if ( t ) throw 'stream finished';
            if ( !strm.ondata ) throw 'no stream handler';
            w.postMessage( [ d, t = f ], [ d.buffer ] );
        };
        strm.terminate = function( ) {
            w.terminate( );
        };
    }; // read 2 bytes
    var b2 = function b2( d, b ) {
        return d[ b ] | d[ b + 1 ] << 8;
    }; // read 4 bytes
    var b4 = function b4( d, b ) {
        return ( d[ b ] | d[ b + 1 ] << 8 | d[ b + 2 ] << 16 | d[ b + 3 ] << 24 ) >>> 0;
    };
    var b8 = function b8( d, b ) {
        return b4( d, b ) + b4( d, b + 4 ) * 4294967296;
    }; // write bytes
    var wbytes = function wbytes( d, b, v ) {
        for ( ; v; ++b ) {
            d[ b ] = v, v >>>= 8;
        }
    }; // gzip header
    var gzh = function gzh( c, o ) {
        var fn = o.filename;
        c[ 0 ] = 31, c[ 1 ] = 139, c[ 2 ] = 8, c[ 8 ] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[ 9 ] = 3; // assume Unix
        if ( o.mtime != 0 ) wbytes( c, 4, Math.floor( new Date( o.mtime || Date.now( ) ) / 1000 ) );
        if ( fn ) {
            c[ 3 ] = 8;
            for ( var i = 0; i <= fn.length; ++i ) {
                c[ i + 10 ] = fn.charCodeAt( i );
            }
        }
    }; // gzip footer: -8 to -4 = CRC, -4 to -0 is length
    // gzip start
    var gzs = function gzs( d ) {
        if ( d[ 0 ] != 31 || d[ 1 ] != 139 || d[ 2 ] != 8 ) throw 'invalid gzip data';
        var flg = d[ 3 ];
        var st = 10;
        if ( flg & 4 ) st += d[ 10 ] | ( d[ 11 ] << 8 ) + 2;
        for ( var zs = ( flg >> 3 & 1 ) + ( flg >> 4 & 1 ); zs > 0; zs -= !d[ st++ ] ) {
            ;
        }
        return st + ( flg & 2 );
    }; // gzip length
    var gzl = function gzl( d ) {
        var l = d.length;
        return ( d[ l - 4 ] | d[ l - 3 ] << 8 | d[ l - 2 ] << 16 | d[ l - 1 ] << 24 ) >>> 0;
    }; // gzip header length
    var gzhl = function gzhl( o ) {
        return 10 + ( o.filename && o.filename.length + 1 || 0 );
    }; // zlib header
    var zlh = function zlh( c, o ) {
        var lv = o.level,
            fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
        c[ 0 ] = 120, c[ 1 ] = fl << 6 | ( fl ? 32 - 2 * fl : 1 );
    }; // zlib valid
    var zlv = function zlv( d ) {
        if ( ( d[ 0 ] & 15 ) != 8 || d[ 0 ] >>> 4 > 7 || ( d[ 0 ] << 8 | d[ 1 ] ) % 31 ) throw 'invalid zlib data';
        if ( d[ 1 ] & 32 ) throw 'invalid zlib data: preset dictionaries not supported';
    };

    function AsyncCmpStrm( opts, cb ) {
        if ( !cb && typeof opts == 'function' ) cb = opts, opts = {};
        this.ondata = cb;
        return opts;
    } // zlib footer: -4 to -0 is Adler32
    /**
     * Streaming DEFLATE compression
     */
    var Deflate = /*#__PURE__*/ function( ) {
        function Deflate( opts, cb ) {
            if ( !cb && typeof opts == 'function' ) cb = opts, opts = {};
            this.ondata = cb;
            this.o = opts || {};
        }
        Deflate.prototype.p = function( c, f ) {
            this.ondata( dopt( c, this.o, 0, 0, !f ), f );
        };
        /**
         * Pushes a chunk to be deflated
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Deflate.prototype.push = function( chunk, _final4 ) {
            if ( this.d ) throw 'stream finished';
            if ( !this.ondata ) throw 'no stream handler';
            this.d = _final4;
            this.p( chunk, _final4 || false );
        };
        return Deflate;
    }( );
    /**
     * Asynchronous streaming DEFLATE compression
     */
    var AsyncDeflate = /*#__PURE__*/ function( ) {
        function AsyncDeflate( opts, cb ) {
            astrmify( [ bDflt, function( ) {
                return [ astrm, Deflate ];
            } ], this, AsyncCmpStrm.call( this, opts, cb ), function( ev ) {
                var strm = new Deflate( ev.data );
                onmessage = astrm( strm );
            }, 6 );
        }
        return AsyncDeflate;
    }( );

    function deflate( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bDflt ], function( ev ) {
            return pbf( deflateSync( ev.data[ 0 ], ev.data[ 1 ] ) );
        }, 0, cb );
    }
    /**
     * Compresses data with DEFLATE without any wrapper
     * @param data The data to compress
     * @param opts The compression options
     * @returns The deflated version of the data
     */
    function deflateSync( data, opts ) {
        return dopt( data, opts || {}, 0, 0 );
    }
    /**
     * Streaming DEFLATE decompression
     */
    var Inflate = /*#__PURE__*/ function( ) {
        /**
         * Creates an inflation stream
         * @param cb The callback to call whenever data is inflated
         */
        function Inflate( cb ) {
            this.s = {};
            this.p = new u8( 0 );
            this.ondata = cb;
        }
        Inflate.prototype.e = function( c ) {
            if ( this.d ) throw 'stream finished';
            if ( !this.ondata ) throw 'no stream handler';
            var l = this.p.length;
            var n = new u8( l + c.length );
            n.set( this.p ), n.set( c, l ), this.p = n;
        };
        Inflate.prototype.c = function( _final5 ) {
            this.d = this.s.i = _final5 || false;
            var bts = this.s.b;
            var dt = inflt( this.p, this.o, this.s );
            this.ondata( slc( dt, bts, this.s.b ), this.d );
            this.o = slc( dt, this.s.b - 32768 ), this.s.b = this.o.length;
            this.p = slc( this.p, this.s.p / 8 | 0 ), this.s.p &= 7;
        };
        /**
         * Pushes a chunk to be inflated
         * @param chunk The chunk to push
         * @param final Whether this is the final chunk
         */
        Inflate.prototype.push = function( chunk, _final6 ) {
            this.e( chunk ), this.c( _final6 );
        };
        return Inflate;
    }( );
    /**
     * Asynchronous streaming DEFLATE decompression
     */
    var AsyncInflate = /*#__PURE__*/ function( ) {
        /**
         * Creates an asynchronous inflation stream
         * @param cb The callback to call whenever data is deflated
         */
        function AsyncInflate( cb ) {
            this.ondata = cb;
            astrmify( [ bInflt, function( ) {
                return [ astrm, Inflate ];
            } ], this, 0, function( ) {
                var strm = new Inflate( );
                onmessage = astrm( strm );
            }, 7 );
        }
        return AsyncInflate;
    }( );

    function inflate( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bInflt ], function( ev ) {
            return pbf( inflateSync( ev.data[ 0 ], gu8( ev.data[ 1 ] ) ) );
        }, 1, cb );
    }
    /**
     * Expands DEFLATE data with no wrapper
     * @param data The data to decompress
     * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
     * @returns The decompressed version of the data
     */
    function inflateSync( data, out ) {
        return inflt( data, out );
    } // before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
    /**
     * Streaming GZIP compression
     */
    var Gzip = /*#__PURE__*/ function( ) {
        function Gzip( opts, cb ) {
            this.c = crc( );
            this.l = 0;
            this.v = 1;
            Deflate.call( this, opts, cb );
        }
        /**
         * Pushes a chunk to be GZIPped
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Gzip.prototype.push = function( chunk, _final7 ) {
            Deflate.prototype.push.call( this, chunk, _final7 );
        };
        Gzip.prototype.p = function( c, f ) {
            this.c.p( c );
            this.l += c.length;
            var raw = dopt( c, this.o, this.v && gzhl( this.o ), f && 8, !f );
            if ( this.v ) gzh( raw, this.o ), this.v = 0;
            if ( f ) wbytes( raw, raw.length - 8, this.c.d( ) ), wbytes( raw, raw.length - 4, this.l );
            this.ondata( raw, f );
        };
        return Gzip;
    }( );
    /**
     * Asynchronous streaming GZIP compression
     */
    var AsyncGzip = /*#__PURE__*/ function( ) {
        function AsyncGzip( opts, cb ) {
            astrmify( [ bDflt, gze, function( ) {
                return [ astrm, Deflate, Gzip ];
            } ], this, AsyncCmpStrm.call( this, opts, cb ), function( ev ) {
                var strm = new Gzip( ev.data );
                onmessage = astrm( strm );
            }, 8 );
        }
        return AsyncGzip;
    }( );

    function gzip( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bDflt, gze, function( ) {
            return [ gzipSync ];
        } ], function( ev ) {
            return pbf( gzipSync( ev.data[ 0 ], ev.data[ 1 ] ) );
        }, 2, cb );
    }
    /**
     * Compresses data with GZIP
     * @param data The data to compress
     * @param opts The compression options
     * @returns The gzipped version of the data
     */
    function gzipSync( data, opts ) {
        if ( !opts ) opts = {};
        var c = crc( ),
            l = data.length;
        c.p( data );
        var d = dopt( data, opts, gzhl( opts ), 8 ),
            s = d.length;
        return gzh( d, opts ), wbytes( d, s - 8, c.d( ) ), wbytes( d, s - 4, l ), d;
    }
    /**
     * Streaming GZIP decompression
     */
    var Gunzip = /*#__PURE__*/ function( ) {
        /**
         * Creates a GUNZIP stream
         * @param cb The callback to call whenever data is inflated
         */
        function Gunzip( cb ) {
            this.v = 1;
            Inflate.call( this, cb );
        }
        /**
         * Pushes a chunk to be GUNZIPped
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Gunzip.prototype.push = function( chunk, _final8 ) {
            Inflate.prototype.e.call( this, chunk );
            if ( this.v ) {
                var s = this.p.length > 3 ? gzs( this.p ) : 4;
                if ( s >= this.p.length && !_final8 ) return;
                this.p = this.p.subarray( s ), this.v = 0;
            }
            if ( _final8 ) {
                if ( this.p.length < 8 ) throw 'invalid gzip stream';
                this.p = this.p.subarray( 0, -8 );
            } // necessary to prevent TS from using the closure value
            // This allows for workerization to function correctly
            Inflate.prototype.c.call( this, _final8 );
        };
        return Gunzip;
    }( );
    /**
     * Asynchronous streaming GZIP decompression
     */
    var AsyncGunzip = /*#__PURE__*/ function( ) {
        /**
         * Creates an asynchronous GUNZIP stream
         * @param cb The callback to call whenever data is deflated
         */
        function AsyncGunzip( cb ) {
            this.ondata = cb;
            astrmify( [ bInflt, guze, function( ) {
                return [ astrm, Inflate, Gunzip ];
            } ], this, 0, function( ) {
                var strm = new Gunzip( );
                onmessage = astrm( strm );
            }, 9 );
        }
        return AsyncGunzip;
    }( );

    function gunzip( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bInflt, guze, function( ) {
            return [ gunzipSync ];
        } ], function( ev ) {
            return pbf( gunzipSync( ev.data[ 0 ] ) );
        }, 3, cb );
    }
    /**
     * Expands GZIP data
     * @param data The data to decompress
     * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
     * @returns The decompressed version of the data
     */
    function gunzipSync( data, out ) {
        return inflt( data.subarray( gzs( data ), -8 ), out || new u8( gzl( data ) ) );
    }
    /**
     * Streaming Zlib compression
     */
    var Zlib = /*#__PURE__*/ function( ) {
        function Zlib( opts, cb ) {
            this.c = adler( );
            this.v = 1;
            Deflate.call( this, opts, cb );
        }
        /**
         * Pushes a chunk to be zlibbed
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Zlib.prototype.push = function( chunk, _final9 ) {
            Deflate.prototype.push.call( this, chunk, _final9 );
        };
        Zlib.prototype.p = function( c, f ) {
            this.c.p( c );
            var raw = dopt( c, this.o, this.v && 2, f && 4, !f );
            if ( this.v ) zlh( raw, this.o ), this.v = 0;
            if ( f ) wbytes( raw, raw.length - 4, this.c.d( ) );
            this.ondata( raw, f );
        };
        return Zlib;
    }( );
    /**
     * Asynchronous streaming Zlib compression
     */
    var AsyncZlib = /*#__PURE__*/ function( ) {
        function AsyncZlib( opts, cb ) {
            astrmify( [ bDflt, zle, function( ) {
                return [ astrm, Deflate, Zlib ];
            } ], this, AsyncCmpStrm.call( this, opts, cb ), function( ev ) {
                var strm = new Zlib( ev.data );
                onmessage = astrm( strm );
            }, 10 );
        }
        return AsyncZlib;
    }( );

    function zlib( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bDflt, zle, function( ) {
            return [ zlibSync ];
        } ], function( ev ) {
            return pbf( zlibSync( ev.data[ 0 ], ev.data[ 1 ] ) );
        }, 4, cb );
    }
    /**
     * Compress data with Zlib
     * @param data The data to compress
     * @param opts The compression options
     * @returns The zlib-compressed version of the data
     */
    function zlibSync( data, opts ) {
        if ( !opts ) opts = {};
        var a = adler( );
        a.p( data );
        var d = dopt( data, opts, 2, 4 );
        return zlh( d, opts ), wbytes( d, d.length - 4, a.d( ) ), d;
    }
    /**
     * Streaming Zlib decompression
     */
    var Unzlib = /*#__PURE__*/ function( ) {
        /**
         * Creates a Zlib decompression stream
         * @param cb The callback to call whenever data is inflated
         */
        function Unzlib( cb ) {
            this.v = 1;
            Inflate.call( this, cb );
        }
        /**
         * Pushes a chunk to be unzlibbed
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Unzlib.prototype.push = function( chunk, _final10 ) {
            Inflate.prototype.e.call( this, chunk );
            if ( this.v ) {
                if ( this.p.length < 2 && !_final10 ) return;
                this.p = this.p.subarray( 2 ), this.v = 0;
            }
            if ( _final10 ) {
                if ( this.p.length < 4 ) throw 'invalid zlib stream';
                this.p = this.p.subarray( 0, -4 );
            } // necessary to prevent TS from using the closure value
            // This allows for workerization to function correctly
            Inflate.prototype.c.call( this, _final10 );
        };
        return Unzlib;
    }( );
    /**
     * Asynchronous streaming Zlib decompression
     */
    var AsyncUnzlib = /*#__PURE__*/ function( ) {
        /**
         * Creates an asynchronous Zlib decompression stream
         * @param cb The callback to call whenever data is deflated
         */
        function AsyncUnzlib( cb ) {
            this.ondata = cb;
            astrmify( [ bInflt, zule, function( ) {
                return [ astrm, Inflate, Unzlib ];
            } ], this, 0, function( ) {
                var strm = new Unzlib( );
                onmessage = astrm( strm );
            }, 11 );
        }
        return AsyncUnzlib;
    }( );

    function unzlib( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return cbify( data, opts, [ bInflt, zule, function( ) {
            return [ unzlibSync ];
        } ], function( ev ) {
            return pbf( unzlibSync( ev.data[ 0 ], gu8( ev.data[ 1 ] ) ) );
        }, 5, cb );
    }
    /**
     * Expands Zlib data
     * @param data The data to decompress
     * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
     * @returns The decompressed version of the data
     */
    function unzlibSync( data, out ) {
        return inflt( ( zlv( data ), data.subarray( 2, -4 ) ), out );
    }
    /**
     * Streaming GZIP, Zlib, or raw DEFLATE decompression
     */
    var Decompress = /*#__PURE__*/ function( ) {
        /**
         * Creates a decompression stream
         * @param cb The callback to call whenever data is decompressed
         */
        function Decompress( cb ) {
            this.G = Gunzip;
            this.I = Inflate;
            this.Z = Unzlib;
            this.ondata = cb;
        }
        /**
         * Pushes a chunk to be decompressed
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Decompress.prototype.push = function( chunk, _final11 ) {
            if ( !this.ondata ) throw 'no stream handler';
            if ( !this.s ) {
                if ( this.p && this.p.length ) {
                    var n = new u8( this.p.length + chunk.length );
                    n.set( this.p ), n.set( chunk, this.p.length );
                } else this.p = chunk;
                if ( this.p.length > 2 ) {
                    var _this_1 = this;
                    var cb = function cb( ) {
                        _this_1.ondata.apply( _this_1, arguments );
                    };
                    this.s = this.p[ 0 ] == 31 && this.p[ 1 ] == 139 && this.p[ 2 ] == 8 ? new this.G( cb ) : ( this.p[ 0 ] & 15 ) != 8 || this.p[ 0 ] >> 4 > 7 || ( this.p[ 0 ] << 8 | this.p[ 1 ] ) % 31 ? new this.I( cb ) : new this.Z( cb );
                    this.s.push( this.p, _final11 );
                    this.p = null;
                }
            } else this.s.push( chunk, _final11 );
        };
        return Decompress;
    }( );
    /**
     * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
     */
    var AsyncDecompress = /*#__PURE__*/ function( ) {
        /**
         * Creates an asynchronous decompression stream
         * @param cb The callback to call whenever data is decompressed
         */
        function AsyncDecompress( cb ) {
            this.G = AsyncGunzip;
            this.I = AsyncInflate;
            this.Z = AsyncUnzlib;
            this.ondata = cb;
        }
        /**
         * Pushes a chunk to be decompressed
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        AsyncDecompress.prototype.push = function( chunk, _final12 ) {
            Decompress.prototype.push.call( this, chunk, _final12 );
        };
        return AsyncDecompress;
    }( );

    function decompress( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        return data[ 0 ] == 31 && data[ 1 ] == 139 && data[ 2 ] == 8 ? gunzip( data, opts, cb ) : ( data[ 0 ] & 15 ) != 8 || data[ 0 ] >> 4 > 7 || ( data[ 0 ] << 8 | data[ 1 ] ) % 31 ? inflate( data, opts, cb ) : unzlib( data, opts, cb );
    }
    /**
     * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
     * @param data The data to decompress
     * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
     * @returns The decompressed version of the data
     */
    function decompressSync( data, out ) {
        return data[ 0 ] == 31 && data[ 1 ] == 139 && data[ 2 ] == 8 ? gunzipSync( data, out ) : ( data[ 0 ] & 15 ) != 8 || data[ 0 ] >> 4 > 7 || ( data[ 0 ] << 8 | data[ 1 ] ) % 31 ? inflateSync( data, out ) : unzlibSync( data, out );
    } // flatten a directory structure
    var fltn = function fltn( d, p, t, o ) {
        for ( var k in d ) {
            var val = d[ k ],
                n = p + k;
            if ( val instanceof u8 ) t[ n ] = [ val, o ];
            else if ( Array.isArray( val ) ) t[ n ] = [ val[ 0 ], mrg( o, val[ 1 ] ) ];
            else fltn( val, n + '/', t, o );
        }
    }; // text encoder
    var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder( ); // text decoder
    var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder( ); // text decoder stream
    var tds = 0;
    try {
        td.decode( et, {
            stream: true
        } );
        tds = 1;
    } catch ( e ) {} // decode UTF8
    var dutf8 = function dutf8( d ) {
        for ( var r = '', i = 0;; ) {
            var c = d[ i++ ];
            var eb = ( c > 127 ) + ( c > 223 ) + ( c > 239 );
            if ( i + eb > d.length ) return [ r, slc( d, i - 1 ) ];
            if ( !eb ) r += String.fromCharCode( c );
            else if ( eb == 3 ) {
                c = ( ( c & 15 ) << 18 | ( d[ i++ ] & 63 ) << 12 | ( d[ i++ ] & 63 ) << 6 | d[ i++ ] & 63 ) - 65536, r += String.fromCharCode( 55296 | c >> 10, 56320 | c & 1023 );
            } else if ( eb & 1 ) r += String.fromCharCode( ( c & 31 ) << 6 | d[ i++ ] & 63 );
            else r += String.fromCharCode( ( c & 15 ) << 12 | ( d[ i++ ] & 63 ) << 6 | d[ i++ ] & 63 );
        }
    };
    /**
     * Streaming UTF-8 decoding
     */
    var DecodeUTF8 = /*#__PURE__*/ function( ) {
        /**
         * Creates a UTF-8 decoding stream
         * @param cb The callback to call whenever data is decoded
         */
        function DecodeUTF8( cb ) {
            this.ondata = cb;
            if ( tds ) this.t = new TextDecoder( );
            else this.p = et;
        }
        /**
         * Pushes a chunk to be decoded from UTF-8 binary
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        DecodeUTF8.prototype.push = function( chunk, _final13 ) {
            if ( !this.ondata ) throw 'no callback';
            _final13 = !!_final13;
            if ( this.t ) {
                this.ondata( this.t.decode( chunk, {
                    stream: true
                } ), _final13 );
                if ( _final13 ) {
                    if ( this.t.decode( ).length ) throw 'invalid utf-8 data';
                    this.t = null;
                }
                return;
            }
            if ( !this.p ) throw 'stream finished';
            var dat = new u8( this.p.length + chunk.length );
            dat.set( this.p );
            dat.set( chunk, this.p.length );
            var _a = dutf8( dat ),
                ch = _a[ 0 ],
                np = _a[ 1 ];
            if ( _final13 ) {
                if ( np.length ) throw 'invalid utf-8 data';
                this.p = null;
            } else this.p = np;
            this.ondata( ch, _final13 );
        };
        return DecodeUTF8;
    }( );
    /**
     * Streaming UTF-8 encoding
     */
    var EncodeUTF8 = /*#__PURE__*/ function( ) {
        /**
         * Creates a UTF-8 decoding stream
         * @param cb The callback to call whenever data is encoded
         */
        function EncodeUTF8( cb ) {
            this.ondata = cb;
        }
        /**
         * Pushes a chunk to be encoded to UTF-8
         * @param chunk The string data to push
         * @param final Whether this is the last chunk
         */
        EncodeUTF8.prototype.push = function( chunk, _final14 ) {
            if ( !this.ondata ) throw 'no callback';
            if ( this.d ) throw 'stream finished';
            this.ondata( strToU8( chunk ), this.d = _final14 || false );
        };
        return EncodeUTF8;
    }( );
    /**
     * Converts a string into a Uint8Array for use with compression/decompression methods
     * @param str The string to encode
     * @param latin1 Whether or not to interpret the data as Latin-1. This should
     *               not need to be true unless decoding a binary string.
     * @returns The string encoded in UTF-8/Latin-1 binary
     */
    function strToU8( str, latin1 ) {
        if ( latin1 ) {
            var ar_1 = new u8( str.length );
            for ( var i = 0; i < str.length; ++i ) {
                ar_1[ i ] = str.charCodeAt( i );
            }
            return ar_1;
        }
        if ( te ) return te.encode( str );
        var l = str.length;
        var ar = new u8( str.length + ( str.length >> 1 ) );
        var ai = 0;
        var w = function w( v ) {
            ar[ ai++ ] = v;
        };
        for ( var i = 0; i < l; ++i ) {
            if ( ai + 5 > ar.length ) {
                var n = new u8( ai + 8 + ( l - i << 1 ) );
                n.set( ar );
                ar = n;
            }
            var c = str.charCodeAt( i );
            if ( c < 128 || latin1 ) w( c );
            else if ( c < 2048 ) w( 192 | c >> 6 ), w( 128 | c & 63 );
            else if ( c > 55295 && c < 57344 ) c = 65536 + ( c & 1023 << 10 ) | str.charCodeAt( ++i ) & 1023, w( 240 | c >> 18 ), w( 128 | c >> 12 & 63 ), w( 128 | c >> 6 & 63 ), w( 128 | c & 63 );
            else w( 224 | c >> 12 ), w( 128 | c >> 6 & 63 ), w( 128 | c & 63 );
        }
        return slc( ar, 0, ai );
    }
    /**
     * Converts a Uint8Array to a string
     * @param dat The data to decode to string
     * @param latin1 Whether or not to interpret the data as Latin-1. This should
     *               not need to be true unless encoding to binary string.
     * @returns The original UTF-8/Latin-1 string
     */
    function strFromU8( dat, latin1 ) {
        if ( latin1 ) {
            var r = '';
            for ( var i = 0; i < dat.length; i += 16384 ) {
                r += String.fromCharCode.apply( null, dat.subarray( i, i + 16384 ) );
            }
            return r;
        } else if ( td ) return td.decode( dat );
        else {
            var _a = dutf8( dat ),
                out = _a[ 0 ],
                ext = _a[ 1 ];
            if ( ext.length ) throw 'invalid utf-8 data';
            return out;
        }
    } // deflate bit flag
    var dbf = function dbf( l ) {
        return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    }; // skip local zip header
    var slzh = function slzh( d, b ) {
        return b + 30 + b2( d, b + 26 ) + b2( d, b + 28 );
    }; // read zip header
    var zh = function zh( d, b, z ) {
        var fnl = b2( d, b + 28 ),
            fn = strFromU8( d.subarray( b + 46, b + 46 + fnl ), !( b2( d, b + 8 ) & 2048 ) ),
            es = b + 46 + fnl,
            bs = b4( d, b + 20 );
        var _a = z && bs == 4294967295 ? z64e( d, es ) : [ bs, b4( d, b + 24 ), b4( d, b + 42 ) ],
            sc = _a[ 0 ],
            su = _a[ 1 ],
            off = _a[ 2 ];
        return [ b2( d, b + 10 ), sc, su, fn, es + b2( d, b + 30 ) + b2( d, b + 32 ), off ];
    }; // read zip64 extra field
    var z64e = function z64e( d, b ) {
        for ( ; b2( d, b ) != 1; b += 4 + b2( d, b + 2 ) ) {
            ;
        }
        return [ b8( d, b + 12 ), b8( d, b + 4 ), b8( d, b + 20 ) ];
    }; // extra field length
    var exfl = function exfl( ex ) {
        var le = 0;
        if ( ex ) {
            for ( var k in ex ) {
                var l = ex[ k ].length;
                if ( l > 65535 ) throw 'extra field too long';
                le += l + 4;
            }
        }
        return le;
    }; // write zip header
    var wzh = function wzh( d, b, f, fn, u, c, ce, co ) {
        var fl = fn.length,
            ex = f.extra,
            col = co && co.length;
        var exl = exfl( ex );
        wbytes( d, b, ce != null ? 0x2014B50 : 0x4034B50 ), b += 4;
        if ( ce != null ) d[ b++ ] = 20, d[ b++ ] = f.os;
        d[ b ] = 20, b += 2; // spec compliance? what's that?
        d[ b++ ] = f.flag << 1 | ( c == null && 8 ), d[ b++ ] = u && 8;
        d[ b++ ] = f.compression & 255, d[ b++ ] = f.compression >> 8;
        var dt = new Date( f.mtime == null ? Date.now( ) : f.mtime ),
            y = dt.getFullYear( ) - 1980;
        if ( y < 0 || y > 119 ) throw 'date not in range 1980-2099';
        wbytes( d, b, y << 25 | dt.getMonth( ) + 1 << 21 | dt.getDate( ) << 16 | dt.getHours( ) << 11 | dt.getMinutes( ) << 5 | dt.getSeconds( ) >>> 1 ), b += 4;
        if ( c != null ) {
            wbytes( d, b, f.crc );
            wbytes( d, b + 4, c );
            wbytes( d, b + 8, f.size );
        }
        wbytes( d, b + 12, fl );
        wbytes( d, b + 14, exl ), b += 16;
        if ( ce != null ) {
            wbytes( d, b, col );
            wbytes( d, b + 6, f.attrs );
            wbytes( d, b + 10, ce ), b += 14;
        }
        d.set( fn, b );
        b += fl;
        if ( exl ) {
            for ( var k in ex ) {
                var exf = ex[ k ],
                    l = exf.length;
                wbytes( d, b, +k );
                wbytes( d, b + 2, l );
                d.set( exf, b + 4 ), b += 4 + l;
            }
        }
        if ( col ) d.set( co, b ), b += col;
        return b;
    }; // write zip footer (end of central directory)
    var wzf = function wzf( o, b, c, d, e ) {
        wbytes( o, b, 0x6054B50 ); // skip disk
        wbytes( o, b + 8, c );
        wbytes( o, b + 10, c );
        wbytes( o, b + 12, d );
        wbytes( o, b + 16, e );
    };
    /**
     * A pass-through stream to keep data uncompressed in a ZIP archive.
     */
    var ZipPassThrough = /*#__PURE__*/ function( ) {
        /**
         * Creates a pass-through stream that can be added to ZIP archives
         * @param filename The filename to associate with this data stream
         */
        function ZipPassThrough( filename ) {
            this.filename = filename;
            this.c = crc( );
            this.size = 0;
            this.compression = 0;
        }
        /**
         * Processes a chunk and pushes to the output stream. You can override this
         * method in a subclass for custom behavior, but by default this passes
         * the data through. You must call this.ondata(err, chunk, final) at some
         * point in this method.
         * @param chunk The chunk to process
         * @param final Whether this is the last chunk
         */
        ZipPassThrough.prototype.process = function( chunk, _final15 ) {
            this.ondata( null, chunk, _final15 );
        };
        /**
         * Pushes a chunk to be added. If you are subclassing this with a custom
         * compression algorithm, note that you must push data from the source
         * file only, pre-compression.
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        ZipPassThrough.prototype.push = function( chunk, _final16 ) {
            if ( !this.ondata ) throw 'no callback - add to ZIP archive before pushing';
            this.c.p( chunk );
            this.size += chunk.length;
            if ( _final16 ) this.crc = this.c.d( );
            this.process( chunk, _final16 || false );
        };
        return ZipPassThrough;
    }( ); // I don't extend because TypeScript extension adds 1kB of runtime bloat
    /**
     * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
     * for better performance
     */
    var ZipDeflate = /*#__PURE__*/ function( ) {
        /**
         * Creates a DEFLATE stream that can be added to ZIP archives
         * @param filename The filename to associate with this data stream
         * @param opts The compression options
         */
        function ZipDeflate( filename, opts ) {
            var _this_1 = this;
            if ( !opts ) opts = {};
            ZipPassThrough.call( this, filename );
            this.d = new Deflate( opts, function( dat, _final17 ) {
                _this_1.ondata( null, dat, _final17 );
            } );
            this.compression = 8;
            this.flag = dbf( opts.level );
        }
        ZipDeflate.prototype.process = function( chunk, _final18 ) {
            try {
                this.d.push( chunk, _final18 );
            } catch ( e ) {
                this.ondata( e, null, _final18 );
            }
        };
        /**
         * Pushes a chunk to be deflated
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        ZipDeflate.prototype.push = function( chunk, _final19 ) {
            ZipPassThrough.prototype.push.call( this, chunk, _final19 );
        };
        return ZipDeflate;
    }( );
    /**
     * Asynchronous streaming DEFLATE compression for ZIP archives
     */
    var AsyncZipDeflate = /*#__PURE__*/ function( ) {
        /**
         * Creates a DEFLATE stream that can be added to ZIP archives
         * @param filename The filename to associate with this data stream
         * @param opts The compression options
         */
        function AsyncZipDeflate( filename, opts ) {
            var _this_1 = this;
            if ( !opts ) opts = {};
            ZipPassThrough.call( this, filename );
            this.d = new AsyncDeflate( opts, function( err, dat, _final20 ) {
                _this_1.ondata( err, dat, _final20 );
            } );
            this.compression = 8;
            this.flag = dbf( opts.level );
            this.terminate = this.d.terminate;
        }
        AsyncZipDeflate.prototype.process = function( chunk, _final21 ) {
            this.d.push( chunk, _final21 );
        };
        /**
         * Pushes a chunk to be deflated
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        AsyncZipDeflate.prototype.push = function( chunk, _final22 ) {
            ZipPassThrough.prototype.push.call( this, chunk, _final22 );
        };
        return AsyncZipDeflate;
    }( ); // TODO: Better tree shaking
    /**
     * A zippable archive to which files can incrementally be added
     */
    var Zip = /*#__PURE__*/ function( ) {
        /**
         * Creates an empty ZIP archive to which files can be added
         * @param cb The callback to call whenever data for the generated ZIP archive
         *           is available
         */
        function Zip( cb ) {
            this.ondata = cb;
            this.u = [ ];
            this.d = 1;
        }
        /**
         * Adds a file to the ZIP archive
         * @param file The file stream to add
         */
        Zip.prototype.add = function( file ) {
            var _this_1 = this;
            if ( this.d & 2 ) throw 'stream finished';
            var f = strToU8( file.filename ),
                fl = f.length;
            var com = file.comment,
                o = com && strToU8( com );
            var u = fl != file.filename.length || o && com.length != o.length;
            var hl = fl + exfl( file.extra ) + 30;
            if ( fl > 65535 ) throw 'filename too long';
            var header = new u8( hl );
            wzh( header, 0, file, f, u );
            var chks = [ header ];
            var pAll = function pAll( ) {
                for ( var _i = 0, chks_1 = chks; _i < chks_1.length; _i++ ) {
                    var chk = chks_1[ _i ];
                    _this_1.ondata( null, chk, false );
                }
                chks = [ ];
            };
            var tr = this.d;
            this.d = 0;
            var ind = this.u.length;
            var uf = mrg( file, {
                f: f,
                u: u,
                o: o,
                t: function t( ) {
                    if ( file.terminate ) file.terminate( );
                },
                r: function r( ) {
                    pAll( );
                    if ( tr ) {
                        var nxt = _this_1.u[ ind + 1 ];
                        if ( nxt ) nxt.r( );
                        else _this_1.d = 1;
                    }
                    tr = 1;
                }
            } );
            var cl = 0;
            file.ondata = function( err, dat, _final23 ) {
                if ( err ) {
                    _this_1.ondata( err, dat, _final23 );
                    _this_1.terminate( );
                } else {
                    cl += dat.length;
                    chks.push( dat );
                    if ( _final23 ) {
                        var dd = new u8( 16 );
                        wbytes( dd, 0, 0x8074B50 );
                        wbytes( dd, 4, file.crc );
                        wbytes( dd, 8, cl );
                        wbytes( dd, 12, file.size );
                        chks.push( dd );
                        uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
                        if ( tr ) uf.r( );
                        tr = 1;
                    } else if ( tr ) pAll( );
                }
            };
            this.u.push( uf );
        };
        /**
         * Ends the process of adding files and prepares to emit the final chunks.
         * This *must* be called after adding all desired files for the resulting
         * ZIP file to work properly.
         */
        Zip.prototype.end = function( ) {
            var _this_1 = this;
            if ( this.d & 2 ) {
                if ( this.d & 1 ) throw 'stream finishing';
                throw 'stream finished';
            }
            if ( this.d ) this.e( );
            else this.u.push( {
                r: function r( ) {
                    if ( !( _this_1.d & 1 ) ) return;
                    _this_1.u.splice( -1, 1 );
                    _this_1.e( );
                },
                t: function t( ) {}
            } );
            this.d = 3;
        };
        Zip.prototype.e = function( ) {
            var bt = 0,
                l = 0,
                tl = 0;
            for ( var _i = 0, _a = this.u; _i < _a.length; _i++ ) {
                var f = _a[ _i ];
                tl += 46 + f.f.length + exfl( f.extra ) + ( f.o ? f.o.length : 0 );
            }
            var out = new u8( tl + 22 );
            for ( var _b = 0, _c = this.u; _b < _c.length; _b++ ) {
                var f = _c[ _b ];
                wzh( out, bt, f, f.f, f.u, f.c, l, f.o );
                bt += 46 + f.f.length + exfl( f.extra ) + ( f.o ? f.o.length : 0 ), l += f.b;
            }
            wzf( out, bt, this.u.length, tl, l );
            this.ondata( null, out, true );
            this.d = 2;
        };
        /**
         * A method to terminate any internal workers used by the stream. Subsequent
         * calls to add() will fail.
         */
        Zip.prototype.terminate = function( ) {
            for ( var _i = 0, _a = this.u; _i < _a.length; _i++ ) {
                var f = _a[ _i ];
                f.t( );
            }
            this.d = 2;
        };
        return Zip;
    }( );

    function zip( data, opts, cb ) {
        if ( !cb ) cb = opts, opts = {};
        if ( typeof cb != 'function' ) throw 'no callback';
        var r = {};
        fltn( data, '', r, opts );
        var k = Object.keys( r );
        var lft = k.length,
            o = 0,
            tot = 0;
        var slft = lft,
            files = new Array( lft );
        var term = [ ];
        var tAll = function tAll( ) {
            for ( var i = 0; i < term.length; ++i ) {
                term[ i ]( );
            }
        };
        var cbf = function cbf( ) {
            var out = new u8( tot + 22 ),
                oe = o,
                cdl = tot - o;
            tot = 0;
            for ( var i = 0; i < slft; ++i ) {
                var f = files[ i ];
                try {
                    var l = f.c.length;
                    wzh( out, tot, f, f.f, f.u, l );
                    var badd = 30 + f.f.length + exfl( f.extra );
                    var loc = tot + badd;
                    out.set( f.c, loc );
                    wzh( out, o, f, f.f, f.u, l, tot, f.m ), o += 16 + badd + ( f.m ? f.m.length : 0 ), tot = loc + l;
                } catch ( e ) {
                    return cb( e, null );
                }
            }
            wzf( out, o, files.length, cdl, oe );
            cb( null, out );
        };
        if ( !lft ) cbf( );
        var _loop_1 = function _loop_1( i ) {
            var fn = k[ i ];
            var _a = r[ fn ],
                file = _a[ 0 ],
                p = _a[ 1 ];
            var c = crc( ),
                size = file.length;
            c.p( file );
            var f = strToU8( fn ),
                s = f.length;
            var com = p.comment,
                m = com && strToU8( com ),
                ms = m && m.length;
            var exl = exfl( p.extra );
            var compression = p.level == 0 ? 0 : 8;
            var cbl = function cbl( e, d ) {
                if ( e ) {
                    tAll( );
                    cb( e, null );
                } else {
                    var l = d.length;
                    files[ i ] = mrg( p, {
                        size: size,
                        crc: c.d( ),
                        c: d,
                        f: f,
                        m: m,
                        u: s != fn.length || m && com.length != ms,
                        compression: compression
                    } );
                    o += 30 + s + exl + l;
                    tot += 76 + 2 * ( s + exl ) + ( ms || 0 ) + l;
                    if ( !--lft ) cbf( );
                }
            };
            if ( s > 65535 ) cbl( 'filename too long', null );
            if ( !compression ) cbl( null, file );
            else if ( size < 160000 ) {
                try {
                    cbl( null, deflateSync( file, p ) );
                } catch ( e ) {
                    cbl( e, null );
                }
            } else term.push( deflate( file, p, cbl ) );
        }; // Cannot use lft because it can decrease
        for ( var i = 0; i < slft; ++i ) {
            _loop_1( i );
        }
        return tAll;
    }
    /**
     * Synchronously creates a ZIP file. Prefer using `zip` for better performance
     * with more than one file.
     * @param data The directory structure for the ZIP archive
     * @param opts The main options, merged with per-file options
     * @returns The generated ZIP archive
     */
    function zipSync( data, opts ) {
        if ( !opts ) opts = {};
        var r = {};
        var files = [ ];
        fltn( data, '', r, opts );
        var o = 0;
        var tot = 0;
        for ( var fn in r ) {
            var _a = r[ fn ],
                file = _a[ 0 ],
                p = _a[ 1 ];
            var compression = p.level == 0 ? 0 : 8;
            var f = strToU8( fn ),
                s = f.length;
            var com = p.comment,
                m = com && strToU8( com ),
                ms = m && m.length;
            var exl = exfl( p.extra );
            if ( s > 65535 ) throw 'filename too long';
            var d = compression ? deflateSync( file, p ) : file,
                l = d.length;
            var c = crc( );
            c.p( file );
            files.push( mrg( p, {
                size: file.length,
                crc: c.d( ),
                c: d,
                f: f,
                m: m,
                u: s != fn.length || m && com.length != ms,
                o: o,
                compression: compression
            } ) );
            o += 30 + s + exl + l;
            tot += 76 + 2 * ( s + exl ) + ( ms || 0 ) + l;
        }
        var out = new u8( tot + 22 ),
            oe = o,
            cdl = tot - o;
        for ( var i = 0; i < files.length; ++i ) {
            var f = files[ i ];
            wzh( out, f.o, f, f.f, f.u, f.c.length );
            var badd = 30 + f.f.length + exfl( f.extra );
            out.set( f.c, f.o + badd );
            wzh( out, o, f, f.f, f.u, f.c.length, f.o, f.m ), o += 16 + badd + ( f.m ? f.m.length : 0 );
        }
        wzf( out, o, files.length, cdl, oe );
        return out;
    }
    /**
     * Streaming pass-through decompression for ZIP archives
     */
    var UnzipPassThrough = /*#__PURE__*/ function( ) {
        function UnzipPassThrough( ) {}
        UnzipPassThrough.prototype.push = function( data, _final24 ) {
            this.ondata( null, data, _final24 );
        };
        UnzipPassThrough.compression = 0;
        return UnzipPassThrough;
    }( );
    /**
     * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
     * better performance.
     */
    var UnzipInflate = /*#__PURE__*/ function( ) {
        /**
         * Creates a DEFLATE decompression that can be used in ZIP archives
         */
        function UnzipInflate( ) {
            var _this_1 = this;
            this.i = new Inflate( function( dat, _final25 ) {
                _this_1.ondata( null, dat, _final25 );
            } );
        }
        UnzipInflate.prototype.push = function( data, _final26 ) {
            try {
                this.i.push( data, _final26 );
            } catch ( e ) {
                this.ondata( e, data, _final26 );
            }
        };
        UnzipInflate.compression = 8;
        return UnzipInflate;
    }( );
    /**
     * Asynchronous streaming DEFLATE decompression for ZIP archives
     */
    var AsyncUnzipInflate = /*#__PURE__*/ function( ) {
        /**
         * Creates a DEFLATE decompression that can be used in ZIP archives
         */
        function AsyncUnzipInflate( _, sz ) {
            var _this_1 = this;
            if ( sz < 320000 ) {
                this.i = new Inflate( function( dat, _final27 ) {
                    _this_1.ondata( null, dat, _final27 );
                } );
            } else {
                this.i = new AsyncInflate( function( err, dat, _final28 ) {
                    _this_1.ondata( err, dat, _final28 );
                } );
                this.terminate = this.i.terminate;
            }
        }
        AsyncUnzipInflate.prototype.push = function( data, _final29 ) {
            if ( this.i.terminate ) data = slc( data, 0 );
            this.i.push( data, _final29 );
        };
        AsyncUnzipInflate.compression = 8;
        return AsyncUnzipInflate;
    }( );
    /**
     * A ZIP archive decompression stream that emits files as they are discovered
     */
    var Unzip = /*#__PURE__*/ function( ) {
        /**
         * Creates a ZIP decompression stream
         * @param cb The callback to call whenever a file in the ZIP archive is found
         */
        function Unzip( cb ) {
            this.onfile = cb;
            this.k = [ ];
            this.o = {
                0: UnzipPassThrough
            };
            this.p = et;
        }
        /**
         * Pushes a chunk to be unzipped
         * @param chunk The chunk to push
         * @param final Whether this is the last chunk
         */
        Unzip.prototype.push = function( chunk, _final30 ) {
            var _this_1 = this;
            if ( !this.onfile ) throw 'no callback';
            if ( !this.p ) throw 'stream finished';
            if ( this.c > 0 ) {
                var len = Math.min( this.c, chunk.length );
                var toAdd = chunk.subarray( 0, len );
                this.c -= len;
                if ( this.d ) this.d.push( toAdd, !this.c );
                else this.k[ 0 ].push( toAdd );
                chunk = chunk.subarray( len );
                if ( chunk.length ) return this.push( chunk, _final30 );
            } else {
                var f = 0,
                    i = 0,
                    is = void 0,
                    buf = void 0;
                if ( !this.p.length ) buf = chunk;
                else if ( !chunk.length ) buf = this.p;
                else {
                    buf = new u8( this.p.length + chunk.length );
                    buf.set( this.p ), buf.set( chunk, this.p.length );
                }
                var l = buf.length,
                    oc = this.c,
                    add = oc && this.d;
                var _loop_2 = function _loop_2( ) {
                    var _a;
                    var sig = b4( buf, i );
                    if ( sig == 0x4034B50 ) {
                        f = 1, is = i;
                        this_1.d = null;
                        this_1.c = 0;
                        var bf = b2( buf, i + 6 ),
                            cmp_1 = b2( buf, i + 8 ),
                            u = bf & 2048,
                            dd = bf & 8,
                            fnl = b2( buf, i + 26 ),
                            es = b2( buf, i + 28 );
                        if ( l > i + 30 + fnl + es ) {
                            var chks_2 = [ ];
                            this_1.k.unshift( chks_2 );
                            f = 2;
                            var sc_1 = b4( buf, i + 18 ),
                                su_1 = b4( buf, i + 22 );
                            var fn_1 = strFromU8( buf.subarray( i + 30, i += 30 + fnl ), !u );
                            if ( sc_1 == 4294967295 ) {
                                _a = dd ? [ -2 ] : z64e( buf, i ), sc_1 = _a[ 0 ], su_1 = _a[ 1 ];
                            } else if ( dd ) sc_1 = -1;
                            i += es;
                            this_1.c = sc_1;
                            var d_1;
                            var file_1 = {
                                name: fn_1,
                                compression: cmp_1,
                                start: function start( ) {
                                    if ( !file_1.ondata ) throw 'no callback';
                                    if ( !sc_1 ) file_1.ondata( null, et, true );
                                    else {
                                        var ctr = _this_1.o[ cmp_1 ];
                                        if ( !ctr ) throw 'unknown compression type ' + cmp_1;
                                        d_1 = sc_1 < 0 ? new ctr( fn_1 ) : new ctr( fn_1, sc_1, su_1 );
                                        d_1.ondata = function( err, dat, _final31 ) {
                                            file_1.ondata( err, dat, _final31 );
                                        };
                                        for ( var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++ ) {
                                            var dat = chks_3[ _i ];
                                            d_1.push( dat, false );
                                        }
                                        if ( _this_1.k[ 0 ] == chks_2 && _this_1.c ) _this_1.d = d_1;
                                        else d_1.push( et, true );
                                    }
                                },
                                terminate: function terminate( ) {
                                    if ( d_1 && d_1.terminate ) d_1.terminate( );
                                }
                            };
                            if ( sc_1 >= 0 ) file_1.size = sc_1, file_1.originalSize = su_1;
                            this_1.onfile( file_1 );
                        }
                        return "break";
                    } else if ( oc ) {
                        if ( sig == 0x8074B50 ) {
                            is = i += 12 + ( oc == -2 && 8 ), f = 3, this_1.c = 0;
                            return "break";
                        } else if ( sig == 0x2014B50 ) {
                            is = i -= 4, f = 3, this_1.c = 0;
                            return "break";
                        }
                    }
                };
                var this_1 = this;
                for ( ; i < l - 4; ++i ) {
                    var state_1 = _loop_2( );
                    if ( state_1 === "break" ) break;
                }
                this.p = et;
                if ( oc < 0 ) {
                    var dat = f ? buf.subarray( 0, is - 12 - ( oc == -2 && 8 ) - ( b4( buf, is - 16 ) == 0x8074B50 && 4 ) ) : buf.subarray( 0, i );
                    if ( add ) add.push( dat, !!f );
                    else this.k[ +( f == 2 ) ].push( dat );
                }
                if ( f & 2 ) return this.push( buf.subarray( i ), _final30 );
                this.p = buf.subarray( i );
            }
            if ( _final30 ) {
                if ( this.c ) throw 'invalid zip file';
                this.p = null;
            }
        };
        /**
         * Registers a decoder with the stream, allowing for files compressed with
         * the compression type provided to be expanded correctly
         * @param decoder The decoder constructor
         */
        Unzip.prototype.register = function( decoder ) {
            this.o[ decoder.compression ] = decoder;
        };
        return Unzip;
    }( );
    /**
     * Asynchronously decompresses a ZIP archive
     * @param data The raw compressed ZIP file
     * @param cb The callback to call with the decompressed files
     * @returns A function that can be used to immediately terminate the unzipping
     */
    function unzip( data, cb ) {
        if ( typeof cb != 'function' ) throw 'no callback';
        var term = [ ];
        var tAll = function tAll( ) {
            for ( var i = 0; i < term.length; ++i ) {
                term[ i ]( );
            }
        };
        var files = {};
        var e = data.length - 22;
        for ( ; b4( data, e ) != 0x6054B50; --e ) {
            if ( !e || data.length - e > 65558 ) {
                cb( 'invalid zip file', null );
                return;
            }
        }
        var lft = b2( data, e + 8 );
        if ( !lft ) cb( null, {} );
        var c = lft;
        var o = b4( data, e + 16 );
        var z = o == 4294967295;
        if ( z ) {
            e = b4( data, e - 12 );
            if ( b4( data, e ) != 0x6064B50 ) {
                cb( 'invalid zip file', null );
                return;
            }
            c = lft = b4( data, e + 32 );
            o = b4( data, e + 48 );
        }
        var _loop_3 = function _loop_3( i ) {
            var _a = zh( data, o, z ),
                c_1 = _a[ 0 ],
                sc = _a[ 1 ],
                su = _a[ 2 ],
                fn = _a[ 3 ],
                no = _a[ 4 ],
                off = _a[ 5 ],
                b = slzh( data, off );
            o = no;
            var cbl = function cbl( e, d ) {
                if ( e ) {
                    tAll( );
                    cb( e, null );
                } else {
                    files[ fn ] = d;
                    if ( !--lft ) cb( null, files );
                }
            };
            if ( !c_1 ) cbl( null, slc( data, b, b + sc ) );
            else if ( c_1 == 8 ) {
                var infl = data.subarray( b, b + sc );
                if ( sc < 320000 ) {
                    try {
                        cbl( null, inflateSync( infl, new u8( su ) ) );
                    } catch ( e ) {
                        cbl( e, null );
                    }
                } else term.push( inflate( infl, {
                    size: su
                }, cbl ) );
            } else cbl( 'unknown compression type ' + c_1, null );
        };
        for ( var i = 0; i < c; ++i ) {
            _loop_3( );
        }
        return tAll;
    }
    /**
     * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
     * performance with more than one file.
     * @param data The raw compressed ZIP file
     * @returns The decompressed files
     */
    function unzipSync( data ) {
        var files = {};
        var e = data.length - 22;
        for ( ; b4( data, e ) != 0x6054B50; --e ) {
            if ( !e || data.length - e > 65558 ) throw 'invalid zip file';
        }
        var c = b2( data, e + 8 );
        if ( !c ) return {};
        var o = b4( data, e + 16 );
        var z = o == 4294967295;
        if ( z ) {
            e = b4( data, e - 12 );
            if ( b4( data, e ) != 0x6064B50 ) throw 'invalid zip file';
            c = b4( data, e + 32 );
            o = b4( data, e + 48 );
        }
        for ( var i = 0; i < c; ++i ) {
            var _a = zh( data, o, z ),
                c_2 = _a[ 0 ],
                sc = _a[ 1 ],
                su = _a[ 2 ],
                fn = _a[ 3 ],
                no = _a[ 4 ],
                off = _a[ 5 ],
                b = slzh( data, off );
            o = no;
            if ( !c_2 ) files[ fn ] = slc( data, b, b + sc );
            else if ( c_2 == 8 ) files[ fn ] = inflateSync( data.subarray( b, b + sc ), new u8( su ) );
            else throw 'unknown compression type ' + c_2;
        }
        return files;
    }
    var fflate = /*#__PURE__*/ Object.freeze( {
        __proto__: null,
        Deflate: Deflate,
        AsyncDeflate: AsyncDeflate,
        deflate: deflate,
        deflateSync: deflateSync,
        Inflate: Inflate,
        AsyncInflate: AsyncInflate,
        inflate: inflate,
        inflateSync: inflateSync,
        Gzip: Gzip,
        AsyncGzip: AsyncGzip,
        gzip: gzip,
        gzipSync: gzipSync,
        Gunzip: Gunzip,
        AsyncGunzip: AsyncGunzip,
        gunzip: gunzip,
        gunzipSync: gunzipSync,
        Zlib: Zlib,
        AsyncZlib: AsyncZlib,
        zlib: zlib,
        zlibSync: zlibSync,
        Unzlib: Unzlib,
        AsyncUnzlib: AsyncUnzlib,
        unzlib: unzlib,
        unzlibSync: unzlibSync,
        compress: gzip,
        AsyncCompress: AsyncGzip,
        compressSync: gzipSync,
        Compress: Gzip,
        Decompress: Decompress,
        AsyncDecompress: AsyncDecompress,
        decompress: decompress,
        decompressSync: decompressSync,
        DecodeUTF8: DecodeUTF8,
        EncodeUTF8: EncodeUTF8,
        strToU8: strToU8,
        strFromU8: strFromU8,
        ZipPassThrough: ZipPassThrough,
        ZipDeflate: ZipDeflate,
        AsyncZipDeflate: AsyncZipDeflate,
        Zip: Zip,
        zip: zip,
        zipSync: zipSync,
        UnzipPassThrough: UnzipPassThrough,
        UnzipInflate: UnzipInflate,
        AsyncUnzipInflate: AsyncUnzipInflate,
        Unzip: Unzip,
        unzip: unzip,
        unzipSync: unzipSync
    } );
    /**
     * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
     * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
     *
     * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
     * implementation, so I have preserved their copyright notices.
     */ // /*
    // Copyright (c) 2014 - 2017, Syoyo Fujita
    // All rights reserved.
    // Redistribution and use in source and binary forms, with or without
    // modification, are permitted provided that the following conditions are met:
    //     * Redistributions of source code must retain the above copyright
    //       notice, this list of conditions and the following disclaimer.
    //     * Redistributions in binary form must reproduce the above copyright
    //       notice, this list of conditions and the following disclaimer in the
    //       documentation and/or other materials provided with the distribution.
    //     * Neither the name of the Syoyo Fujita nor the
    //       names of its contributors may be used to endorse or promote products
    //       derived from this software without specific prior written permission.
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    // DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    // DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    // (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    // ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    // */
    // // TinyEXR contains some OpenEXR code, which is licensed under ------------
    // ///////////////////////////////////////////////////////////////////////////
    // //
    // // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
    // // Digital Ltd. LLC
    // //
    // // All rights reserved.
    // //
    // // Redistribution and use in source and binary forms, with or without
    // // modification, are permitted provided that the following conditions are
    // // met:
    // // *       Redistributions of source code must retain the above copyright
    // // notice, this list of conditions and the following disclaimer.
    // // *       Redistributions in binary form must reproduce the above
    // // copyright notice, this list of conditions and the following disclaimer
    // // in the documentation and/or other materials provided with the
    // // distribution.
    // // *       Neither the name of Industrial Light & Magic nor the names of
    // // its contributors may be used to endorse or promote products derived
    // // from this software without specific prior written permission.
    // //
    // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    // // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    // // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    // // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    // // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    // // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    // // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    // // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    // // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    // // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    // // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    // //
    // ///////////////////////////////////////////////////////////////////////////
    // // End of OpenEXR license -------------------------------------------------
    var EXRLoader = /*#__PURE__*/ function( _DataTextureLoader ) {
        _inherits( EXRLoader, _DataTextureLoader );
        var _super70 = _createSuper( EXRLoader );

        function EXRLoader( manager ) {
            var _this54;
            _classCallCheck( this, EXRLoader );
            _this54 = _super70.call( this, manager );
            _this54.type = HalfFloatType;
            return _this54;
        }
        _createClass( EXRLoader, [ {
            key: "parse",
            value: function parse( buffer ) {
                var USHORT_RANGE = 1 << 16;
                var BITMAP_SIZE = USHORT_RANGE >> 3;
                var HUF_ENCBITS = 16; // literal (value) bit length
                var HUF_DECBITS = 14; // decoding bit size (>= 8)
                var HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size
                var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
                var HUF_DECMASK = HUF_DECSIZE - 1;
                var NBITS = 16;
                var A_OFFSET = 1 << NBITS - 1;
                var MOD_MASK = ( 1 << NBITS ) - 1;
                var SHORT_ZEROCODE_RUN = 59;
                var LONG_ZEROCODE_RUN = 63;
                var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
                var ULONG_SIZE = 8;
                var FLOAT32_SIZE = 4;
                var INT32_SIZE = 4;
                var INT16_SIZE = 2;
                var INT8_SIZE = 1;
                var STATIC_HUFFMAN = 0;
                var DEFLATE = 1;
                var UNKNOWN = 0;
                var LOSSY_DCT = 1;
                var RLE = 2;
                var logBase = Math.pow( 2.7182818, 2.2 );

                function reverseLutFromBitmap( bitmap, lut ) {
                    var k = 0;
                    for ( var _i263 = 0; _i263 < USHORT_RANGE; ++_i263 ) {
                        if ( _i263 == 0 || bitmap[ _i263 >> 3 ] & 1 << ( _i263 & 7 ) ) {
                            lut[ k++ ] = _i263;
                        }
                    }
                    var n = k - 1;
                    while ( k < USHORT_RANGE ) {
                        lut[ k++ ] = 0;
                    }
                    return n;
                }

                function hufClearDecTable( hdec ) {
                    for ( var _i264 = 0; _i264 < HUF_DECSIZE; _i264++ ) {
                        hdec[ _i264 ] = {};
                        hdec[ _i264 ].len = 0;
                        hdec[ _i264 ].lit = 0;
                        hdec[ _i264 ].p = null;
                    }
                }
                var getBitsReturn = {
                    l: 0,
                    c: 0,
                    lc: 0
                };

                function getBits( nBits, c, lc, uInt8Array, inOffset ) {
                    while ( lc < nBits ) {
                        c = c << 8 | parseUint8Array( uInt8Array, inOffset );
                        lc += 8;
                    }
                    lc -= nBits;
                    getBitsReturn.l = c >> lc & ( 1 << nBits ) - 1;
                    getBitsReturn.c = c;
                    getBitsReturn.lc = lc;
                }
                var hufTableBuffer = new Array( 59 );

                function hufCanonicalCodeTable( hcode ) {
                    for ( var _i265 = 0; _i265 <= 58; ++_i265 ) {
                        hufTableBuffer[ _i265 ] = 0;
                    }
                    for ( var _i266 = 0; _i266 < HUF_ENCSIZE; ++_i266 ) {
                        hufTableBuffer[ hcode[ _i266 ] ] += 1;
                    }
                    var c = 0;
                    for ( var _i267 = 58; _i267 > 0; --_i267 ) {
                        var nc = c + hufTableBuffer[ _i267 ] >> 1;
                        hufTableBuffer[ _i267 ] = c;
                        c = nc;
                    }
                    for ( var _i268 = 0; _i268 < HUF_ENCSIZE; ++_i268 ) {
                        var l = hcode[ _i268 ];
                        if ( l > 0 ) hcode[ _i268 ] = l | hufTableBuffer[ l ]++ << 6;
                    }
                }

                function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {
                    var p = inOffset;
                    var c = 0;
                    var lc = 0;
                    for ( ; im <= iM; im++ ) {
                        if ( p.value - inOffset.value > ni ) return false;
                        getBits( 6, c, lc, uInt8Array, p );
                        var l = getBitsReturn.l;
                        c = getBitsReturn.c;
                        lc = getBitsReturn.lc;
                        hcode[ im ] = l;
                        if ( l == LONG_ZEROCODE_RUN ) {
                            if ( p.value - inOffset.value > ni ) {
                                throw new Error( 'Something wrong with hufUnpackEncTable' );
                            }
                            getBits( 8, c, lc, uInt8Array, p );
                            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
                            c = getBitsReturn.c;
                            lc = getBitsReturn.lc;
                            if ( im + zerun > iM + 1 ) {
                                throw new Error( 'Something wrong with hufUnpackEncTable' );
                            }
                            while ( zerun-- ) {
                                hcode[ im++ ] = 0;
                            }
                            im--;
                        } else if ( l >= SHORT_ZEROCODE_RUN ) {
                            var _zerun = l - SHORT_ZEROCODE_RUN + 2;
                            if ( im + _zerun > iM + 1 ) {
                                throw new Error( 'Something wrong with hufUnpackEncTable' );
                            }
                            while ( _zerun-- ) {
                                hcode[ im++ ] = 0;
                            }
                            im--;
                        }
                    }
                    hufCanonicalCodeTable( hcode );
                }

                function hufLength( code ) {
                    return code & 63;
                }

                function hufCode( code ) {
                    return code >> 6;
                }

                function hufBuildDecTable( hcode, im, iM, hdecod ) {
                    for ( ; im <= iM; im++ ) {
                        var _c10 = hufCode( hcode[ im ] );
                        var l = hufLength( hcode[ im ] );
                        if ( _c10 >> l ) {
                            throw new Error( 'Invalid table entry' );
                        }
                        if ( l > HUF_DECBITS ) {
                            var pl = hdecod[ _c10 >> l - HUF_DECBITS ];
                            if ( pl.len ) {
                                throw new Error( 'Invalid table entry' );
                            }
                            pl.lit++;
                            if ( pl.p ) {
                                var p = pl.p;
                                pl.p = new Array( pl.lit );
                                for ( var _i269 = 0; _i269 < pl.lit - 1; ++_i269 ) {
                                    pl.p[ _i269 ] = p[ _i269 ];
                                }
                            } else {
                                pl.p = new Array( 1 );
                            }
                            pl.p[ pl.lit - 1 ] = im;
                        } else if ( l ) {
                            var plOffset = 0;
                            for ( var _i270 = 1 << HUF_DECBITS - l; _i270 > 0; _i270-- ) {
                                var _pl = hdecod[ ( _c10 << HUF_DECBITS - l ) + plOffset ];
                                if ( _pl.len || _pl.p ) {
                                    throw new Error( 'Invalid table entry' );
                                }
                                _pl.len = l;
                                _pl.lit = im;
                                plOffset++;
                            }
                        }
                    }
                    return true;
                }
                var getCharReturn = {
                    c: 0,
                    lc: 0
                };

                function getChar( c, lc, uInt8Array, inOffset ) {
                    c = c << 8 | parseUint8Array( uInt8Array, inOffset );
                    lc += 8;
                    getCharReturn.c = c;
                    getCharReturn.lc = lc;
                }
                var getCodeReturn = {
                    c: 0,
                    lc: 0
                };

                function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {
                    if ( po == rlc ) {
                        if ( lc < 8 ) {
                            getChar( c, lc, uInt8Array, inOffset );
                            c = getCharReturn.c;
                            lc = getCharReturn.lc;
                        }
                        lc -= 8;
                        var cs = c >> lc;
                        cs = new Uint8Array( [ cs ] )[ 0 ];
                        if ( outBufferOffset.value + cs > outBufferEndOffset ) {
                            return false;
                        }
                        var s = outBuffer[ outBufferOffset.value - 1 ];
                        while ( cs-- > 0 ) {
                            outBuffer[ outBufferOffset.value++ ] = s;
                        }
                    } else if ( outBufferOffset.value < outBufferEndOffset ) {
                        outBuffer[ outBufferOffset.value++ ] = po;
                    } else {
                        return false;
                    }
                    getCodeReturn.c = c;
                    getCodeReturn.lc = lc;
                }

                function UInt16( value ) {
                    return value & 0xFFFF;
                }

                function Int16( value ) {
                    var ref = UInt16( value );
                    return ref > 0x7FFF ? ref - 0x10000 : ref;
                }
                var wdec14Return = {
                    a: 0,
                    b: 0
                };

                function wdec14( l, h ) {
                    var ls = Int16( l );
                    var hs = Int16( h );
                    var hi = hs;
                    var ai = ls + ( hi & 1 ) + ( hi >> 1 );
                    var as = ai;
                    var bs = ai - hi;
                    wdec14Return.a = as;
                    wdec14Return.b = bs;
                }

                function wdec16( l, h ) {
                    var m = UInt16( l );
                    var d = UInt16( h );
                    var bb = m - ( d >> 1 ) & MOD_MASK;
                    var aa = d + bb - A_OFFSET & MOD_MASK;
                    wdec14Return.a = aa;
                    wdec14Return.b = bb;
                }

                function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {
                    var w14 = mx < 1 << 14;
                    var n = nx > ny ? ny : nx;
                    var p = 1;
                    var p2;
                    var py;
                    while ( p <= n ) {
                        p <<= 1;
                    }
                    p >>= 1;
                    p2 = p;
                    p >>= 1;
                    while ( p >= 1 ) {
                        py = 0;
                        var ey = py + oy * ( ny - p2 );
                        var oy1 = oy * p;
                        var oy2 = oy * p2;
                        var ox1 = ox * p;
                        var ox2 = ox * p2;
                        var i00 = void 0,
                            i01 = void 0,
                            i10 = void 0,
                            i11 = void 0;
                        for ( ; py <= ey; py += oy2 ) {
                            var _px = py;
                            var ex = py + ox * ( nx - p2 );
                            for ( ; _px <= ex; _px += ox2 ) {
                                var p01 = _px + ox1;
                                var p10 = _px + oy1;
                                var p11 = p10 + ox1;
                                if ( w14 ) {
                                    wdec14( buffer[ _px + j ], buffer[ p10 + j ] );
                                    i00 = wdec14Return.a;
                                    i10 = wdec14Return.b;
                                    wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );
                                    i01 = wdec14Return.a;
                                    i11 = wdec14Return.b;
                                    wdec14( i00, i01 );
                                    buffer[ _px + j ] = wdec14Return.a;
                                    buffer[ p01 + j ] = wdec14Return.b;
                                    wdec14( i10, i11 );
                                    buffer[ p10 + j ] = wdec14Return.a;
                                    buffer[ p11 + j ] = wdec14Return.b;
                                } else {
                                    wdec16( buffer[ _px + j ], buffer[ p10 + j ] );
                                    i00 = wdec14Return.a;
                                    i10 = wdec14Return.b;
                                    wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );
                                    i01 = wdec14Return.a;
                                    i11 = wdec14Return.b;
                                    wdec16( i00, i01 );
                                    buffer[ _px + j ] = wdec14Return.a;
                                    buffer[ p01 + j ] = wdec14Return.b;
                                    wdec16( i10, i11 );
                                    buffer[ p10 + j ] = wdec14Return.a;
                                    buffer[ p11 + j ] = wdec14Return.b;
                                }
                            }
                            if ( nx & p ) {
                                var _p = _px + oy1;
                                if ( w14 ) wdec14( buffer[ _px + j ], buffer[ _p + j ] );
                                else wdec16( buffer[ _px + j ], buffer[ _p + j ] );
                                i00 = wdec14Return.a;
                                buffer[ _p + j ] = wdec14Return.b;
                                buffer[ _px + j ] = i00;
                            }
                        }
                        if ( ny & p ) {
                            var _px2 = py;
                            var _ex = py + ox * ( nx - p2 );
                            for ( ; _px2 <= _ex; _px2 += ox2 ) {
                                var _p2 = _px2 + ox1;
                                if ( w14 ) wdec14( buffer[ _px2 + j ], buffer[ _p2 + j ] );
                                else wdec16( buffer[ _px2 + j ], buffer[ _p2 + j ] );
                                i00 = wdec14Return.a;
                                buffer[ _p2 + j ] = wdec14Return.b;
                                buffer[ _px2 + j ] = i00;
                            }
                        }
                        p2 = p;
                        p >>= 1;
                    }
                    return py;
                }

                function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {
                    var c = 0;
                    var lc = 0;
                    var outBufferEndOffset = no;
                    var inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );
                    while ( inOffset.value < inOffsetEnd ) {
                        getChar( c, lc, uInt8Array, inOffset );
                        c = getCharReturn.c;
                        lc = getCharReturn.lc;
                        while ( lc >= HUF_DECBITS ) {
                            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;
                            var pl = decodingTable[ index ];
                            if ( pl.len ) {
                                lc -= pl.len;
                                getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );
                                c = getCodeReturn.c;
                                lc = getCodeReturn.lc;
                            } else {
                                if ( !pl.p ) {
                                    throw new Error( 'hufDecode issues' );
                                }
                                var j = void 0;
                                for ( j = 0; j < pl.lit; j++ ) {
                                    var l = hufLength( encodingTable[ pl.p[ j ] ] );
                                    while ( lc < l && inOffset.value < inOffsetEnd ) {
                                        getChar( c, lc, uInt8Array, inOffset );
                                        c = getCharReturn.c;
                                        lc = getCharReturn.lc;
                                    }
                                    if ( lc >= l ) {
                                        if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( c >> lc - l & ( 1 << l ) - 1 ) ) {
                                            lc -= l;
                                            getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );
                                            c = getCodeReturn.c;
                                            lc = getCodeReturn.lc;
                                            break;
                                        }
                                    }
                                }
                                if ( j == pl.lit ) {
                                    throw new Error( 'hufDecode issues' );
                                }
                            }
                        }
                    }
                    var i = 8 - ni & 7;
                    c >>= i;
                    lc -= i;
                    while ( lc > 0 ) {
                        var _pl2 = decodingTable[ c << HUF_DECBITS - lc & HUF_DECMASK ];
                        if ( _pl2.len ) {
                            lc -= _pl2.len;
                            getCode( _pl2.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );
                            c = getCodeReturn.c;
                            lc = getCodeReturn.lc;
                        } else {
                            throw new Error( 'hufDecode issues' );
                        }
                    }
                    return true;
                }

                function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {
                    var outOffset = {
                        value: 0
                    };
                    var initialInOffset = inOffset.value;
                    var im = parseUint32( inDataView, inOffset );
                    var iM = parseUint32( inDataView, inOffset );
                    inOffset.value += 4;
                    var nBits = parseUint32( inDataView, inOffset );
                    inOffset.value += 4;
                    if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {
                        throw new Error( 'Something wrong with HUF_ENCSIZE' );
                    }
                    var freq = new Array( HUF_ENCSIZE );
                    var hdec = new Array( HUF_DECSIZE );
                    hufClearDecTable( hdec );
                    var ni = nCompressed - ( inOffset.value - initialInOffset );
                    hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );
                    if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {
                        throw new Error( 'Something wrong with hufUncompress' );
                    }
                    hufBuildDecTable( freq, im, iM, hdec );
                    hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );
                }

                function applyLut( lut, data, nData ) {
                    for ( var _i271 = 0; _i271 < nData; ++_i271 ) {
                        data[ _i271 ] = lut[ data[ _i271 ] ];
                    }
                }

                function predictor( source ) {
                    for ( var t = 1; t < source.length; t++ ) {
                        var d = source[ t - 1 ] + source[ t ] - 128;
                        source[ t ] = d;
                    }
                }

                function interleaveScalar( source, out ) {
                    var t1 = 0;
                    var t2 = Math.floor( ( source.length + 1 ) / 2 );
                    var s = 0;
                    var stop = source.length - 1;
                    while ( true ) {
                        if ( s > stop ) break;
                        out[ s++ ] = source[ t1++ ];
                        if ( s > stop ) break;
                        out[ s++ ] = source[ t2++ ];
                    }
                }

                function decodeRunLength( source ) {
                    var size = source.byteLength;
                    var out = new Array( );
                    var p = 0;
                    var reader = new DataView( source );
                    while ( size > 0 ) {
                        var l = reader.getInt8( p++ );
                        if ( l < 0 ) {
                            var count = -l;
                            size -= count + 1;
                            for ( var _i272 = 0; _i272 < count; _i272++ ) {
                                out.push( reader.getUint8( p++ ) );
                            }
                        } else {
                            var _count2 = l;
                            size -= 2;
                            var _value8 = reader.getUint8( p++ );
                            for ( var _i273 = 0; _i273 < _count2 + 1; _i273++ ) {
                                out.push( _value8 );
                            }
                        }
                    }
                    return out;
                }

                function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {
                    var dataView = new DataView( outBuffer.buffer );
                    var width = channelData[ cscSet.idx[ 0 ] ].width;
                    var height = channelData[ cscSet.idx[ 0 ] ].height;
                    var numComp = 3;
                    var numFullBlocksX = Math.floor( width / 8.0 );
                    var numBlocksX = Math.ceil( width / 8.0 );
                    var numBlocksY = Math.ceil( height / 8.0 );
                    var leftoverX = width - ( numBlocksX - 1 ) * 8;
                    var leftoverY = height - ( numBlocksY - 1 ) * 8;
                    var currAcComp = {
                        value: 0
                    };
                    var currDcComp = new Array( numComp );
                    var dctData = new Array( numComp );
                    var halfZigBlock = new Array( numComp );
                    var rowBlock = new Array( numComp );
                    var rowOffsets = new Array( numComp );
                    for ( var comp = 0; comp < numComp; ++comp ) {
                        rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
                        currDcComp[ comp ] = comp < 1 ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
                        dctData[ comp ] = new Float32Array( 64 );
                        halfZigBlock[ comp ] = new Uint16Array( 64 );
                        rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );
                    }
                    for ( var blocky = 0; blocky < numBlocksY; ++blocky ) {
                        var maxY = 8;
                        if ( blocky == numBlocksY - 1 ) maxY = leftoverY;
                        var maxX = 8;
                        for ( var blockx = 0; blockx < numBlocksX; ++blockx ) {
                            if ( blockx == numBlocksX - 1 ) maxX = leftoverX;
                            for ( var _comp = 0; _comp < numComp; ++_comp ) {
                                halfZigBlock[ _comp ].fill( 0 ); // set block DC component
                                halfZigBlock[ _comp ][ 0 ] = dcBuffer[ currDcComp[ _comp ]++ ]; // set block AC components
                                unRleAC( currAcComp, acBuffer, halfZigBlock[ _comp ] ); // UnZigZag block to float
                                unZigZag( halfZigBlock[ _comp ], dctData[ _comp ] ); // decode float dct
                                dctInverse( dctData[ _comp ] );
                            } {
                                csc709Inverse( dctData );
                            }
                            for ( var _comp2 = 0; _comp2 < numComp; ++_comp2 ) {
                                convertToHalf( dctData[ _comp2 ], rowBlock[ _comp2 ], blockx * 64 );
                            }
                        } // blockx
                        var _offset2 = 0;
                        for ( var _comp3 = 0; _comp3 < numComp; ++_comp3 ) {
                            var type = channelData[ cscSet.idx[ _comp3 ] ].type;
                            for ( var y = 8 * blocky; y < 8 * blocky + maxY; ++y ) {
                                _offset2 = rowOffsets[ _comp3 ][ y ];
                                for ( var _blockx = 0; _blockx < numFullBlocksX; ++_blockx ) {
                                    var src = _blockx * 64 + ( y & 0x7 ) * 8;
                                    dataView.setUint16( _offset2 + 0 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 0 ], true );
                                    dataView.setUint16( _offset2 + 1 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 1 ], true );
                                    dataView.setUint16( _offset2 + 2 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 2 ], true );
                                    dataView.setUint16( _offset2 + 3 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 3 ], true );
                                    dataView.setUint16( _offset2 + 4 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 4 ], true );
                                    dataView.setUint16( _offset2 + 5 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 5 ], true );
                                    dataView.setUint16( _offset2 + 6 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 6 ], true );
                                    dataView.setUint16( _offset2 + 7 * INT16_SIZE * type, rowBlock[ _comp3 ][ src + 7 ], true );
                                    _offset2 += 8 * INT16_SIZE * type;
                                }
                            } // handle partial X blocks
                            if ( numFullBlocksX != numBlocksX ) {
                                for ( var _y2 = 8 * blocky; _y2 < 8 * blocky + maxY; ++_y2 ) {
                                    var _offset3 = rowOffsets[ _comp3 ][ _y2 ] + 8 * numFullBlocksX * INT16_SIZE * type;
                                    var _src = numFullBlocksX * 64 + ( _y2 & 0x7 ) * 8;
                                    for ( var _x9 = 0; _x9 < maxX; ++_x9 ) {
                                        dataView.setUint16( _offset3 + _x9 * INT16_SIZE * type, rowBlock[ _comp3 ][ _src + _x9 ], true );
                                    }
                                }
                            }
                        } // comp
                    } // blocky
                    var halfRow = new Uint16Array( width );
                    dataView = new DataView( outBuffer.buffer ); // convert channels back to float, if needed
                    for ( var _comp4 = 0; _comp4 < numComp; ++_comp4 ) {
                        channelData[ cscSet.idx[ _comp4 ] ].decoded = true;
                        var _type = channelData[ cscSet.idx[ _comp4 ] ].type;
                        if ( channelData[ _comp4 ].type != 2 ) continue;
                        for ( var _y3 = 0; _y3 < height; ++_y3 ) {
                            var _offset4 = rowOffsets[ _comp4 ][ _y3 ];
                            for ( var _x10 = 0; _x10 < width; ++_x10 ) {
                                halfRow[ _x10 ] = dataView.getUint16( _offset4 + _x10 * INT16_SIZE * _type, true );
                            }
                            for ( var _x11 = 0; _x11 < width; ++_x11 ) {
                                dataView.setFloat32( _offset4 + _x11 * INT16_SIZE * _type, decodeFloat16( halfRow[ _x11 ] ), true );
                            }
                        }
                    }
                }

                function unRleAC( currAcComp, acBuffer, halfZigBlock ) {
                    var acValue;
                    var dctComp = 1;
                    while ( dctComp < 64 ) {
                        acValue = acBuffer[ currAcComp.value ];
                        if ( acValue == 0xff00 ) {
                            dctComp = 64;
                        } else if ( acValue >> 8 == 0xff ) {
                            dctComp += acValue & 0xff;
                        } else {
                            halfZigBlock[ dctComp ] = acValue;
                            dctComp++;
                        }
                        currAcComp.value++;
                    }
                }

                function unZigZag( src, dst ) {
                    dst[ 0 ] = decodeFloat16( src[ 0 ] );
                    dst[ 1 ] = decodeFloat16( src[ 1 ] );
                    dst[ 2 ] = decodeFloat16( src[ 5 ] );
                    dst[ 3 ] = decodeFloat16( src[ 6 ] );
                    dst[ 4 ] = decodeFloat16( src[ 14 ] );
                    dst[ 5 ] = decodeFloat16( src[ 15 ] );
                    dst[ 6 ] = decodeFloat16( src[ 27 ] );
                    dst[ 7 ] = decodeFloat16( src[ 28 ] );
                    dst[ 8 ] = decodeFloat16( src[ 2 ] );
                    dst[ 9 ] = decodeFloat16( src[ 4 ] );
                    dst[ 10 ] = decodeFloat16( src[ 7 ] );
                    dst[ 11 ] = decodeFloat16( src[ 13 ] );
                    dst[ 12 ] = decodeFloat16( src[ 16 ] );
                    dst[ 13 ] = decodeFloat16( src[ 26 ] );
                    dst[ 14 ] = decodeFloat16( src[ 29 ] );
                    dst[ 15 ] = decodeFloat16( src[ 42 ] );
                    dst[ 16 ] = decodeFloat16( src[ 3 ] );
                    dst[ 17 ] = decodeFloat16( src[ 8 ] );
                    dst[ 18 ] = decodeFloat16( src[ 12 ] );
                    dst[ 19 ] = decodeFloat16( src[ 17 ] );
                    dst[ 20 ] = decodeFloat16( src[ 25 ] );
                    dst[ 21 ] = decodeFloat16( src[ 30 ] );
                    dst[ 22 ] = decodeFloat16( src[ 41 ] );
                    dst[ 23 ] = decodeFloat16( src[ 43 ] );
                    dst[ 24 ] = decodeFloat16( src[ 9 ] );
                    dst[ 25 ] = decodeFloat16( src[ 11 ] );
                    dst[ 26 ] = decodeFloat16( src[ 18 ] );
                    dst[ 27 ] = decodeFloat16( src[ 24 ] );
                    dst[ 28 ] = decodeFloat16( src[ 31 ] );
                    dst[ 29 ] = decodeFloat16( src[ 40 ] );
                    dst[ 30 ] = decodeFloat16( src[ 44 ] );
                    dst[ 31 ] = decodeFloat16( src[ 53 ] );
                    dst[ 32 ] = decodeFloat16( src[ 10 ] );
                    dst[ 33 ] = decodeFloat16( src[ 19 ] );
                    dst[ 34 ] = decodeFloat16( src[ 23 ] );
                    dst[ 35 ] = decodeFloat16( src[ 32 ] );
                    dst[ 36 ] = decodeFloat16( src[ 39 ] );
                    dst[ 37 ] = decodeFloat16( src[ 45 ] );
                    dst[ 38 ] = decodeFloat16( src[ 52 ] );
                    dst[ 39 ] = decodeFloat16( src[ 54 ] );
                    dst[ 40 ] = decodeFloat16( src[ 20 ] );
                    dst[ 41 ] = decodeFloat16( src[ 22 ] );
                    dst[ 42 ] = decodeFloat16( src[ 33 ] );
                    dst[ 43 ] = decodeFloat16( src[ 38 ] );
                    dst[ 44 ] = decodeFloat16( src[ 46 ] );
                    dst[ 45 ] = decodeFloat16( src[ 51 ] );
                    dst[ 46 ] = decodeFloat16( src[ 55 ] );
                    dst[ 47 ] = decodeFloat16( src[ 60 ] );
                    dst[ 48 ] = decodeFloat16( src[ 21 ] );
                    dst[ 49 ] = decodeFloat16( src[ 34 ] );
                    dst[ 50 ] = decodeFloat16( src[ 37 ] );
                    dst[ 51 ] = decodeFloat16( src[ 47 ] );
                    dst[ 52 ] = decodeFloat16( src[ 50 ] );
                    dst[ 53 ] = decodeFloat16( src[ 56 ] );
                    dst[ 54 ] = decodeFloat16( src[ 59 ] );
                    dst[ 55 ] = decodeFloat16( src[ 61 ] );
                    dst[ 56 ] = decodeFloat16( src[ 35 ] );
                    dst[ 57 ] = decodeFloat16( src[ 36 ] );
                    dst[ 58 ] = decodeFloat16( src[ 48 ] );
                    dst[ 59 ] = decodeFloat16( src[ 49 ] );
                    dst[ 60 ] = decodeFloat16( src[ 57 ] );
                    dst[ 61 ] = decodeFloat16( src[ 58 ] );
                    dst[ 62 ] = decodeFloat16( src[ 62 ] );
                    dst[ 63 ] = decodeFloat16( src[ 63 ] );
                }

                function dctInverse( data ) {
                    var a = 0.5 * Math.cos( 3.14159 / 4.0 );
                    var b = 0.5 * Math.cos( 3.14159 / 16.0 );
                    var c = 0.5 * Math.cos( 3.14159 / 8.0 );
                    var d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
                    var e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
                    var f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
                    var g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );
                    var alpha = new Array( 4 );
                    var beta = new Array( 4 );
                    var theta = new Array( 4 );
                    var gamma = new Array( 4 );
                    for ( var row = 0; row < 8; ++row ) {
                        var rowPtr = row * 8;
                        alpha[ 0 ] = c * data[ rowPtr + 2 ];
                        alpha[ 1 ] = f * data[ rowPtr + 2 ];
                        alpha[ 2 ] = c * data[ rowPtr + 6 ];
                        alpha[ 3 ] = f * data[ rowPtr + 6 ];
                        beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
                        beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
                        beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
                        beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];
                        theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
                        theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
                        theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
                        theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];
                        gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
                        gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
                        gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
                        gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];
                        data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
                        data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
                        data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
                        data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];
                        data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
                        data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
                        data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
                        data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];
                    }
                    for ( var column = 0; column < 8; ++column ) {
                        alpha[ 0 ] = c * data[ 16 + column ];
                        alpha[ 1 ] = f * data[ 16 + column ];
                        alpha[ 2 ] = c * data[ 48 + column ];
                        alpha[ 3 ] = f * data[ 48 + column ];
                        beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
                        beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
                        beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
                        beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];
                        theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
                        theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );
                        theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
                        theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];
                        gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
                        gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
                        gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
                        gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];
                        data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
                        data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
                        data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
                        data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];
                        data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
                        data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
                        data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
                        data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];
                    }
                }

                function csc709Inverse( data ) {
                    for ( var _i274 = 0; _i274 < 64; ++_i274 ) {
                        var y = data[ 0 ][ _i274 ];
                        var cb = data[ 1 ][ _i274 ];
                        var cr = data[ 2 ][ _i274 ];
                        data[ 0 ][ _i274 ] = y + 1.5747 * cr;
                        data[ 1 ][ _i274 ] = y - 0.1873 * cb - 0.4682 * cr;
                        data[ 2 ][ _i274 ] = y + 1.8556 * cb;
                    }
                }

                function convertToHalf( src, dst, idx ) {
                    for ( var _i275 = 0; _i275 < 64; ++_i275 ) {
                        dst[ idx + _i275 ] = DataUtils.toHalfFloat( toLinear( src[ _i275 ] ) );
                    }
                }

                function toLinear( _float ) {
                    if ( _float <= 1 ) {
                        return Math.sign( _float ) * Math.pow( Math.abs( _float ), 2.2 );
                    } else {
                        return Math.sign( _float ) * Math.pow( logBase, Math.abs( _float ) - 1.0 );
                    }
                }

                function uncompressRAW( info ) {
                    return new DataView( info.array.buffer, info.offset.value, info.size );
                }

                function uncompressRLE( info ) {
                    var compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );
                    var rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
                    var tmpBuffer = new Uint8Array( rawBuffer.length );
                    predictor( rawBuffer ); // revert predictor
                    interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels
                    return new DataView( tmpBuffer.buffer );
                }

                function uncompressZIP( info ) {
                    var compressed = info.array.slice( info.offset.value, info.offset.value + info.size );
                    if ( typeof fflate === 'undefined' ) {
                        console.error( 'THREE.EXRLoader: External library fflate.min.js required.' );
                    }
                    var rawBuffer = unzlibSync( compressed ); // eslint-disable-line no-undef
                    var tmpBuffer = new Uint8Array( rawBuffer.length );
                    predictor( rawBuffer ); // revert predictor
                    interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels
                    return new DataView( tmpBuffer.buffer );
                }

                function uncompressPIZ( info ) {
                    var inDataView = info.viewer;
                    var inOffset = {
                        value: info.offset.value
                    };
                    var outBuffer = new Uint16Array( info.width * info.scanlineBlockSize * ( info.channels * info.type ) );
                    var bitmap = new Uint8Array( BITMAP_SIZE ); // Setup channel info
                    var outBufferEnd = 0;
                    var pizChannelData = new Array( info.channels );
                    for ( var _i276 = 0; _i276 < info.channels; _i276++ ) {
                        pizChannelData[ _i276 ] = {};
                        pizChannelData[ _i276 ][ 'start' ] = outBufferEnd;
                        pizChannelData[ _i276 ][ 'end' ] = pizChannelData[ _i276 ][ 'start' ];
                        pizChannelData[ _i276 ][ 'nx' ] = info.width;
                        pizChannelData[ _i276 ][ 'ny' ] = info.lines;
                        pizChannelData[ _i276 ][ 'size' ] = info.type;
                        outBufferEnd += pizChannelData[ _i276 ].nx * pizChannelData[ _i276 ].ny * pizChannelData[ _i276 ].size;
                    } // Read range compression data
                    var minNonZero = parseUint16( inDataView, inOffset );
                    var maxNonZero = parseUint16( inDataView, inOffset );
                    if ( maxNonZero >= BITMAP_SIZE ) {
                        throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );
                    }
                    if ( minNonZero <= maxNonZero ) {
                        for ( var _i277 = 0; _i277 < maxNonZero - minNonZero + 1; _i277++ ) {
                            bitmap[ _i277 + minNonZero ] = parseUint8( inDataView, inOffset );
                        }
                    } // Reverse LUT
                    var lut = new Uint16Array( USHORT_RANGE );
                    var maxValue = reverseLutFromBitmap( bitmap, lut );
                    var length = parseUint32( inDataView, inOffset ); // Huffman decoding
                    hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd ); // Wavelet decoding
                    for ( var _i278 = 0; _i278 < info.channels; ++_i278 ) {
                        var cd = pizChannelData[ _i278 ];
                        for ( var j = 0; j < pizChannelData[ _i278 ].size; ++j ) {
                            wav2Decode( outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue );
                        }
                    } // Expand the pixel data to their original range
                    applyLut( lut, outBuffer, outBufferEnd ); // Rearrange the pixel data into the format expected by the caller.
                    var tmpOffset = 0;
                    var tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
                    for ( var y = 0; y < info.lines; y++ ) {
                        for ( var _c11 = 0; _c11 < info.channels; _c11++ ) {
                            var _cd = pizChannelData[ _c11 ];
                            var n = _cd.nx * _cd.size;
                            var cp = new Uint8Array( outBuffer.buffer, _cd.end * INT16_SIZE, n * INT16_SIZE );
                            tmpBuffer.set( cp, tmpOffset );
                            tmpOffset += n * INT16_SIZE;
                            _cd.end += n;
                        }
                    }
                    return new DataView( tmpBuffer.buffer );
                }

                function uncompressPXR( info ) {
                    var compressed = info.array.slice( info.offset.value, info.offset.value + info.size );
                    if ( typeof fflate === 'undefined' ) {
                        console.error( 'THREE.EXRLoader: External library fflate.min.js required.' );
                    }
                    var rawBuffer = unzlibSync( compressed ); // eslint-disable-line no-undef
                    var sz = info.lines * info.channels * info.width;
                    var tmpBuffer = info.type == 1 ? new Uint16Array( sz ) : new Uint32Array( sz );
                    var tmpBufferEnd = 0;
                    var writePtr = 0;
                    var ptr = new Array( 4 );
                    for ( var y = 0; y < info.lines; y++ ) {
                        for ( var _c12 = 0; _c12 < info.channels; _c12++ ) {
                            var pixel = 0;
                            switch ( info.type ) {
                                case 1:
                                    ptr[ 0 ] = tmpBufferEnd;
                                    ptr[ 1 ] = ptr[ 0 ] + info.width;
                                    tmpBufferEnd = ptr[ 1 ] + info.width;
                                    for ( var j = 0; j < info.width; ++j ) {
                                        var diff = rawBuffer[ ptr[ 0 ]++ ] << 8 | rawBuffer[ ptr[ 1 ]++ ];
                                        pixel += diff;
                                        tmpBuffer[ writePtr ] = pixel;
                                        writePtr++;
                                    }
                                    break;
                                case 2:
                                    ptr[ 0 ] = tmpBufferEnd;
                                    ptr[ 1 ] = ptr[ 0 ] + info.width;
                                    ptr[ 2 ] = ptr[ 1 ] + info.width;
                                    tmpBufferEnd = ptr[ 2 ] + info.width;
                                    for ( var _j8 = 0; _j8 < info.width; ++_j8 ) {
                                        var _diff2 = rawBuffer[ ptr[ 0 ]++ ] << 24 | rawBuffer[ ptr[ 1 ]++ ] << 16 | rawBuffer[ ptr[ 2 ]++ ] << 8;
                                        pixel += _diff2;
                                        tmpBuffer[ writePtr ] = pixel;
                                        writePtr++;
                                    }
                                    break;
                            }
                        }
                    }
                    return new DataView( tmpBuffer.buffer );
                }

                function uncompressDWA( info ) {
                    var inDataView = info.viewer;
                    var inOffset = {
                        value: info.offset.value
                    };
                    var outBuffer = new Uint8Array( info.width * info.lines * ( info.channels * info.type * INT16_SIZE ) ); // Read compression header information
                    var dwaHeader = {
                        version: parseInt64( inDataView, inOffset ),
                        unknownUncompressedSize: parseInt64( inDataView, inOffset ),
                        unknownCompressedSize: parseInt64( inDataView, inOffset ),
                        acCompressedSize: parseInt64( inDataView, inOffset ),
                        dcCompressedSize: parseInt64( inDataView, inOffset ),
                        rleCompressedSize: parseInt64( inDataView, inOffset ),
                        rleUncompressedSize: parseInt64( inDataView, inOffset ),
                        rleRawSize: parseInt64( inDataView, inOffset ),
                        totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
                        totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
                        acCompression: parseInt64( inDataView, inOffset )
                    };
                    if ( dwaHeader.version < 2 ) throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' ); // Read channel ruleset information
                    var channelRules = new Array( );
                    var ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;
                    while ( ruleSize > 0 ) {
                        var name = parseNullTerminatedString( inDataView.buffer, inOffset );
                        var _value9 = parseUint8( inDataView, inOffset );
                        var compression = _value9 >> 2 & 3;
                        var csc = ( _value9 >> 4 ) - 1;
                        var index = new Int8Array( [ csc ] )[ 0 ];
                        var type = parseUint8( inDataView, inOffset );
                        channelRules.push( {
                            name: name,
                            index: index,
                            type: type,
                            compression: compression
                        } );
                        ruleSize -= name.length + 3;
                    } // Classify channels
                    var channels = EXRHeader.channels;
                    var channelData = new Array( info.channels );
                    for ( var _i279 = 0; _i279 < info.channels; ++_i279 ) {
                        var cd = channelData[ _i279 ] = {};
                        var channel = channels[ _i279 ];
                        cd.name = channel.name;
                        cd.compression = UNKNOWN;
                        cd.decoded = false;
                        cd.type = channel.pixelType;
                        cd.pLinear = channel.pLinear;
                        cd.width = info.width;
                        cd.height = info.lines;
                    }
                    var cscSet = {
                        idx: new Array( 3 )
                    };
                    for ( var _offset5 = 0; _offset5 < info.channels; ++_offset5 ) {
                        var _cd2 = channelData[ _offset5 ];
                        for ( var _i280 = 0; _i280 < channelRules.length; ++_i280 ) {
                            var rule = channelRules[ _i280 ];
                            if ( _cd2.name == rule.name ) {
                                _cd2.compression = rule.compression;
                                if ( rule.index >= 0 ) {
                                    cscSet.idx[ rule.index ] = _offset5;
                                }
                                _cd2.offset = _offset5;
                            }
                        }
                    }
                    var acBuffer, dcBuffer, rleBuffer; // Read DCT - AC component data
                    if ( dwaHeader.acCompressedSize > 0 ) {
                        switch ( dwaHeader.acCompression ) {
                            case STATIC_HUFFMAN:
                                acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
                                hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
                                break;
                            case DEFLATE:
                                var compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
                                var data = unzlibSync( compressed ); // eslint-disable-line no-undef
                                acBuffer = new Uint16Array( data.buffer );
                                inOffset.value += dwaHeader.totalAcUncompressedCount;
                                break;
                        }
                    } // Read DCT - DC component data
                    if ( dwaHeader.dcCompressedSize > 0 ) {
                        var zlibInfo = {
                            array: info.array,
                            offset: inOffset,
                            size: dwaHeader.dcCompressedSize
                        };
                        dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
                        inOffset.value += dwaHeader.dcCompressedSize;
                    } // Read RLE compressed data
                    if ( dwaHeader.rleRawSize > 0 ) {
                        var _compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
                        var _data3 = unzlibSync( _compressed ); // eslint-disable-line no-undef
                        rleBuffer = decodeRunLength( _data3.buffer );
                        inOffset.value += dwaHeader.rleCompressedSize;
                    } // Prepare outbuffer data offset
                    var outBufferEnd = 0;
                    var rowOffsets = new Array( channelData.length );
                    for ( var _i281 = 0; _i281 < rowOffsets.length; ++_i281 ) {
                        rowOffsets[ _i281 ] = new Array( );
                    }
                    for ( var y = 0; y < info.lines; ++y ) {
                        for ( var chan = 0; chan < channelData.length; ++chan ) {
                            rowOffsets[ chan ].push( outBufferEnd );
                            outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;
                        }
                    } // Lossy DCT decode RGB channels
                    lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer ); // Decode other channels
                    for ( var _i282 = 0; _i282 < channelData.length; ++_i282 ) {
                        var _cd3 = channelData[ _i282 ];
                        if ( _cd3.decoded ) continue;
                        switch ( _cd3.compression ) {
                            case RLE:
                                var row = 0;
                                var rleOffset = 0;
                                for ( var _y4 = 0; _y4 < info.lines; ++_y4 ) {
                                    var rowOffsetBytes = rowOffsets[ _i282 ][ row ];
                                    for ( var _x12 = 0; _x12 < _cd3.width; ++_x12 ) {
                                        for ( var _byte = 0; _byte < INT16_SIZE * _cd3.type; ++_byte ) {
                                            outBuffer[ rowOffsetBytes++ ] = rleBuffer[ rleOffset + _byte * _cd3.width * _cd3.height ];
                                        }
                                        rleOffset++;
                                    }
                                    row++;
                                }
                                break;
                            case LOSSY_DCT: // skip
                            default:
                                throw new Error( 'EXRLoader.parse: unsupported channel compression' );
                        }
                    }
                    return new DataView( outBuffer.buffer );
                }

                function parseNullTerminatedString( buffer, offset ) {
                    var uintBuffer = new Uint8Array( buffer );
                    var endOffset = 0;
                    while ( uintBuffer[ offset.value + endOffset ] != 0 ) {
                        endOffset += 1;
                    }
                    var stringValue = new TextDecoder( ).decode( uintBuffer.slice( offset.value, offset.value + endOffset ) );
                    offset.value = offset.value + endOffset + 1;
                    return stringValue;
                }

                function parseFixedLengthString( buffer, offset, size ) {
                    var stringValue = new TextDecoder( ).decode( new Uint8Array( buffer ).slice( offset.value, offset.value + size ) );
                    offset.value = offset.value + size;
                    return stringValue;
                }

                function parseRational( dataView, offset ) {
                    var x = parseInt32( dataView, offset );
                    var y = parseUint32( dataView, offset );
                    return [ x, y ];
                }

                function parseTimecode( dataView, offset ) {
                    var x = parseUint32( dataView, offset );
                    var y = parseUint32( dataView, offset );
                    return [ x, y ];
                }

                function parseInt32( dataView, offset ) {
                    var Int32 = dataView.getInt32( offset.value, true );
                    offset.value = offset.value + INT32_SIZE;
                    return Int32;
                }

                function parseUint32( dataView, offset ) {
                    var Uint32 = dataView.getUint32( offset.value, true );
                    offset.value = offset.value + INT32_SIZE;
                    return Uint32;
                }

                function parseUint8Array( uInt8Array, offset ) {
                    var Uint8 = uInt8Array[ offset.value ];
                    offset.value = offset.value + INT8_SIZE;
                    return Uint8;
                }

                function parseUint8( dataView, offset ) {
                    var Uint8 = dataView.getUint8( offset.value );
                    offset.value = offset.value + INT8_SIZE;
                    return Uint8;
                }
                var parseInt64 = function parseInt64( dataView, offset ) {
                    var Int64 = Number( dataView.getBigInt64( offset.value, true ) );
                    offset.value += ULONG_SIZE;
                    return Int64;
                };

                function parseFloat32( dataView, offset ) {
                    var _float2 = dataView.getFloat32( offset.value, true );
                    offset.value += FLOAT32_SIZE;
                    return _float2;
                }

                function decodeFloat32( dataView, offset ) {
                    return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );
                } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
                function decodeFloat16( binary ) {
                    var exponent = ( binary & 0x7C00 ) >> 10,
                        fraction = binary & 0x03FF;
                    return ( binary >> 15 ? -1 : 1 ) * ( exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 ) : 6.103515625e-5 * ( fraction / 0x400 ) );
                }

                function parseUint16( dataView, offset ) {
                    var Uint16 = dataView.getUint16( offset.value, true );
                    offset.value += INT16_SIZE;
                    return Uint16;
                }

                function parseFloat16( buffer, offset ) {
                    return decodeFloat16( parseUint16( buffer, offset ) );
                }

                function parseChlist( dataView, buffer, offset, size ) {
                    var startOffset = offset.value;
                    var channels = [ ];
                    while ( offset.value < startOffset + size - 1 ) {
                        var name = parseNullTerminatedString( buffer, offset );
                        var pixelType = parseInt32( dataView, offset );
                        var pLinear = parseUint8( dataView, offset );
                        offset.value += 3; // reserved, three chars
                        var xSampling = parseInt32( dataView, offset );
                        var ySampling = parseInt32( dataView, offset );
                        channels.push( {
                            name: name,
                            pixelType: pixelType,
                            pLinear: pLinear,
                            xSampling: xSampling,
                            ySampling: ySampling
                        } );
                    }
                    offset.value += 1;
                    return channels;
                }

                function parseChromaticities( dataView, offset ) {
                    var redX = parseFloat32( dataView, offset );
                    var redY = parseFloat32( dataView, offset );
                    var greenX = parseFloat32( dataView, offset );
                    var greenY = parseFloat32( dataView, offset );
                    var blueX = parseFloat32( dataView, offset );
                    var blueY = parseFloat32( dataView, offset );
                    var whiteX = parseFloat32( dataView, offset );
                    var whiteY = parseFloat32( dataView, offset );
                    return {
                        redX: redX,
                        redY: redY,
                        greenX: greenX,
                        greenY: greenY,
                        blueX: blueX,
                        blueY: blueY,
                        whiteX: whiteX,
                        whiteY: whiteY
                    };
                }

                function parseCompression( dataView, offset ) {
                    var compressionCodes = [ 'NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION' ];
                    var compression = parseUint8( dataView, offset );
                    return compressionCodes[ compression ];
                }

                function parseBox2i( dataView, offset ) {
                    var xMin = parseUint32( dataView, offset );
                    var yMin = parseUint32( dataView, offset );
                    var xMax = parseUint32( dataView, offset );
                    var yMax = parseUint32( dataView, offset );
                    return {
                        xMin: xMin,
                        yMin: yMin,
                        xMax: xMax,
                        yMax: yMax
                    };
                }

                function parseLineOrder( dataView, offset ) {
                    var lineOrders = [ 'INCREASING_Y' ];
                    var lineOrder = parseUint8( dataView, offset );
                    return lineOrders[ lineOrder ];
                }

                function parseV2f( dataView, offset ) {
                    var x = parseFloat32( dataView, offset );
                    var y = parseFloat32( dataView, offset );
                    return [ x, y ];
                }

                function parseV3f( dataView, offset ) {
                    var x = parseFloat32( dataView, offset );
                    var y = parseFloat32( dataView, offset );
                    var z = parseFloat32( dataView, offset );
                    return [ x, y, z ];
                }

                function parseValue( dataView, buffer, offset, type, size ) {
                    if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {
                        return parseFixedLengthString( buffer, offset, size );
                    } else if ( type === 'chlist' ) {
                        return parseChlist( dataView, buffer, offset, size );
                    } else if ( type === 'chromaticities' ) {
                        return parseChromaticities( dataView, offset );
                    } else if ( type === 'compression' ) {
                        return parseCompression( dataView, offset );
                    } else if ( type === 'box2i' ) {
                        return parseBox2i( dataView, offset );
                    } else if ( type === 'lineOrder' ) {
                        return parseLineOrder( dataView, offset );
                    } else if ( type === 'float' ) {
                        return parseFloat32( dataView, offset );
                    } else if ( type === 'v2f' ) {
                        return parseV2f( dataView, offset );
                    } else if ( type === 'v3f' ) {
                        return parseV3f( dataView, offset );
                    } else if ( type === 'int' ) {
                        return parseInt32( dataView, offset );
                    } else if ( type === 'rational' ) {
                        return parseRational( dataView, offset );
                    } else if ( type === 'timecode' ) {
                        return parseTimecode( dataView, offset );
                    } else if ( type === 'preview' ) {
                        offset.value += size;
                        return 'skipped';
                    } else {
                        offset.value += size;
                        return undefined;
                    }
                }

                function parseHeader( dataView, buffer, offset ) {
                    var EXRHeader = {};
                    if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic
                        throw new Error( 'THREE.EXRLoader: provided file doesn\'t appear to be in OpenEXR format.' );
                    }
                    EXRHeader.version = dataView.getUint8( 4 );
                    var spec = dataView.getUint8( 5 ); // fullMask
                    EXRHeader.spec = {
                        singleTile: !!( spec & 2 ),
                        longName: !!( spec & 4 ),
                        deepFormat: !!( spec & 8 ),
                        multiPart: !!( spec & 16 )
                    }; // start of header
                    offset.value = 8; // start at 8 - after pre-amble
                    var keepReading = true;
                    while ( keepReading ) {
                        var attributeName = parseNullTerminatedString( buffer, offset );
                        if ( attributeName == 0 ) {
                            keepReading = false;
                        } else {
                            var attributeType = parseNullTerminatedString( buffer, offset );
                            var attributeSize = parseUint32( dataView, offset );
                            var attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );
                            if ( attributeValue === undefined ) {
                                console.warn( "EXRLoader.parse: skipped unknown header attribute type '".concat( attributeType, "'." ) );
                            } else {
                                EXRHeader[ attributeName ] = attributeValue;
                            }
                        }
                    }
                    if ( ( spec & ~0x04 ) != 0 ) { // unsupported tiled, deep-image, multi-part
                        console.error( 'EXRHeader:', EXRHeader );
                        throw new Error( 'THREE.EXRLoader: provided file is currently unsupported.' );
                    }
                    return EXRHeader;
                }

                function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {
                    var EXRDecoder = {
                        size: 0,
                        viewer: dataView,
                        array: uInt8Array,
                        offset: offset,
                        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
                        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
                        channels: EXRHeader.channels.length,
                        bytesPerLine: null,
                        lines: null,
                        inputSize: null,
                        type: EXRHeader.channels[ 0 ].pixelType,
                        uncompress: null,
                        getter: null,
                        format: null,
                        encoding: null
                    };
                    switch ( EXRHeader.compression ) {
                        case 'NO_COMPRESSION':
                            EXRDecoder.lines = 1;
                            EXRDecoder.uncompress = uncompressRAW;
                            break;
                        case 'RLE_COMPRESSION':
                            EXRDecoder.lines = 1;
                            EXRDecoder.uncompress = uncompressRLE;
                            break;
                        case 'ZIPS_COMPRESSION':
                            EXRDecoder.lines = 1;
                            EXRDecoder.uncompress = uncompressZIP;
                            break;
                        case 'ZIP_COMPRESSION':
                            EXRDecoder.lines = 16;
                            EXRDecoder.uncompress = uncompressZIP;
                            break;
                        case 'PIZ_COMPRESSION':
                            EXRDecoder.lines = 32;
                            EXRDecoder.uncompress = uncompressPIZ;
                            break;
                        case 'PXR24_COMPRESSION':
                            EXRDecoder.lines = 16;
                            EXRDecoder.uncompress = uncompressPXR;
                            break;
                        case 'DWAA_COMPRESSION':
                            EXRDecoder.lines = 32;
                            EXRDecoder.uncompress = uncompressDWA;
                            break;
                        case 'DWAB_COMPRESSION':
                            EXRDecoder.lines = 256;
                            EXRDecoder.uncompress = uncompressDWA;
                            break;
                        default:
                            throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );
                    }
                    EXRDecoder.scanlineBlockSize = EXRDecoder.lines;
                    if ( EXRDecoder.type == 1 ) { // half
                        switch ( outputType ) {
                            case FloatType:
                                EXRDecoder.getter = parseFloat16;
                                EXRDecoder.inputSize = INT16_SIZE;
                                break;
                            case HalfFloatType:
                                EXRDecoder.getter = parseUint16;
                                EXRDecoder.inputSize = INT16_SIZE;
                                break;
                        }
                    } else if ( EXRDecoder.type == 2 ) { // float
                        switch ( outputType ) {
                            case FloatType:
                                EXRDecoder.getter = parseFloat32;
                                EXRDecoder.inputSize = FLOAT32_SIZE;
                                break;
                            case HalfFloatType:
                                EXRDecoder.getter = decodeFloat32;
                                EXRDecoder.inputSize = FLOAT32_SIZE;
                        }
                    } else {
                        throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );
                    }
                    EXRDecoder.blockCount = ( EXRHeader.dataWindow.yMax + 1 ) / EXRDecoder.scanlineBlockSize;
                    for ( var _i283 = 0; _i283 < EXRDecoder.blockCount; _i283++ ) {
                        parseInt64( dataView, offset );
                    } // scanlineOffset
                    // we should be passed the scanline offset table, ready to start reading pixel data.
                    // RGB images will be converted to RGBA format, preventing software emulation in select devices.
                    EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;
                    var size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;
                    switch ( outputType ) {
                        case FloatType:
                            EXRDecoder.byteArray = new Float32Array( size ); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
                            if ( EXRDecoder.channels < EXRDecoder.outputChannels ) EXRDecoder.byteArray.fill( 1, 0, size );
                            break;
                        case HalfFloatType:
                            EXRDecoder.byteArray = new Uint16Array( size );
                            if ( EXRDecoder.channels < EXRDecoder.outputChannels ) EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1
                            break;
                        default:
                            console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
                            break;
                    }
                    EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;
                    if ( EXRDecoder.outputChannels == 4 ) {
                        EXRDecoder.format = RGBAFormat;
                        EXRDecoder.encoding = LinearEncoding;
                    } else {
                        EXRDecoder.format = RedFormat;
                        EXRDecoder.encoding = LinearEncoding;
                    }
                    return EXRDecoder;
                } // start parsing file [START]
                var bufferDataView = new DataView( buffer );
                var uInt8Array = new Uint8Array( buffer );
                var offset = {
                    value: 0
                }; // get header information and validate format.
                var EXRHeader = parseHeader( bufferDataView, buffer, offset ); // get input compression information and prepare decoding.
                var EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );
                var tmpOffset = {
                    value: 0
                };
                var channelOffsets = {
                    R: 0,
                    G: 1,
                    B: 2,
                    A: 3,
                    Y: 0
                };
                for ( var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++ ) {
                    var line = parseUint32( bufferDataView, offset ); // line_no
                    EXRDecoder.size = parseUint32( bufferDataView, offset ); // data_len
                    EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;
                    var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
                    var viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );
                    offset.value += EXRDecoder.size;
                    for ( var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++ ) {
                        var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
                        if ( true_y >= EXRDecoder.height ) break;
                        for ( var channelID = 0; channelID < EXRDecoder.channels; channelID++ ) {
                            var cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];
                            for ( var _x13 = 0; _x13 < EXRDecoder.width; _x13++ ) {
                                tmpOffset.value = ( line_y * ( EXRDecoder.channels * EXRDecoder.width ) + channelID * EXRDecoder.width + _x13 ) * EXRDecoder.inputSize;
                                var outIndex = ( EXRDecoder.height - 1 - true_y ) * ( EXRDecoder.width * EXRDecoder.outputChannels ) + _x13 * EXRDecoder.outputChannels + cOff;
                                EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );
                            }
                        }
                    }
                }
                return {
                    header: EXRHeader,
                    width: EXRDecoder.width,
                    height: EXRDecoder.height,
                    data: EXRDecoder.byteArray,
                    format: EXRDecoder.format,
                    encoding: EXRDecoder.encoding,
                    type: this.type
                };
            }
        }, {
            key: "setDataType",
            value: function setDataType( value ) {
                this.type = value;
                return this;
            }
        }, {
            key: "load",
            value: function load( url, onLoad, onProgress, onError ) {
                function onLoadCallback( texture, texData ) {
                    texture.encoding = texData.encoding;
                    texture.minFilter = LinearFilter;
                    texture.magFilter = LinearFilter;
                    texture.generateMipmaps = false;
                    texture.flipY = false;
                    if ( onLoad ) onLoad( texture, texData );
                }
                return _get( _getPrototypeOf( EXRLoader.prototype ), "load", this ).call( this, url, onLoadCallback, onProgress, onError );
            }
        } ] );
        return EXRLoader;
    }( DataTextureLoader );
    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    var Easing = {
        Linear: {
            None: function None( amount ) {
                return amount;
            }
        },
        Quadratic: {
            In: function In( amount ) {
                return amount * amount;
            },
            Out: function Out( amount ) {
                return amount * ( 2 - amount );
            },
            InOut: function InOut( amount ) {
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * amount * amount;
                }
                return -0.5 * ( --amount * ( amount - 2 ) - 1 );
            }
        },
        Cubic: {
            In: function In( amount ) {
                return amount * amount * amount;
            },
            Out: function Out( amount ) {
                return --amount * amount * amount + 1;
            },
            InOut: function InOut( amount ) {
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * amount * amount * amount;
                }
                return 0.5 * ( ( amount -= 2 ) * amount * amount + 2 );
            }
        },
        Quartic: {
            In: function In( amount ) {
                return amount * amount * amount * amount;
            },
            Out: function Out( amount ) {
                return 1 - --amount * amount * amount * amount;
            },
            InOut: function InOut( amount ) {
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * amount * amount * amount * amount;
                }
                return -0.5 * ( ( amount -= 2 ) * amount * amount * amount - 2 );
            }
        },
        Quintic: {
            In: function In( amount ) {
                return amount * amount * amount * amount * amount;
            },
            Out: function Out( amount ) {
                return --amount * amount * amount * amount * amount + 1;
            },
            InOut: function InOut( amount ) {
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * amount * amount * amount * amount * amount;
                }
                return 0.5 * ( ( amount -= 2 ) * amount * amount * amount * amount + 2 );
            }
        },
        Sinusoidal: {
            In: function In( amount ) {
                return 1 - Math.cos( amount * Math.PI / 2 );
            },
            Out: function Out( amount ) {
                return Math.sin( amount * Math.PI / 2 );
            },
            InOut: function InOut( amount ) {
                return 0.5 * ( 1 - Math.cos( Math.PI * amount ) );
            }
        },
        Exponential: {
            In: function In( amount ) {
                return amount === 0 ? 0 : Math.pow( 1024, amount - 1 );
            },
            Out: function Out( amount ) {
                return amount === 1 ? 1 : 1 - Math.pow( 2, -10 * amount );
            },
            InOut: function InOut( amount ) {
                if ( amount === 0 ) {
                    return 0;
                }
                if ( amount === 1 ) {
                    return 1;
                }
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * Math.pow( 1024, amount - 1 );
                }
                return 0.5 * ( -Math.pow( 2, -10 * ( amount - 1 ) ) + 2 );
            }
        },
        Circular: {
            In: function In( amount ) {
                return 1 - Math.sqrt( 1 - amount * amount );
            },
            Out: function Out( amount ) {
                return Math.sqrt( 1 - --amount * amount );
            },
            InOut: function InOut( amount ) {
                if ( ( amount *= 2 ) < 1 ) {
                    return -0.5 * ( Math.sqrt( 1 - amount * amount ) - 1 );
                }
                return 0.5 * ( Math.sqrt( 1 - ( amount -= 2 ) * amount ) + 1 );
            }
        },
        Elastic: {
            In: function In( amount ) {
                if ( amount === 0 ) {
                    return 0;
                }
                if ( amount === 1 ) {
                    return 1;
                }
                return -Math.pow( 2, 10 * ( amount - 1 ) ) * Math.sin( ( amount - 1.1 ) * 5 * Math.PI );
            },
            Out: function Out( amount ) {
                if ( amount === 0 ) {
                    return 0;
                }
                if ( amount === 1 ) {
                    return 1;
                }
                return Math.pow( 2, -10 * amount ) * Math.sin( ( amount - 0.1 ) * 5 * Math.PI ) + 1;
            },
            InOut: function InOut( amount ) {
                if ( amount === 0 ) {
                    return 0;
                }
                if ( amount === 1 ) {
                    return 1;
                }
                amount *= 2;
                if ( amount < 1 ) {
                    return -0.5 * Math.pow( 2, 10 * ( amount - 1 ) ) * Math.sin( ( amount - 1.1 ) * 5 * Math.PI );
                }
                return 0.5 * Math.pow( 2, -10 * ( amount - 1 ) ) * Math.sin( ( amount - 1.1 ) * 5 * Math.PI ) + 1;
            }
        },
        Back: {
            In: function In( amount ) {
                var s = 1.70158;
                return amount * amount * ( ( s + 1 ) * amount - s );
            },
            Out: function Out( amount ) {
                var s = 1.70158;
                return --amount * amount * ( ( s + 1 ) * amount + s ) + 1;
            },
            InOut: function InOut( amount ) {
                var s = 1.70158 * 1.525;
                if ( ( amount *= 2 ) < 1 ) {
                    return 0.5 * ( amount * amount * ( ( s + 1 ) * amount - s ) );
                }
                return 0.5 * ( ( amount -= 2 ) * amount * ( ( s + 1 ) * amount + s ) + 2 );
            }
        },
        Bounce: {
            In: function In( amount ) {
                return 1 - Easing.Bounce.Out( 1 - amount );
            },
            Out: function Out( amount ) {
                if ( amount < 1 / 2.75 ) {
                    return 7.5625 * amount * amount;
                } else if ( amount < 2 / 2.75 ) {
                    return 7.5625 * ( amount -= 1.5 / 2.75 ) * amount + 0.75;
                } else if ( amount < 2.5 / 2.75 ) {
                    return 7.5625 * ( amount -= 2.25 / 2.75 ) * amount + 0.9375;
                } else {
                    return 7.5625 * ( amount -= 2.625 / 2.75 ) * amount + 0.984375;
                }
            },
            InOut: function InOut( amount ) {
                if ( amount < 0.5 ) {
                    return Easing.Bounce.In( amount * 2 ) * 0.5;
                }
                return Easing.Bounce.Out( amount * 2 - 1 ) * 0.5 + 0.5;
            }
        }
    };
    var now; // Include a performance.now polyfill.
    // In node.js, use process.hrtime.
    // eslint-disable-next-line
    // @ts-ignore
    if ( typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime ) {
        now = function now( ) { // eslint-disable-next-line
            // @ts-ignore
            var time = process.hrtime( ); // Convert [seconds, nanoseconds] to milliseconds.
            return time[ 0 ] * 1000 + time[ 1 ] / 1000000;
        };
    } // In a browser, use self.performance.now if it is available.
    else if ( typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined ) { // This must be bound, because directly assigning this function
        // leads to an invocation exception in Chrome.
        now = self.performance.now.bind( self.performance );
    } // Use Date.now if it is available.
    else if ( Date.now !== undefined ) {
        now = Date.now;
    } // Otherwise, use 'new Date().getTime()'.
    else {
        now = function now( ) {
            return new Date( ).getTime( );
        };
    }
    var now$1 = now;
    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tween
     */
    var Group = /** @class */ function( ) {
        function Group( ) {
            this._tweens = {};
            this._tweensAddedDuringUpdate = {};
        }
        Group.prototype.getAll = function( ) {
            var _this = this;
            return Object.keys( this._tweens ).map( function( tweenId ) {
                return _this._tweens[ tweenId ];
            } );
        };
        Group.prototype.removeAll = function( ) {
            this._tweens = {};
        };
        Group.prototype.add = function( tween ) {
            this._tweens[ tween.getId( ) ] = tween;
            this._tweensAddedDuringUpdate[ tween.getId( ) ] = tween;
        };
        Group.prototype.remove = function( tween ) {
            delete this._tweens[ tween.getId( ) ];
            delete this._tweensAddedDuringUpdate[ tween.getId( ) ];
        };
        Group.prototype.update = function( time, preserve ) {
            if ( time === void 0 ) {
                time = now$1( );
            }
            if ( preserve === void 0 ) {
                preserve = false;
            }
            var tweenIds = Object.keys( this._tweens );
            if ( tweenIds.length === 0 ) {
                return false;
            } // Tweens are updated in "batches". If you add a new tween during an
            // update, then the new tween will be updated in the next batch.
            // If you remove a tween during an update, it may or may not be updated.
            // However, if the removed tween was added during the current batch,
            // then it will not be updated.
            while ( tweenIds.length > 0 ) {
                this._tweensAddedDuringUpdate = {};
                for ( var i = 0; i < tweenIds.length; i++ ) {
                    var tween = this._tweens[ tweenIds[ i ] ];
                    var autoStart = !preserve;
                    if ( tween && tween.update( time, autoStart ) === false && !preserve ) {
                        delete this._tweens[ tweenIds[ i ] ];
                    }
                }
                tweenIds = Object.keys( this._tweensAddedDuringUpdate );
            }
            return true;
        };
        return Group;
    }( );
    /**
     *
     */
    var Interpolation = {
        Linear: function Linear( v, k ) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor( f );
            var fn = Interpolation.Utils.Linear;
            if ( k < 0 ) {
                return fn( v[ 0 ], v[ 1 ], f );
            }
            if ( k > 1 ) {
                return fn( v[ m ], v[ m - 1 ], m - f );
            }
            return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );
        },
        Bezier: function Bezier( v, k ) {
            var b = 0;
            var n = v.length - 1;
            var pw = Math.pow;
            var bn = Interpolation.Utils.Bernstein;
            for ( var i = 0; i <= n; i++ ) {
                b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
            }
            return b;
        },
        CatmullRom: function CatmullRom( v, k ) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor( f );
            var fn = Interpolation.Utils.CatmullRom;
            if ( v[ 0 ] === v[ m ] ) {
                if ( k < 0 ) {
                    i = Math.floor( f = m * ( 1 + k ) );
                }
                return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );
            } else {
                if ( k < 0 ) {
                    return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
                }
                if ( k > 1 ) {
                    return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );
                }
                return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );
            }
        },
        Utils: {
            Linear: function Linear( p0, p1, t ) {
                return ( p1 - p0 ) * t + p0;
            },
            Bernstein: function Bernstein( n, i ) {
                var fc = Interpolation.Utils.Factorial;
                return fc( n ) / fc( i ) / fc( n - i );
            },
            Factorial: function( ) {
                var a = [ 1 ];
                return function( n ) {
                    var s = 1;
                    if ( a[ n ] ) {
                        return a[ n ];
                    }
                    for ( var i = n; i > 1; i-- ) {
                        s *= i;
                    }
                    a[ n ] = s;
                    return s;
                };
            }( ),
            CatmullRom: function CatmullRom( p0, p1, p2, p3, t ) {
                var v0 = ( p2 - p0 ) * 0.5;
                var v1 = ( p3 - p1 ) * 0.5;
                var t2 = t * t;
                var t3 = t * t2;
                return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
            }
        }
    };
    /**
     * Utils
     */
    var Sequence = /** @class */ function( ) {
        function Sequence( ) {}
        Sequence.nextId = function( ) {
            return Sequence._nextId++;
        };
        Sequence._nextId = 0;
        return Sequence;
    }( );
    var mainGroup = new Group( );
    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var Tween = /** @class */ function( ) {
        function Tween( _object, _group ) {
            if ( _group === void 0 ) {
                _group = mainGroup;
            }
            this._object = _object;
            this._group = _group;
            this._isPaused = false;
            this._pauseStart = 0;
            this._valuesStart = {};
            this._valuesEnd = {};
            this._valuesStartRepeat = {};
            this._duration = 1000;
            this._initialRepeat = 0;
            this._repeat = 0;
            this._yoyo = false;
            this._isPlaying = false;
            this._reversed = false;
            this._delayTime = 0;
            this._startTime = 0;
            this._easingFunction = Easing.Linear.None;
            this._interpolationFunction = Interpolation.Linear;
            this._chainedTweens = [ ];
            this._onStartCallbackFired = false;
            this._id = Sequence.nextId( );
            this._isChainStopped = false;
            this._goToEnd = false;
        }
        Tween.prototype.getId = function( ) {
            return this._id;
        };
        Tween.prototype.isPlaying = function( ) {
            return this._isPlaying;
        };
        Tween.prototype.isPaused = function( ) {
            return this._isPaused;
        };
        Tween.prototype.to = function( properties, duration ) { // TODO? restore this, then update the 07_dynamic_to example to set fox
            // tween's to on each update. That way the behavior is opt-in (there's
            // currently no opt-out).
            // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
            this._valuesEnd = Object.create( properties );
            if ( duration !== undefined ) {
                this._duration = duration;
            }
            return this;
        };
        Tween.prototype.duration = function( d ) {
            this._duration = d;
            return this;
        };
        Tween.prototype.start = function( time ) {
            if ( this._isPlaying ) {
                return this;
            } // eslint-disable-next-line
            this._group && this._group.add( this );
            this._repeat = this._initialRepeat;
            if ( this._reversed ) { // If we were reversed (f.e. using the yoyo feature) then we need to
                // flip the tween direction back to forward.
                this._reversed = false;
                for ( var property in this._valuesStartRepeat ) {
                    this._swapEndStartRepeatValues( property );
                    this._valuesStart[ property ] = this._valuesStartRepeat[ property ];
                }
            }
            this._isPlaying = true;
            this._isPaused = false;
            this._onStartCallbackFired = false;
            this._isChainStopped = false;
            this._startTime = time !== undefined ? typeof time === 'string' ? now$1( ) + parseFloat( time ) : time : now$1( );
            this._startTime += this._delayTime;
            this._setupProperties( this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat );
            return this;
        };
        Tween.prototype._setupProperties = function( _object, _valuesStart, _valuesEnd, _valuesStartRepeat ) {
            for ( var property in _valuesEnd ) {
                var startValue = _object[ property ];
                var startValueIsArray = Array.isArray( startValue );
                var propType = startValueIsArray ? 'array' : _typeof( startValue );
                var isInterpolationList = !startValueIsArray && Array.isArray( _valuesEnd[ property ] ); // If `to()` specifies a property that doesn't exist in the source object,
                // we should not set that property in the object
                if ( propType === 'undefined' || propType === 'function' ) {
                    continue;
                } // Check if an Array was provided as property value
                if ( isInterpolationList ) {
                    var endValues = _valuesEnd[ property ];
                    if ( endValues.length === 0 ) {
                        continue;
                    } // handle an array of relative values
                    endValues = endValues.map( this._handleRelativeValue.bind( this, startValue ) ); // Create a local copy of the Array with the start value at the front
                    _valuesEnd[ property ] = [ startValue ].concat( endValues );
                } // handle the deepness of the values
                if ( ( propType === 'object' || startValueIsArray ) && startValue && !isInterpolationList ) {
                    _valuesStart[ property ] = startValueIsArray ? [ ] : {}; // eslint-disable-next-line
                    for ( var prop in startValue ) { // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[ property ][ prop ] = startValue[ prop ];
                    }
                    _valuesStartRepeat[ property ] = startValueIsArray ? [ ] : {}; // TODO? repeat nested values? And yoyo? And array values?
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._setupProperties( startValue, _valuesStart[ property ], _valuesEnd[ property ], _valuesStartRepeat[ property ] );
                } else { // Save the starting value, but only once.
                    if ( typeof _valuesStart[ property ] === 'undefined' ) {
                        _valuesStart[ property ] = startValue;
                    }
                    if ( !startValueIsArray ) { // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
                    }
                    if ( isInterpolationList ) { // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStartRepeat[ property ] = _valuesEnd[ property ].slice( ).reverse( );
                    } else {
                        _valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;
                    }
                }
            }
        };
        Tween.prototype.stop = function( ) {
            if ( !this._isChainStopped ) {
                this._isChainStopped = true;
                this.stopChainedTweens( );
            }
            if ( !this._isPlaying ) {
                return this;
            } // eslint-disable-next-line
            this._group && this._group.remove( this );
            this._isPlaying = false;
            this._isPaused = false;
            if ( this._onStopCallback ) {
                this._onStopCallback( this._object );
            }
            return this;
        };
        Tween.prototype.end = function( ) {
            this._goToEnd = true;
            this.update( Infinity );
            return this;
        };
        Tween.prototype.pause = function( time ) {
            if ( time === void 0 ) {
                time = now$1( );
            }
            if ( this._isPaused || !this._isPlaying ) {
                return this;
            }
            this._isPaused = true;
            this._pauseStart = time; // eslint-disable-next-line
            this._group && this._group.remove( this );
            return this;
        };
        Tween.prototype.resume = function( time ) {
            if ( time === void 0 ) {
                time = now$1( );
            }
            if ( !this._isPaused || !this._isPlaying ) {
                return this;
            }
            this._isPaused = false;
            this._startTime += time - this._pauseStart;
            this._pauseStart = 0; // eslint-disable-next-line
            this._group && this._group.add( this );
            return this;
        };
        Tween.prototype.stopChainedTweens = function( ) {
            for ( var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++ ) {
                this._chainedTweens[ i ].stop( );
            }
            return this;
        };
        Tween.prototype.group = function( group ) {
            this._group = group;
            return this;
        };
        Tween.prototype.delay = function( amount ) {
            this._delayTime = amount;
            return this;
        };
        Tween.prototype.repeat = function( times ) {
            this._initialRepeat = times;
            this._repeat = times;
            return this;
        };
        Tween.prototype.repeatDelay = function( amount ) {
            this._repeatDelayTime = amount;
            return this;
        };
        Tween.prototype.yoyo = function( yoyo ) {
            this._yoyo = yoyo;
            return this;
        };
        Tween.prototype.easing = function( easingFunction ) {
            this._easingFunction = easingFunction;
            return this;
        };
        Tween.prototype.interpolation = function( interpolationFunction ) {
            this._interpolationFunction = interpolationFunction;
            return this;
        };
        Tween.prototype.chain = function( ) {
            var tweens = [ ];
            for ( var _i = 0; _i < arguments.length; _i++ ) {
                tweens[ _i ] = arguments[ _i ];
            }
            this._chainedTweens = tweens;
            return this;
        };
        Tween.prototype.onStart = function( callback ) {
            this._onStartCallback = callback;
            return this;
        };
        Tween.prototype.onUpdate = function( callback ) {
            this._onUpdateCallback = callback;
            return this;
        };
        Tween.prototype.onRepeat = function( callback ) {
            this._onRepeatCallback = callback;
            return this;
        };
        Tween.prototype.onComplete = function( callback ) {
            this._onCompleteCallback = callback;
            return this;
        };
        Tween.prototype.onStop = function( callback ) {
            this._onStopCallback = callback;
            return this;
        };
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        Tween.prototype.update = function( time, autoStart ) {
            if ( time === void 0 ) {
                time = now$1( );
            }
            if ( autoStart === void 0 ) {
                autoStart = true;
            }
            if ( this._isPaused ) return true;
            var property;
            var elapsed;
            var endTime = this._startTime + this._duration;
            if ( !this._goToEnd && !this._isPlaying ) {
                if ( time > endTime ) return false;
                if ( autoStart ) this.start( time );
            }
            this._goToEnd = false;
            if ( time < this._startTime ) {
                return true;
            }
            if ( this._onStartCallbackFired === false ) {
                if ( this._onStartCallback ) {
                    this._onStartCallback( this._object );
                }
                this._onStartCallbackFired = true;
            }
            elapsed = ( time - this._startTime ) / this._duration;
            elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction( elapsed ); // properties transformations
            this._updateProperties( this._object, this._valuesStart, this._valuesEnd, value );
            if ( this._onUpdateCallback ) {
                this._onUpdateCallback( this._object, elapsed );
            }
            if ( elapsed === 1 ) {
                if ( this._repeat > 0 ) {
                    if ( isFinite( this._repeat ) ) {
                        this._repeat--;
                    } // Reassign starting values, restart by making startTime = now
                    for ( property in this._valuesStartRepeat ) {
                        if ( !this._yoyo && typeof this._valuesEnd[ property ] === 'string' ) {
                            this._valuesStartRepeat[ property ] = // eslint-disable-next-line
                                // @ts-ignore FIXME?
                                this._valuesStartRepeat[ property ] + parseFloat( this._valuesEnd[ property ] );
                        }
                        if ( this._yoyo ) {
                            this._swapEndStartRepeatValues( property );
                        }
                        this._valuesStart[ property ] = this._valuesStartRepeat[ property ];
                    }
                    if ( this._yoyo ) {
                        this._reversed = !this._reversed;
                    }
                    if ( this._repeatDelayTime !== undefined ) {
                        this._startTime = time + this._repeatDelayTime;
                    } else {
                        this._startTime = time + this._delayTime;
                    }
                    if ( this._onRepeatCallback ) {
                        this._onRepeatCallback( this._object );
                    }
                    return true;
                } else {
                    if ( this._onCompleteCallback ) {
                        this._onCompleteCallback( this._object );
                    }
                    for ( var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++ ) { // Make the chained tweens start exactly at the time they should,
                        // even if the `update()` method was called way past the duration of the tween
                        this._chainedTweens[ i ].start( this._startTime + this._duration );
                    }
                    this._isPlaying = false;
                    return false;
                }
            }
            return true;
        };
        Tween.prototype._updateProperties = function( _object, _valuesStart, _valuesEnd, value ) {
            for ( var property in _valuesEnd ) { // Don't update properties that do not exist in the source object
                if ( _valuesStart[ property ] === undefined ) {
                    continue;
                }
                var start = _valuesStart[ property ] || 0;
                var end = _valuesEnd[ property ];
                var startIsArray = Array.isArray( _object[ property ] );
                var endIsArray = Array.isArray( end );
                var isInterpolationList = !startIsArray && endIsArray;
                if ( isInterpolationList ) {
                    _object[ property ] = this._interpolationFunction( end, value );
                } else if ( _typeof( end ) === 'object' && end ) { // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._updateProperties( _object[ property ], start, end, value );
                } else { // Parses relative end values with start as base (e.g.: +10, -3)
                    end = this._handleRelativeValue( start, end ); // Protect against non numeric properties.
                    if ( typeof end === 'number' ) { // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _object[ property ] = start + ( end - start ) * value;
                    }
                }
            }
        };
        Tween.prototype._handleRelativeValue = function( start, end ) {
            if ( typeof end !== 'string' ) {
                return end;
            }
            if ( end.charAt( 0 ) === '+' || end.charAt( 0 ) === '-' ) {
                return start + parseFloat( end );
            } else {
                return parseFloat( end );
            }
        };
        Tween.prototype._swapEndStartRepeatValues = function( property ) {
            var tmp = this._valuesStartRepeat[ property ];
            var endValue = this._valuesEnd[ property ];
            if ( typeof endValue === 'string' ) {
                this._valuesStartRepeat[ property ] = this._valuesStartRepeat[ property ] + parseFloat( endValue );
            } else {
                this._valuesStartRepeat[ property ] = this._valuesEnd[ property ];
            }
            this._valuesEnd[ property ] = tmp;
        };
        return Tween;
    }( );
    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    Sequence.nextId;
    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tweens.
     */
    var TWEEN = mainGroup; // This is the best way to export things in a way that's compatible with both ES
    // Modules and CommonJS, without build hacks, and so as not to break the
    // existing API.
    // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
    TWEEN.getAll.bind( TWEEN );
    TWEEN.removeAll.bind( TWEEN );
    TWEEN.add.bind( TWEEN );
    TWEEN.remove.bind( TWEEN );
    var update = TWEEN.update.bind( TWEEN );
    var X_BUTTON = 0;
    var O_BUTTON = 1;
    var SQUARE_BUTTON = 2;
    var TRIANGLE_BUTTON = 3;
    var Card = /*#__PURE__*/ function( ) {
        function Card( ) {
            _classCallCheck( this, Card );
            throw "Cannot construct a card";
        }
        _createClass( Card, null, [ {
            key: "initDOM",
            value: function initDOM( ) {
                document.body.appendChild( this.card );
                this.card.className = "card";
                this.added = true;
            }
        } ] );
        return Card;
    }( );
    Card.card = document.createElementNS( "http://www.w3.org/1999/xhtml", "div" );
    Card.added = false;
    var cards$1 = {
        advil: {
            card: "Advance to Illinois Ave.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee2( ) {
                    return _regeneratorRuntime( ).wrap( function _callee2$( _context9 ) {
                        while ( 1 ) {
                            switch ( _context9.prev = _context9.next ) {
                                case 0:
                                    _context9.next = 2;
                                    return player.goToPosition( 24 );
                                case 2:
                                case "end":
                                    return _context9.stop( );
                            }
                        }
                    }, _callee2 );
                } ) )( );
            },
            immediate: true
        },
        advut: {
            card: "Advance to nearest utility.\nIf unowned, you may buy from bank.\n If owned, reroll dice and pay owner 10 times the rolled amount.",
            "function": function _function( player ) { //set player position to nearest utility based on current position
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee3( ) {
                    return _regeneratorRuntime( ).wrap( function _callee3$( _context10 ) {
                        while ( 1 ) {
                            switch ( _context10.prev = _context10.next ) {
                                case 0:
                                case "end":
                                    return _context10.stop( );
                            }
                        }
                    }, _callee3 );
                } ) )( );
            },
            immediate: true
        },
        chair: {
            card: "You have been elected chairman of the board. Pay each player $50",
            "function": function _function( user ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee4( ) {
                    var players, _iterator5, _step5, player;
                    return _regeneratorRuntime( ).wrap( function _callee4$( _context11 ) {
                        while ( 1 ) {
                            switch ( _context11.prev = _context11.next ) {
                                case 0:
                                    players = Globals.players;
                                    user.money -= 50 * players.length - 1;
                                    _iterator5 = _createForOfIteratorHelper( players );
                                    try {
                                        for ( _iterator5.s( ); !( _step5 = _iterator5.n( ) ).done; ) {
                                            player = _step5.value;
                                            if ( player !== user ) player.money += 50;
                                        }
                                    } catch ( err ) {
                                        _iterator5.e( err );
                                    } finally {
                                        _iterator5.f( );
                                    }
                                case 4:
                                case "end":
                                    return _context11.stop( );
                            }
                        }
                    }, _callee4 );
                } ) )( );
            },
            immediate: true
        },
        advgo: {
            card: "Advance to go",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee5( ) {
                    return _regeneratorRuntime( ).wrap( function _callee5$( _context12 ) {
                        while ( 1 ) {
                            switch ( _context12.prev = _context12.next ) {
                                case 0:
                                    _context12.next = 2;
                                    return player.goToPosition( 0 );
                                case 2:
                                case "end":
                                    return _context12.stop( );
                            }
                        }
                    }, _callee5 );
                } ) )( );
            },
            immediate: true
        },
        advrr: {
            card: "Take a ride on the reading.\n If you pass go, collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee6( ) {
                    return _regeneratorRuntime( ).wrap( function _callee6$( _context13 ) {
                        while ( 1 ) {
                            switch ( _context13.prev = _context13.next ) {
                                case 0:
                                    _context13.next = 2;
                                    return player.goToPosition( 5 );
                                case 2:
                                case "end":
                                    return _context13.stop( );
                            }
                        }
                    }, _callee6 );
                } ) )( );
            },
            immediate: true
        },
        loan: {
            card: "Your building and loan matures.\n Collect $150",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee7( ) {
                    return _regeneratorRuntime( ).wrap( function _callee7$( _context14 ) {
                        while ( 1 ) {
                            switch ( _context14.prev = _context14.next ) {
                                case 0:
                                    player.money += 150;
                                case 1:
                                case "end":
                                    return _context14.stop( );
                            }
                        }
                    }, _callee7 );
                } ) )( );
            },
            immediate: true
        },
        bank: {
            card: "Bank pays you dividend of $50",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee8( ) {
                    return _regeneratorRuntime( ).wrap( function _callee8$( _context15 ) {
                        while ( 1 ) {
                            switch ( _context15.prev = _context15.next ) {
                                case 0:
                                    player.money += 50;
                                case 1:
                                case "end":
                                    return _context15.stop( );
                            }
                        }
                    }, _callee8 );
                } ) )( );
            },
            immediate: true
        },
        advbw: {
            card: "Take a walk on the board walk.\nAdvance token to board walk.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee9( ) {
                    return _regeneratorRuntime( ).wrap( function _callee9$( _context16 ) {
                        while ( 1 ) {
                            switch ( _context16.prev = _context16.next ) {
                                case 0:
                                    _context16.next = 2;
                                    return player.goToPosition( 39 );
                                case 2:
                                case "end":
                                    return _context16.stop( );
                            }
                        }
                    }, _callee9 );
                } ) )( );
            },
            immediate: true
        },
        back: {
            card: "Go back 3 spaces",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee10( ) {
                    return _regeneratorRuntime( ).wrap( function _callee10$( _context17 ) {
                        while ( 1 ) {
                            switch ( _context17.prev = _context17.next ) {
                                case 0:
                                    player.inJail = true;
                                    _context17.next = 3;
                                    return player.moveBackward( 3 );
                                case 3:
                                    player.inJail = false;
                                case 4:
                                case "end":
                                    return _context17.stop( );
                            }
                        }
                    }, _callee10 );
                } ) )( );
            },
            immediate: true
        },
        houses: {
            card: "Because one of your houses wasn't up to code, the roof collapsed and killed someone.\n Go to jail. Go directly to jail, do not pass go, do not collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee11( ) {
                    return _regeneratorRuntime( ).wrap( function _callee11$( _context18 ) {
                        while ( 1 ) {
                            switch ( _context18.prev = _context18.next ) {
                                case 0:
                                    player.inJail = true;
                                    player.jailTurns = 1;
                                    _context18.next = 4;
                                    return player.goToPosition( 10 );
                                case 4:
                                case "end":
                                    return _context18.stop( );
                            }
                        }
                    }, _callee11 );
                } ) )( );
            },
            immediate: true
        },
        advnr: {
            card: "Advance token to the nearest railroad and pay owner twice the rental to which they are entitled.\nIf railroad is unowned, you may buy it from the bank",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee12( ) {
                    return _regeneratorRuntime( ).wrap( function _callee12$( _context19 ) {
                        while ( 1 ) {
                            switch ( _context19.prev = _context19.next ) {
                                case 0:
                                case "end":
                                    return _context19.stop( );
                            }
                        }
                    }, _callee12 );
                } ) )( );
            },
            immediate: true
        },
        advjl: {
            card: "Go directly to jail.\n Do not pass go, do not collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee13( ) {
                    return _regeneratorRuntime( ).wrap( function _callee13$( _context20 ) {
                        while ( 1 ) {
                            switch ( _context20.prev = _context20.next ) {
                                case 0:
                                    player.inJail = true;
                                    player.jailTurns = 1;
                                    _context20.next = 4;
                                    return player.goToPosition( 10 );
                                case 4:
                                case "end":
                                    return _context20.stop( );
                            }
                        }
                    }, _callee13 );
                } ) )( );
            },
            immediate: true
        },
        advnj: {
            card: "Get out of jail free",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee14( ) {
                    return _regeneratorRuntime( ).wrap( function _callee14$( _context21 ) {
                        while ( 1 ) {
                            switch ( _context21.prev = _context21.next ) {
                                case 0:
                                    player.inJail = false;
                                case 1:
                                case "end":
                                    return _context21.stop( );
                            }
                        }
                    }, _callee14 );
                } ) )( );
            },
            immediate: false
        },
        poor: {
            card: "Pay poor tax of $15",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee15( ) {
                    return _regeneratorRuntime( ).wrap( function _callee15$( _context22 ) {
                        while ( 1 ) {
                            switch ( _context22.prev = _context22.next ) {
                                case 0:
                                    player.money -= 15;
                                case 1:
                                case "end":
                                    return _context22.stop( );
                            }
                        }
                    }, _callee15 );
                } ) )( );
            },
            immediate: false
        },
        advsc: {
            card: "Advance to St. Charles Place.\nIf you pass go, collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee16( ) {
                    return _regeneratorRuntime( ).wrap( function _callee16$( _context23 ) {
                        while ( 1 ) {
                            switch ( _context23.prev = _context23.next ) {
                                case 0:
                                    _context23.next = 2;
                                    return player.goToPosition( 11 );
                                case 2:
                                case "end":
                                    return _context23.stop( );
                            }
                        }
                    }, _callee16 );
                } ) )( );
            },
            immediate: true
        },
        advrng: {
            card: "Go to a random spot on the board. If you pass go, collect $200.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee17( ) {
                    return _regeneratorRuntime( ).wrap( function _callee17$( _context24 ) {
                        while ( 1 ) {
                            switch ( _context24.prev = _context24.next ) {
                                case 0:
                                    _context24.next = 2;
                                    return player.goToPosition( Math.random( ) * 40 | 0 );
                                case 2:
                                case "end":
                                    return _context24.stop( );
                            }
                        }
                    }, _callee17 );
                } ) )( );
            },
            immediate: true
        },
        bots: {
            card: "You were found to be betting on bot fights.\n Go to jail, go directly to jail, do not pass go, do not collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee18( ) {
                    return _regeneratorRuntime( ).wrap( function _callee18$( _context25 ) {
                        while ( 1 ) {
                            switch ( _context25.prev = _context25.next ) {
                                case 0:
                                    player.inJail = true;
                                    player.jailTurns = 1;
                                    _context25.next = 4;
                                    return player.goToPosition( 10 );
                                case 4:
                                case "end":
                                    return _context25.stop( );
                            }
                        }
                    }, _callee18 );
                } ) )( );
            }
        }
    };
    var ChanceTile = /*#__PURE__*/ function( ) {
        function ChanceTile( ) {
            _classCallCheck( this, ChanceTile );
            this.type = "chance";
        }
        _createClass( ChanceTile, [ {
            key: "onLand",
            value: function onLand( player ) {
                return new Promise( function( resolve ) { //choose card
                    var k = Object.keys( cards$1 );
                    var card = cards$1[ k[ Math.random( ) * ( k.length - 1 ) | 0 ] ];
                    var dCard = Card.card;
                    if ( !Card.added ) Card.initDOM( );
                    dCard.innerText = card.card;
                    dCard.style.display = "block";
                    dCard.style.bottom = "-50px";
                    dCard.style.transform = "translate(-50%, 0%)";
                    new Tween( {
                        h: -50
                    } ).to( {
                        h: 400
                    }, 4500 ).onUpdate( function( _ref3 ) {
                        var h = _ref3.h;
                        dCard.style.bottom = h + "px";
                    } ).delay( 2000 ).start( ).onComplete( function( ) {
                        setTimeout( function( ) {
                            dCard.style.display = "none";
                            card[ "function" ]( player ).then( resolve );
                        }, 3000 );
                    } );
                } );
            }
        } ] );
        return ChanceTile;
    }( );
    var cards = {
        advnj: {
            card: "Get out of jail, free.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee19( ) {
                    return _regeneratorRuntime( ).wrap( function _callee19$( _context26 ) {
                        while ( 1 ) {
                            switch ( _context26.prev = _context26.next ) {
                                case 0:
                                    player.inJail = false;
                                case 1:
                                case "end":
                                    return _context26.stop( );
                            }
                        }
                    }, _callee19 );
                } ) )( );
            },
            immediate: false
        },
        life: {
            card: "Life insurance matures.\n Collect $100.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee20( ) {
                    return _regeneratorRuntime( ).wrap( function _callee20$( _context27 ) {
                        while ( 1 ) {
                            switch ( _context27.prev = _context27.next ) {
                                case 0:
                                    player.money += 100;
                                case 1:
                                case "end":
                                    return _context27.stop( );
                            }
                        }
                    }, _callee20 );
                } ) )( );
            },
            immediate: true
        },
        stock: {
            card: "From sale of stock, you get $45.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee21( ) {
                    return _regeneratorRuntime( ).wrap( function _callee21$( _context28 ) {
                        while ( 1 ) {
                            switch ( _context28.prev = _context28.next ) {
                                case 0:
                                    player.money += 45;
                                case 1:
                                case "end":
                                    return _context28.stop( );
                            }
                        }
                    }, _callee21 );
                } ) )( );
            },
            immediate: true
        },
        belle: {
            card: "You lost horribly in a beauty contest.\n Pay $50 for entrance fee.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee22( ) {
                    return _regeneratorRuntime( ).wrap( function _callee22$( _context29 ) {
                        while ( 1 ) {
                            switch ( _context29.prev = _context29.next ) {
                                case 0:
                                    player.money -= 50;
                                case 1:
                                case "end":
                                    return _context29.stop( );
                            }
                        }
                    }, _callee22 );
                } ) )( );
            },
            immediate: true
        },
        xmas: {
            card: "You were found stealing toys from children on X-mas.\n Pay $100 for compensation.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee23( ) {
                    return _regeneratorRuntime( ).wrap( function _callee23$( _context30 ) {
                        while ( 1 ) {
                            switch ( _context30.prev = _context30.next ) {
                                case 0:
                                    player.money -= 100;
                                case 1:
                                case "end":
                                    return _context30.stop( );
                            }
                        }
                    }, _callee23 );
                } ) )( );
            },
            immediate: true
        },
        tax: {
            card: "You were convicted of tax evasion.\n Go to jail, go directly to jail, do not pass go, do not collect $200.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee24( ) {
                    return _regeneratorRuntime( ).wrap( function _callee24$( _context31 ) {
                        while ( 1 ) {
                            switch ( _context31.prev = _context31.next ) {
                                case 0:
                                    player.inJail = true;
                                    player.jailTurns = 1;
                                    player.goToPosition( 10 );
                                case 3:
                                case "end":
                                    return _context31.stop( );
                            }
                        }
                    }, _callee24 );
                } ) )( );
            },
            immediate: true
        },
        opera: {
            card: "Grand Opera Opening.\n Collect $50 from every player.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee25( ) {
                    var players, _iterator6, _step6, opp;
                    return _regeneratorRuntime( ).wrap( function _callee25$( _context32 ) {
                        while ( 1 ) {
                            switch ( _context32.prev = _context32.next ) {
                                case 0:
                                    players = Globals.players;
                                    _iterator6 = _createForOfIteratorHelper( players );
                                    try {
                                        for ( _iterator6.s( ); !( _step6 = _iterator6.n( ) ).done; ) {
                                            opp = _step6.value;
                                            opp.money -= 50;
                                            player.money += 50;
                                        }
                                    } catch ( err ) {
                                        _iterator6.e( err );
                                    } finally {
                                        _iterator6.f( );
                                    }
                                case 3:
                                case "end":
                                    return _context32.stop( );
                            }
                        }
                    }, _callee25 );
                } ) )( );
            },
            immediate: true
        },
        hosp: {
            card: "You broke your ankle. Pay hospital bill of $150.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee26( ) {
                    return _regeneratorRuntime( ).wrap( function _callee26$( _context33 ) {
                        while ( 1 ) {
                            switch ( _context33.prev = _context33.next ) {
                                case 0:
                                    player.money -= 150;
                                case 1:
                                case "end":
                                    return _context33.stop( );
                            }
                        }
                    }, _callee26 );
                } ) )( );
            },
            immediate: true
        },
        school: {
            card: "You bought books for a student. Pay $10.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee27( ) {
                    return _regeneratorRuntime( ).wrap( function _callee27$( _context34 ) {
                        while ( 1 ) {
                            switch ( _context34.prev = _context34.next ) {
                                case 0:
                                    player.money -= 10;
                                case 1:
                                case "end":
                                    return _context34.stop( );
                            }
                        }
                    }, _callee27 );
                } ) )( );
            },
            immediate: true
        },
        repairs: {
            card: "Housing market soars.\n Collect $100.",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee28( ) {
                    return _regeneratorRuntime( ).wrap( function _callee28$( _context35 ) {
                        while ( 1 ) {
                            switch ( _context35.prev = _context35.next ) {
                                case 0:
                                    player.money += 100;
                                case 1:
                                case "end":
                                    return _context35.stop( );
                            }
                        }
                    }, _callee28 );
                } ) )( );
            },
            immediate: true
        },
        bank: {
            card: "Bank error really in your favor. Collect $350",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee29( ) {
                    return _regeneratorRuntime( ).wrap( function _callee29$( _context36 ) {
                        while ( 1 ) {
                            switch ( _context36.prev = _context36.next ) {
                                case 0:
                                    player.money += 350;
                                case 1:
                                case "end":
                                    return _context36.stop( );
                            }
                        }
                    }, _callee29 );
                } ) )( );
            },
            immediate: true
        },
        marriage: {
            card: "You got married and then robbed blind.\n You lose $400",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee30( ) {
                    return _regeneratorRuntime( ).wrap( function _callee30$( _context37 ) {
                        while ( 1 ) {
                            switch ( _context37.prev = _context37.next ) {
                                case 0:
                                    player.money -= 400;
                                case 1:
                                case "end":
                                    return _context37.stop( );
                            }
                        }
                    }, _callee30 );
                } ) )( );
            },
            immediate: true
        },
        inherit: {
            card: "You inherit $500",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee31( ) {
                    return _regeneratorRuntime( ).wrap( function _callee31$( _context38 ) {
                        while ( 1 ) {
                            switch ( _context38.prev = _context38.next ) {
                                case 0:
                                    player.money += 500;
                                case 1:
                                case "end":
                                    return _context38.stop( );
                            }
                        }
                    }, _callee31 );
                } ) )( );
            },
            immediate: true
        },
        advjl: {
            card: "Go to jail. Go directly to jail.\n Do not pass go, do not collect $200",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee32( ) {
                    return _regeneratorRuntime( ).wrap( function _callee32$( _context39 ) {
                        while ( 1 ) {
                            switch ( _context39.prev = _context39.next ) {
                                case 0:
                                    player.inJail = true;
                                    player.jailTurns = 1;
                                    player.goToPosition( 10 );
                                case 3:
                                case "end":
                                    return _context39.stop( );
                            }
                        }
                    }, _callee32 );
                } ) )( );
            },
            immediate: true
        },
        jackpot: {
            card: "You got a lottery ticket.\n You have a 1 / 1000 chance that you win $1000, otherwise, you lose $10",
            "function": function _function( player ) {
                return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee33( ) {
                    return _regeneratorRuntime( ).wrap( function _callee33$( _context40 ) {
                        while ( 1 ) {
                            switch ( _context40.prev = _context40.next ) {
                                case 0:
                                    player.money += Number( ( Math.random( ) * 1000 | 0 ) == 234 ) * 1000;
                                case 1:
                                case "end":
                                    return _context40.stop( );
                            }
                        }
                    }, _callee33 );
                } ) )( );
            },
            immediate: true
        }
    };
    var CommunityChest = /*#__PURE__*/ function( ) {
        function CommunityChest( ) {
            _classCallCheck( this, CommunityChest );
            this.type = "community chest";
        }
        _createClass( CommunityChest, [ {
            key: "onLand",
            value: function onLand( player ) {
                return new Promise( function( resolve ) {
                    var k = Object.keys( cards );
                    var card = cards[ k[ Math.random( ) * ( k.length - 1 ) | 0 ] ];
                    var dCard = Card.card;
                    if ( !Card.added ) Card.initDOM( );
                    dCard.innerText = card.card;
                    dCard.style.display = "block";
                    dCard.style.bottom = "-50px";
                    dCard.style.transform = "translate(-50%, 0%)";
                    new Tween( {
                        h: -50
                    } ).to( {
                        h: 400
                    }, 4500 ).onUpdate( function( _ref4 ) {
                        var h = _ref4.h;
                        dCard.style.bottom = h + "px";
                    } ).delay( 2000 ).start( ).onComplete( function( ) {
                        setTimeout( function( ) {
                            dCard.style.display = "none";
                        }, 3000 );
                    } );
                } );
            }
        } ] );
        return CommunityChest;
    }( );
    var FreeParking = /*#__PURE__*/ function( ) {
        function FreeParking( ) {
            _classCallCheck( this, FreeParking );
            this.type = "special";
        }
        _createClass( FreeParking, [ {
            key: "onLand",
            value: function( ) {
                var _onLand = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee34( player ) {
                    return _regeneratorRuntime( ).wrap( function _callee34$( _context41 ) {
                        while ( 1 ) {
                            switch ( _context41.prev = _context41.next ) {
                                case 0:
                                case "end":
                                    return _context41.stop( );
                            }
                        }
                    }, _callee34 );
                } ) );

                function onLand( _x14 ) {
                    return _onLand.apply( this, arguments );
                }
                return onLand;
            }( )
        } ] );
        return FreeParking;
    }( );
    var GoTile = /*#__PURE__*/ function( ) {
        function GoTile( ) {
            _classCallCheck( this, GoTile );
            this.type = "special";
        }
        _createClass( GoTile, [ {
            key: "onLand",
            value: function( ) {
                var _onLand2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee35( player ) {
                    return _regeneratorRuntime( ).wrap( function _callee35$( _context42 ) {
                        while ( 1 ) {
                            switch ( _context42.prev = _context42.next ) {
                                case 0:
                                    player.money += 100;
                                case 1:
                                case "end":
                                    return _context42.stop( );
                            }
                        }
                    }, _callee35 );
                } ) );

                function onLand( _x15 ) {
                    return _onLand2.apply( this, arguments );
                }
                return onLand;
            }( )
        } ] );
        return GoTile;
    }( );
    var GoToJail = /*#__PURE__*/ function( ) {
        function GoToJail( ) {
            _classCallCheck( this, GoToJail );
            this.type = "special";
            this.jailed = null;
        }
        _createClass( GoToJail, [ {
            key: "onLand",
            value: function( ) {
                var _onLand3 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee36( player ) {
                    return _regeneratorRuntime( ).wrap( function _callee36$( _context43 ) {
                        while ( 1 ) {
                            switch ( _context43.prev = _context43.next ) {
                                case 0:
                                    if ( this.jailed ) this.jailed.inJail = false;
                                    this.jailed = player;
                                    player.jailTurns = 1;
                                    player.inJail = true;
                                    _context43.next = 6;
                                    return player.goToPosition( 10 );
                                case 6:
                                case "end":
                                    return _context43.stop( );
                            }
                        }
                    }, _callee36, this );
                } ) );

                function onLand( _x16 ) {
                    return _onLand3.apply( this, arguments );
                }
                return onLand;
            }( )
        } ] );
        return GoToJail;
    }( );
    var properties = [ "Mediterranean Avenue", "Baltic Avenue", "Reading Railroad", "Oriental Avenue", "Vermont Avenue", "Connecticut Avenue", "St. Charles Place", "Electric Company", "States Avenue", "Virginia Avenue", "Pennsylvania Railroad", "St. James Place", "Tennessee Avenue", "New York Avenue", "Kentucky Avenue", "Indiana Avenue", "Illinois Avenue", "B. & O. Railroad", "Atlantic Avenue", "Vetnor Avenue", "Water Works", "Marvins Gardens", "Pacific Avenue", "North Carolina Avenue", "Pennsylvania Avenue", "Short Line", "Park Place", "Boardwalk" ];
    var Property = /*#__PURE__*/ function( ) {
        function Property( cost, rent, houseCost, houseRents, axis, value, direction ) {
            _classCallCheck( this, Property );
            this.numHouses = 0;
            this.mortgaged = false;
            this.type = "property";
            this.owner = null;
            this.table = {
                cost: cost,
                houseCost: houseCost,
                rents: [ rent ].concat( _toConsumableArray( houseRents ) ),
                mortgage: cost / 2,
                houseMortgage: houseCost / 2
            };
            this.initHousePos = new Vector3( );
            this.initHousePos[ axis ] = value;
            this.initHousePos[ axis == "z" ? "x" : "z" ] = 560 * direction;
            this.axis = axis;
            this.instanceId = Property.PROPERTY_COUNT++ * 4;
        }
        _createClass( Property, [ {
            key: "onLand",
            value: function( ) {
                var _onLand4 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee37( player ) {
                    var scope;
                    return _regeneratorRuntime( ).wrap( function _callee37$( _context44 ) {
                        while ( 1 ) {
                            switch ( _context44.prev = _context44.next ) {
                                case 0:
                                    scope = this;
                                    if ( this.owner ) {
                                        _context44.next = 5;
                                        break;
                                    }
                                    if ( player.money >= this.table.cost ) {
                                        player.awaitButtonPress( [ X_BUTTON, O_BUTTON ] ).then( function( button ) {
                                            if ( button == O_BUTTON ) {
                                                player.money -= scope.table.cost;
                                                scope.owner = player;
                                                player.properties.push( scope );
                                                player.propertyCount++;
                                            }
                                        } );
                                    }
                                    _context44.next = 9;
                                    break;
                                case 5:
                                    if ( !( this.owner !== player ) ) {
                                        _context44.next = 9;
                                        break;
                                    }
                                    if ( !( this.owner.inJail || this.mortgaged ) ) {
                                        _context44.next = 8;
                                        break;
                                    }
                                    return _context44.abrupt( "return" );
                                case 8:
                                    this.owner.awaitButtonPressFor( [ TRIANGLE_BUTTON ], 20000 ).then( function( ) {
                                        player.money -= scope.table.rents[ scope.numHouses ];
                                        scope.owner.money += scope.table.rents[ scope.numHouses ];
                                    } )[ "catch" ]( function( ) {
                                        var rentElem = document.getElementById( "noRent" );
                                        rentElem.innerHTML = scope.owner.name + " Forgot to collect on their rent";
                                        rentElem.style.display = "inline";
                                        setTimeout( function( ) {
                                            rentElem.style.display = "none";
                                        }, 10000 );
                                    } );
                                case 9:
                                case "end":
                                    return _context44.stop( );
                            }
                        }
                    }, _callee37, this );
                } ) );

                function onLand( _x17 ) {
                    return _onLand4.apply( this, arguments );
                }
                return onLand;
            }( )
        }, {
            key: "mortgage",
            value: function mortgage( ) {
                this.mortgaged = true;
                this.owner.money += this.table.mortgage;
            }
        }, {
            key: "unmortgage",
            value: function unmortgage( ) {
                var unmortgageCost = this.table.cost * 1.1;
                if ( this.owner.money >= unmortgageCost ) {
                    this.owner.money -= unmortgageCost;
                    this.mortgaged = false;
                }
            }
        }, {
            key: "toggleMortgage",
            value: function toggleMortgage( ) {
                if ( this.mortgaged ) {
                    this.unmortgage( );
                } else {
                    this.mortgage( );
                }
            }
        }, {
            key: "getPropertyName",
            value: function getPropertyName( ) {
                return properties[ this.instanceId / 4 ];
            }
        }, {
            key: "addHouse",
            value: function addHouse( ) {
                var scope = this;
                return new Promise( function( resolve, reject ) {
                    if ( scope.numHouses === 4 ) {
                        resolve( );
                        return;
                    }
                    if ( scope.owner.money >= scope.table.houseCost ) {
                        scope.owner.money -= scope.table.houseCost;
                        var fromIObj = Globals.fromIObj,
                            toIObj = Globals.toIObj,
                            houseMesh = Globals.houseMesh;
                        var _v = new Vector3( ),
                            _v2 = new Vector3( ),
                            q0 = new Quaternion$1( ),
                            q1 = new Quaternion$1( );
                        var p = new Vector3( ),
                            s = new Vector3( 1, 1, 1 ),
                            q = new Quaternion$1( ),
                            m = new Matrix4( );
                        var _i284 = scope.instanceId + scope.numHouses;
                        fromIObj.a = 0;
                        toIObj.a = 1;
                        _v2.copy( scope.initHousePos );
                        _v2[ scope.axis ] -= Property.HOUSE_WIDTH * scope.numHouses;
                        scope.numHouses++;
                        _v.copy( _v2 );
                        _v.negate( );
                        _v.setLength( 2000 );
                        q0.set( 0, 0, 0, 1 );
                        if ( scope.axis == "x" ) {
                            q1.set( 0, 0, 0, 1 );
                        } else {
                            q1.set( 0, Math.SQRT1_2, 0, Math.SQRT1_2 );
                        }
                        new Tween( fromIObj ).to( toIObj, 7000 ).onUpdate( function( _ref5 ) {
                            var a = _ref5.a;
                            p.lerpVectors( _v, _v2, a );
                            q.slerpQuaternions( q0, q1, a );
                            m.compose( p, q, s );
                            houseMesh.setMatrixAt( _i284, m );
                            houseMesh.instanceMatrix.needsUpdate = true;
                        } ).onComplete( function( ) {
                            resolve( );
                        } ).easing( Easing.Bounce.Out ).start( );
                    } else {
                        resolve( );
                    }
                } );
            }
        }, {
            key: "removeHouse",
            value: function removeHouse( ) {
                var scope = this;
                return new Promise( function( resolve ) {
                    if ( scope.numHouses === 0 ) {
                        resolve( );
                        return;
                    }
                    scope.owner.money += scope.table.houseMortgage;
                    var fromIObj = Globals.fromIObj,
                        toIObj = Globals.toIObj,
                        houseMesh = Globals.houseMesh;
                    var v0 = new Vector3( ),
                        v1 = new Vector3( ),
                        q0 = new Quaternion$1( ),
                        q1 = new Quaternion$1( );
                    var p = new Vector3( ),
                        s = new Vector3( 1, 1, 1 ),
                        q = new Quaternion$1( ),
                        m = new Matrix4( );
                    scope.numHouses--;
                    var i = scope.instanceId + scope.numHouses;
                    houseMesh.getMatrixAt( i, m );
                    v0.setFromMatrixPosition( m );
                    v1.copy( v0 );
                    v1.negate( );
                    v1.setLength( 2000 );
                    q0.setFromRotationMatrix( m );
                    q1.set( 0, 0, 0, 1 );
                    fromIObj.a = 0;
                    toIObj.a = 1;
                    new Tween( fromIObj ).to( toIObj, 7000 ).onUpdate( function( _ref6 ) {
                        var a = _ref6.a;
                        p.lerpVectors( v0, v1, a );
                        q.slerpQuaternions( q0, q1, a );
                        m.compose( p, q, s );
                        houseMesh.setMatrixAt( i, m );
                        houseMesh.instanceMatrix.needsUpdate = true;
                    } ).onComplete( function( ) {
                        m.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
                        houseMesh.setMatrixAt( i, m );
                        houseMesh.instanceMatrix.needsUpdate = true;
                        resolve( );
                    } ).easing( Easing.Bounce.In ).start( );
                } );
            }
        } ] );
        return Property;
    }( );
    Property.HOUSE_WIDTH = 28;
    Property.PROPERTY_COUNT = 0;
    var TaxTile = /*#__PURE__*/ function( ) {
        function TaxTile( tax ) {
            _classCallCheck( this, TaxTile );
            this.type = "special";
            this.tax = tax;
        }
        _createClass( TaxTile, [ {
            key: "onLand",
            value: function( ) {
                var _onLand5 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee38( player ) {
                    return _regeneratorRuntime( ).wrap( function _callee38$( _context45 ) {
                        while ( 1 ) {
                            switch ( _context45.prev = _context45.next ) {
                                case 0:
                                    player.money -= this.tax;
                                case 1:
                                case "end":
                                    return _context45.stop( );
                            }
                        }
                    }, _callee38, this );
                } ) );

                function onLand( _x18 ) {
                    return _onLand5.apply( this, arguments );
                }
                return onLand;
            }( )
        } ] );
        return TaxTile;
    }( );
    var Globals = /*#__PURE__*/ _createClass( function Globals( ) {
        _classCallCheck( this, Globals );
        throw "Cannot create a Globals instance";
    } );
    Globals.players = [ ];
    Globals.tiles = [ new GoTile( ), new Property( 60, 2, 50, [ 10, 30, 90, 160 ], "x", 517, 1 ), new CommunityChest( ), new Property( 60, 4, 50, [ 20, 60, 180, 320 ], "x", 280, 1 ), new TaxTile( 200 ), new Property( 200, 50, 0, [ 50, 50, 50, 50 ], "x", 45, 1 ), new Property( 100, 6, 50, [ 30, 90, 270, 400 ], "x", -77, 1 ), new ChanceTile( ), new Property( 100, 6, 50, [ 30, 90, 270, 400 ], "x", -312, 1 ), new Property( 120, 8, 50, [ 40, 100, 300, 450 ], "x", -430, 1 ), new FreeParking( ), new Property( 140, 10, 100, [ 50, 150, 450, 625 ], "z", 517, -1 ), new Property( 150, 75, 0, [ 75, 75, 75, 75 ], "z", 400, -1 ), new Property( 140, 10, 100, [ 50, 150, 450, 625 ], "z", 280, -1 ), new Property( 160, 12, 100, [ 60, 180, 500, 700 ], "z", 160, -1 ), new Property( 200, 75, 0, [ 75, 75, 75, 75 ], "z", 44, -1 ), new Property( 180, 14, 100, [ 70, 200, 550, 750 ], "z", -77, -1 ), new CommunityChest( ), new Property( 180, 14, 100, [ 70, 200, 550, 750 ], "z", -314, -1 ), new Property( 100, 16, 100, [ 80, 220, 600, 800 ], "z", -432, -1 ), new FreeParking( ), new Property( 220, 18, 150, [ 90, 250, 700, 875 ], "x", -430, -1 ), new ChanceTile( ), new Property( 220, 18, 150, [ 90, 250, 700, 875 ], "x", -195, -1 ), new Property( 240, 20, 150, [ 100, 300, 750, 925 ], "x", -77, -1 ), new Property( 200, 125, 0, [ 125, 125, 125, 125 ], "x", 45, -1 ), new Property( 260, 22, 150, [ 110, 330, 800, 975 ], "x", 162, -1 ), new Property( 260, 22, 150, [ 110, 30, 800, 975 ], "x", 280, -1 ), new Property( 150, 75, 0, [ 75, 75, 75, 75 ], "x", 398, -1 ), new Property( 280, 24, 150, [ 120, 360, 850, 1025 ], "x", 517, -1 ), new GoToJail( ), new Property( 300, 26, 200, [ 130, 390, 900, 1100 ], "z", -432, 1 ), new Property( 300, 26, 200, [ 130, 390, 900, 1100 ], "z", -314, 1 ), new CommunityChest( ), new Property( 320, 28, 200, [ 150, 450, 1000, 1200 ], "z", -77, 1 ), new Property( 200, 200, 0, [ 200, 200, 200, 200 ], "z", 44, 1 ), new ChanceTile( ), new Property( 350, 35, 200, [ 175, 500, 1100, 1300 ], "z", 280, 1 ), new TaxTile( 75 ), new Property( 400, 50, 200, [ 200, 600, 1400, 1700 ], "z", 517, 1 ) ];
    Globals.v0 = new Vector3( );
    Globals.v1 = new Vector3( );
    Globals.q0 = new Quaternion$1( );
    Globals.q1 = new Quaternion$1( );
    Globals.fromIObj = {
        a: 0
    };
    Globals.toIObj = {
        a: 1
    };
    var tilePositions = [ 0.000, .0333, .0570, .0810, .1046, .1280, .1530, .1767, .2010, .2245, .2550, .2830, .3070, .3300, .3550, .3800, .4030, .4260, .4510, .4750, .5000, .5333, .5570, .5815, .6047, .6290, .6520, .6765, .7000, .7240, .7540, .7820, .8065, .8310, .8550, .8795, .9030, .9265, .9505, .9750 ];
    var curve = new CatmullRomCurve3( [ new Vector3( 625, 0, 600 ), new Vector3( 600, 0, 625 ), new Vector3( -600, 0, 625 ), new Vector3( -625, 0, 600 ), new Vector3( -625, 0, -600 ), new Vector3( -600, 0, -625 ), new Vector3( 600, 0, -625 ), new Vector3( 625, 0, -600 ) ], true );
    var v0$1 = new Vector3( );
    var Player = /*#__PURE__*/ function( ) {
        function Player( id, name, token ) {
            _classCallCheck( this, Player );
            this.money = 1500;
            this.propertyCount = 0;
            this.properties = [ ];
            this.inJail = false;
            this.jailTurns = 0;
            this.chanceCard = null;
            this.communityChestCard = null;
            this.currentPos = 0;
            this.statsPanel = document.createElementNS( "http://www.w3.org/1999/xhtml", "div" );
            this.header = document.createElementNS( "http://www.w3.org/1999/xhtml", "h1" );
            this.body = document.createElementNS( "http://www.w3.org/1999/xhtml", "p" );
            this.gamepadId = id;
            this.name = name;
            this.statsPanel.className = "stats";
            this.token = token;
            curve.getPointAt( 0, this.token.position );
            curve.getPointAt( 0.01, v0$1 );
            this.token.lookAt( v0$1 );
            this.statsPanel.appendChild( this.header );
            this.statsPanel.appendChild( document.createElementNS( "http://www.w3.org/1999/xhtml", "hr" ) );
            this.statsPanel.appendChild( this.body );
            this.hideStats( );
            document.body.appendChild( this.statsPanel );
        }
        _createClass( Player, [ {
            key: "getGamepad",
            value: function getGamepad( ) {
                return navigator.getGamepads( )[ this.gamepadId ];
            }
        }, {
            key: "awaitButtonPress",
            value: function awaitButtonPress( allowedButtons ) {
                var scope = this;
                var p = new Promise( function( resolve, reject ) {
                    var i = setInterval( function( ) {
                        var _iterator7 = _createForOfIteratorHelper( allowedButtons ),
                            _step7;
                        try {
                            for ( _iterator7.s( ); !( _step7 = _iterator7.n( ) ).done; ) {
                                var button = _step7.value;
                                if ( scope.getGamepad( ).buttons[ button ].pressed ) {
                                    clearInterval( i );
                                    resolve( button );
                                }
                            }
                        } catch ( err ) {
                            _iterator7.e( err );
                        } finally {
                            _iterator7.f( );
                        }
                    }, 17 );
                } );
                return p;
            }
        }, {
            key: "awaitButtonPressFor",
            value: function awaitButtonPressFor( allowedButtons, timeoutMs ) {
                var scope = this;
                var p = new Promise( function( resolve, reject ) {
                    var i = setInterval( function( ) {
                        var _iterator8 = _createForOfIteratorHelper( allowedButtons ),
                            _step8;
                        try {
                            for ( _iterator8.s( ); !( _step8 = _iterator8.n( ) ).done; ) {
                                var button = _step8.value;
                                if ( scope.getGamepad( ).buttons[ button ].pressed ) {
                                    clearInterval( i );
                                    clearTimeout( t );
                                    resolve( button );
                                }
                            }
                        } catch ( err ) {
                            _iterator8.e( err );
                        } finally {
                            _iterator8.f( );
                        }
                    }, 17 );
                    var t = setTimeout( function( ) {
                        clearInterval( i );
                        clearTimeout( t );
                        reject( "Took Too long to press button" );
                    }, timeoutMs );
                } );
                return p;
            }
        }, {
            key: "baseStats",
            value: function( ) {
                var _baseStats = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee39( ) {
                    var scope, button;
                    return _regeneratorRuntime( ).wrap( function _callee39$( _context46 ) {
                        while ( 1 ) {
                            switch ( _context46.prev = _context46.next ) {
                                case 0:
                                    scope = this;
                                    scope.header.innerHTML = this.name;
                                    scope.body.innerText = "Money: ".concat( this.money, "\nNum Properties: " ).concat( this.properties.length, "\nProperties > Circle\nClose > Square" );
                                    _context46.next = 5;
                                    return scope.awaitButtonPress( [ O_BUTTON, SQUARE_BUTTON ] );
                                case 5:
                                    button = _context46.sent;
                                    if ( !( button == O_BUTTON ) ) {
                                        _context46.next = 11;
                                        break;
                                    }
                                    _context46.next = 9;
                                    return scope.propertyStats( );
                                case 9:
                                    _context46.next = 12;
                                    break;
                                case 11:
                                    scope.hideStats( );
                                case 12:
                                case "end":
                                    return _context46.stop( );
                            }
                        }
                    }, _callee39, this );
                } ) );

                function baseStats( ) {
                    return _baseStats.apply( this, arguments );
                }
                return baseStats;
            }( )
        }, {
            key: "propertyStats",
            value: function( ) {
                var _propertyStats = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee41( ) {
                    var propertyId, scope, nextProperty, previousProperty, showProperty, onButtonPress, _onButtonPress;
                    return _regeneratorRuntime( ).wrap( function _callee41$( _context48 ) {
                        while ( 1 ) {
                            switch ( _context48.prev = _context48.next ) {
                                case 0:
                                    _onButtonPress = function _onButtonPress3( ) {
                                        _onButtonPress = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee40( ) {
                                            var button;
                                            return _regeneratorRuntime( ).wrap( function _callee40$( _context47 ) {
                                                while ( 1 ) {
                                                    switch ( _context47.prev = _context47.next ) {
                                                        case 0:
                                                            _context47.next = 2;
                                                            return scope.awaitButtonPress( [ O_BUTTON, X_BUTTON, TRIANGLE_BUTTON, SQUARE_BUTTON ] );
                                                        case 2:
                                                            button = _context47.sent;
                                                            if ( !( button == O_BUTTON ) ) {
                                                                _context47.next = 9;
                                                                break;
                                                            }
                                                            _context47.next = 6;
                                                            return scope.propertyFunctions( propertyId );
                                                        case 6:
                                                            return _context47.abrupt( "return" );
                                                        case 9:
                                                            if ( !( button == SQUARE_BUTTON ) ) {
                                                                _context47.next = 14;
                                                                break;
                                                            }
                                                            scope.baseStats( );
                                                            return _context47.abrupt( "return" );
                                                        case 14:
                                                            if ( button == TRIANGLE_BUTTON ) {
                                                                nextProperty( );
                                                            } else if ( button == X_BUTTON ) {
                                                                previousProperty( );
                                                            }
                                                        case 15:
                                                            onButtonPress( );
                                                        case 16:
                                                        case "end":
                                                            return _context47.stop( );
                                                    }
                                                }
                                            }, _callee40 );
                                        } ) );
                                        return _onButtonPress.apply( this, arguments );
                                    };
                                    onButtonPress = function _onButtonPress2( ) {
                                        return _onButtonPress.apply( this, arguments );
                                    };
                                    showProperty = function _showProperty( ) {
                                        propertyId = MathUtils.euclideanModulo( propertyId, scope.properties.length );
                                        scope.body.innerText = "".concat( scope.properties[ propertyId ].getPropertyName( ), " > Circle\nBack > Square\nNext Property > Triangle\nPrevious Property > X" );
                                    };
                                    previousProperty = function _previousProperty( ) {
                                        propertyId--;
                                        showProperty( );
                                    };
                                    nextProperty = function _nextProperty( ) {
                                        propertyId++;
                                        showProperty( );
                                    };
                                    propertyId = 0;
                                    scope = this;
                                    scope.header.innerHTML = "Properties";
                                    onButtonPress( );
                                case 9:
                                case "end":
                                    return _context48.stop( );
                            }
                        }
                    }, _callee41, this );
                } ) );

                function propertyStats( ) {
                    return _propertyStats.apply( this, arguments );
                }
                return propertyStats;
            }( )
        }, {
            key: "propertyFunctions",
            value: function propertyFunctions( id ) {
                var _this55 = this;
                var prop = this.properties[ id ],
                    scope = this;
                return new Promise( function( resolve ) {
                    _this55.header.innerHTML = prop.getPropertyName( );
                    _this55.body.innerText = "Add House > Circle\n    Remove House > X\n    ".concat( prop.mortgaged ? "Unmortgage" : "Mortgage", " Property > Triangle\n    Back > Square" );

                    function onButtonPress( ) {
                        return _onButtonPress4.apply( this, arguments );
                    }

                    function _onButtonPress4( ) {
                        _onButtonPress4 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee42( ) {
                            var button;
                            return _regeneratorRuntime( ).wrap( function _callee42$( _context49 ) {
                                while ( 1 ) {
                                    switch ( _context49.prev = _context49.next ) {
                                        case 0:
                                            _context49.next = 2;
                                            return scope.awaitButtonPress( [ O_BUTTON, X_BUTTON, TRIANGLE_BUTTON, SQUARE_BUTTON ] );
                                        case 2:
                                            button = _context49.sent;
                                            if ( !( button == O_BUTTON ) ) {
                                                _context49.next = 7;
                                                break;
                                            }
                                            prop.addHouse( );
                                            _context49.next = 18;
                                            break;
                                        case 7:
                                            if ( !( button == X_BUTTON ) ) {
                                                _context49.next = 11;
                                                break;
                                            }
                                            prop.removeHouse( );
                                            _context49.next = 18;
                                            break;
                                        case 11:
                                            if ( !( button == TRIANGLE_BUTTON ) ) {
                                                _context49.next = 15;
                                                break;
                                            }
                                            prop.toggleMortgage( );
                                            _context49.next = 18;
                                            break;
                                        case 15:
                                            scope.propertyStats( );
                                            resolve( );
                                            return _context49.abrupt( "return" );
                                        case 18:
                                            new Promise( function( resolve ) {
                                                setTimeout( resolve, 500 );
                                            } ).then( function( ) {
                                                onButtonPress( );
                                            } );
                                        case 19:
                                        case "end":
                                            return _context49.stop( );
                                    }
                                }
                            }, _callee42 );
                        } ) );
                        return _onButtonPress4.apply( this, arguments );
                    }
                    onButtonPress( );
                } );
            }
        }, {
            key: "updateStats",
            value: function updateStats( ) {
                if ( this.money < 0 ) {
                    Globals.players.splice( Globals.players.indexOf( this ), 1 );
                }
            }
        }, {
            key: "hideStats",
            value: function hideStats( ) {
                this.statsPanel.style.display = "none";
            }
        }, {
            key: "showStats",
            value: function( ) {
                var _showStats = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee43( ) {
                    return _regeneratorRuntime( ).wrap( function _callee43$( _context50 ) {
                        while ( 1 ) {
                            switch ( _context50.prev = _context50.next ) {
                                case 0:
                                    this.statsPanel.style.display = "block";
                                    _context50.next = 3;
                                    return this.baseStats( );
                                case 3:
                                case "end":
                                    return _context50.stop( );
                            }
                        }
                    }, _callee43, this );
                } ) );

                function showStats( ) {
                    return _showStats.apply( this, arguments );
                }
                return showStats;
            }( )
        }, {
            key: "goToPosition",
            value: function goToPosition( position ) {
                var _this56 = this;
                var currentT = tilePositions[ this.currentPos ];
                var intT = tilePositions[ position ];
                var scope = this;
                if ( intT < currentT ) {
                    intT++;
                    if ( !this.inJail ) this.money += 200;
                }
                var camera = Globals.camera,
                    v0 = Globals.v0,
                    v1 = Globals.v1,
                    q0 = Globals.q0,
                    q1 = Globals.q1,
                    fromIObj = Globals.fromIObj,
                    toIObj = Globals.toIObj;
                var p = new Promise( function( resolve ) {
                    v1.set( 200, 100, 0 );
                    _this56.token.localToWorld( v1 );
                    v0.copy( camera.position );
                    camera.lookAt( 0, 0, 0 );
                    q0.copy( camera.quaternion );
                    camera.position.copy( v1 );
                    camera.lookAt( _this56.token.position );
                    q1.copy( camera.quaternion );
                    fromIObj.a = 0;
                    toIObj.a = 1;
                    var camToTokenTween = new Tween( fromIObj ).to( toIObj, 3000 ).onUpdate( function( _ref7 ) {
                        var a = _ref7.a;
                        camera.position.lerpVectors( v0, v1, a );
                        camera.quaternion.slerpQuaternions( q0, q1, a );
                    } ).onComplete( function( ) {
                        fromIObj.a = currentT;
                        toIObj.a = intT;
                        scope.token.add( camera );
                        camera.position.set( 200, 100, 0 );
                        camera.lookAt( scope.token.position );
                        tokenToSpaceTween.start( );
                    } ).easing( Easing.Quadratic.InOut );
                    var tokenToSpaceTween = new Tween( fromIObj ).to( toIObj, Math.log2( Number( intT > 1 ) * 40 + position - scope.currentPos ) * 1500 ).onUpdate( function( _ref8 ) {
                        var a = _ref8.a;
                        curve.getPointAt( a % 1, scope.token.position );
                        curve.getPointAt( ( a + 0.01 ) % 1, v0 );
                        scope.token.lookAt( v0 );
                    } ).onComplete( function( ) {
                        scope.currentPos = position;
                        scope.token.remove( camera );
                        scope.token.localToWorld( camera.position );
                        v0.copy( camera.position );
                        camera.lookAt( scope.token.position );
                        q0.copy( camera.quaternion );
                        v1.set( 0, 975, 0 );
                        q1.set( -Math.SQRT1_2, 0, 0, Math.SQRT1_2 );
                        fromIObj.a = 0;
                        toIObj.a = 1;
                        camToOrigTween.start( );
                    } ).delay( 500 ).easing( Easing.Sinusoidal.InOut );
                    var camToOrigTween = new Tween( fromIObj ).to( toIObj, 3000 ).onUpdate( function( _ref9 ) {
                        var a = _ref9.a;
                        camera.position.lerpVectors( v0, v1, a );
                        camera.quaternion.slerpQuaternions( q0, q1, a );
                    } ).delay( 500 ).easing( Easing.Quadratic.InOut ).onComplete( /*#__PURE__*/ _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee44( ) {
                        return _regeneratorRuntime( ).wrap( function _callee44$( _context51 ) {
                            while ( 1 ) {
                                switch ( _context51.prev = _context51.next ) {
                                    case 0:
                                        _context51.next = 2;
                                        return Globals.tiles[ scope.currentPos ].onLand( scope );
                                    case 2:
                                        resolve( scope );
                                    case 3:
                                    case "end":
                                        return _context51.stop( );
                                }
                            }
                        }, _callee44 );
                    } ) ) );
                    camToTokenTween.start( );
                } );
                return p;
            }
        }, {
            key: "moveForward",
            value: function moveForward( spaces ) {
                if ( this.inJail ) {
                    if ( spaces >= 11 ) {
                        this.inJail = false;
                    } else if ( this.jailTurns == 5 ) {
                        this.money -= 50;
                        this.inJail = false;
                    } else {
                        var _scope = this;
                        this.jailTurns++;
                        return new Promise( function( resolve ) {
                            resolve( _scope );
                        } );
                    }
                }
                return this.goToPosition( MathUtils.euclideanModulo( this.currentPos + spaces, 40 ) );
            }
        }, {
            key: "moveBackward",
            value: function moveBackward( spaces ) {
                return this.goToPosition( MathUtils.euclideanModulo( this.currentPos - spaces, 40 ) );
            }
        } ] );
        return Player;
    }( );
    /**
     * Records what objects are colliding with each other
     */
    /**
     * A 3x3 matrix.
     * Authored by {@link http://github.com/schteppe/ schteppe}
     */
    var Mat3 = /*#__PURE__*/ function( ) {
        /**
         * A vector of length 9, containing all matrix elements.
         */
        /**
         * @param elements A vector of length 9, containing all matrix elements.
         */
        function Mat3( elements ) {
            _classCallCheck( this, Mat3 );
            if ( elements === void 0 ) {
                elements = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
            }
            this.elements = elements;
        }
        /**
         * Sets the matrix to identity
         * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
         * @todo Create another function that immediately creates an identity matrix eg. `eye()`
         */
        _createClass( Mat3, [ {
            key: "identity",
            value: function identity( ) {
                var e = this.elements;
                e[ 0 ] = 1;
                e[ 1 ] = 0;
                e[ 2 ] = 0;
                e[ 3 ] = 0;
                e[ 4 ] = 1;
                e[ 5 ] = 0;
                e[ 6 ] = 0;
                e[ 7 ] = 0;
                e[ 8 ] = 1;
            }
            /**
             * Set all elements to zero
             */
        }, {
            key: "setZero",
            value: function setZero( ) {
                var e = this.elements;
                e[ 0 ] = 0;
                e[ 1 ] = 0;
                e[ 2 ] = 0;
                e[ 3 ] = 0;
                e[ 4 ] = 0;
                e[ 5 ] = 0;
                e[ 6 ] = 0;
                e[ 7 ] = 0;
                e[ 8 ] = 0;
            }
            /**
             * Sets the matrix diagonal elements from a Vec3
             */
        }, {
            key: "setTrace",
            value: function setTrace( vector ) {
                var e = this.elements;
                e[ 0 ] = vector.x;
                e[ 4 ] = vector.y;
                e[ 8 ] = vector.z;
            }
            /**
             * Gets the matrix diagonal elements
             */
        }, {
            key: "getTrace",
            value: function getTrace( target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var e = this.elements;
                target.x = e[ 0 ];
                target.y = e[ 4 ];
                target.z = e[ 8 ];
                return target;
            }
            /**
             * Matrix-Vector multiplication
             * @param v The vector to multiply with
             * @param target Optional, target to save the result in.
             */
        }, {
            key: "vmult",
            value: function vmult( v, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var e = this.elements;
                var x = v.x;
                var y = v.y;
                var z = v.z;
                target.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
                target.y = e[ 3 ] * x + e[ 4 ] * y + e[ 5 ] * z;
                target.z = e[ 6 ] * x + e[ 7 ] * y + e[ 8 ] * z;
                return target;
            }
            /**
             * Matrix-scalar multiplication
             */
        }, {
            key: "smult",
            value: function smult( s ) {
                for ( var _i285 = 0; _i285 < this.elements.length; _i285++ ) {
                    this.elements[ _i285 ] *= s;
                }
            }
            /**
             * Matrix multiplication
             * @param matrix Matrix to multiply with from left side.
             */
        }, {
            key: "mmult",
            value: function mmult( matrix, target ) {
                if ( target === void 0 ) {
                    target = new Mat3( );
                }
                var A = this.elements;
                var B = matrix.elements;
                var T = target.elements;
                var a11 = A[ 0 ],
                    a12 = A[ 1 ],
                    a13 = A[ 2 ],
                    a21 = A[ 3 ],
                    a22 = A[ 4 ],
                    a23 = A[ 5 ],
                    a31 = A[ 6 ],
                    a32 = A[ 7 ],
                    a33 = A[ 8 ];
                var b11 = B[ 0 ],
                    b12 = B[ 1 ],
                    b13 = B[ 2 ],
                    b21 = B[ 3 ],
                    b22 = B[ 4 ],
                    b23 = B[ 5 ],
                    b31 = B[ 6 ],
                    b32 = B[ 7 ],
                    b33 = B[ 8 ];
                T[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
                T[ 1 ] = a11 * b12 + a12 * b22 + a13 * b32;
                T[ 2 ] = a11 * b13 + a12 * b23 + a13 * b33;
                T[ 3 ] = a21 * b11 + a22 * b21 + a23 * b31;
                T[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
                T[ 5 ] = a21 * b13 + a22 * b23 + a23 * b33;
                T[ 6 ] = a31 * b11 + a32 * b21 + a33 * b31;
                T[ 7 ] = a31 * b12 + a32 * b22 + a33 * b32;
                T[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
                return target;
            }
            /**
             * Scale each column of the matrix
             */
        }, {
            key: "scale",
            value: function scale( vector, target ) {
                if ( target === void 0 ) {
                    target = new Mat3( );
                }
                var e = this.elements;
                var t = target.elements;
                for ( var _i286 = 0; _i286 !== 3; _i286++ ) {
                    t[ 3 * _i286 + 0 ] = vector.x * e[ 3 * _i286 + 0 ];
                    t[ 3 * _i286 + 1 ] = vector.y * e[ 3 * _i286 + 1 ];
                    t[ 3 * _i286 + 2 ] = vector.z * e[ 3 * _i286 + 2 ];
                }
                return target;
            }
            /**
             * Solve Ax=b
             * @param b The right hand side
             * @param target Optional. Target vector to save in.
             * @return The solution x
             * @todo should reuse arrays
             */
        }, {
            key: "solve",
            value: function solve( b, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                } // Construct equations
                var nr = 3; // num rows
                var nc = 4; // num cols
                var eqns = [ ];
                var i;
                var j;
                for ( i = 0; i < nr * nc; i++ ) {
                    eqns.push( 0 );
                }
                for ( i = 0; i < 3; i++ ) {
                    for ( j = 0; j < 3; j++ ) {
                        eqns[ i + nc * j ] = this.elements[ i + 3 * j ];
                    }
                }
                eqns[ 3 + 4 * 0 ] = b.x;
                eqns[ 3 + 4 * 1 ] = b.y;
                eqns[ 3 + 4 * 2 ] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination
                var n = 3;
                var k = n;
                var np;
                var kp = 4; // num rows
                var p;
                do {
                    i = k - n;
                    if ( eqns[ i + nc * i ] === 0 ) { // the pivot is null, swap lines
                        for ( j = i + 1; j < k; j++ ) {
                            if ( eqns[ i + nc * j ] !== 0 ) {
                                np = kp;
                                do { // do ligne( i ) = ligne( i ) + ligne( k )
                                    p = kp - np;
                                    eqns[ p + nc * i ] += eqns[ p + nc * j ];
                                } while ( --np );
                                break;
                            }
                        }
                    }
                    if ( eqns[ i + nc * i ] !== 0 ) {
                        for ( j = i + 1; j < k; j++ ) {
                            var multiplier = eqns[ i + nc * j ] / eqns[ i + nc * i ];
                            np = kp;
                            do { // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                                p = kp - np;
                                eqns[ p + nc * j ] = p <= i ? 0 : eqns[ p + nc * j ] - eqns[ p + nc * i ] * multiplier;
                            } while ( --np );
                        }
                    }
                } while ( --n ); // Get the solution
                target.z = eqns[ 2 * nc + 3 ] / eqns[ 2 * nc + 2 ];
                target.y = ( eqns[ 1 * nc + 3 ] - eqns[ 1 * nc + 2 ] * target.z ) / eqns[ 1 * nc + 1 ];
                target.x = ( eqns[ 0 * nc + 3 ] - eqns[ 0 * nc + 2 ] * target.z - eqns[ 0 * nc + 1 ] * target.y ) / eqns[ 0 * nc + 0 ];
                if ( isNaN( target.x ) || isNaN( target.y ) || isNaN( target.z ) || target.x === Infinity || target.y === Infinity || target.z === Infinity ) {
                    throw "Could not solve equation! Got x=[".concat( target.toString( ), "], b=[" ).concat( b.toString( ), "], A=[" ).concat( this.toString( ), "]" );
                }
                return target;
            }
            /**
             * Get an element in the matrix by index. Index starts at 0, not 1!!!
             * @param value If provided, the matrix element will be set to this value.
             */
        }, {
            key: "e",
            value: function e( row, column, value ) {
                if ( value === undefined ) {
                    return this.elements[ column + 3 * row ];
                } else { // Set value
                    this.elements[ column + 3 * row ] = value;
                }
            }
            /**
             * Copy another matrix into this matrix object.
             */
        }, {
            key: "copy",
            value: function copy( matrix ) {
                for ( var _i287 = 0; _i287 < matrix.elements.length; _i287++ ) {
                    this.elements[ _i287 ] = matrix.elements[ _i287 ];
                }
                return this;
            }
            /**
             * Returns a string representation of the matrix.
             */
        }, {
            key: "toString",
            value: function toString( ) {
                var r = '';
                var sep = ',';
                for ( var _i288 = 0; _i288 < 9; _i288++ ) {
                    r += this.elements[ _i288 ] + sep;
                }
                return r;
            }
            /**
             * reverse the matrix
             * @param target Target matrix to save in.
             * @return The solution x
             */
        }, {
            key: "reverse",
            value: function reverse( target ) {
                if ( target === void 0 ) {
                    target = new Mat3( );
                } // Construct equations
                var nr = 3; // num rows
                var nc = 6; // num cols
                var eqns = reverse_eqns;
                var i;
                var j;
                for ( i = 0; i < 3; i++ ) {
                    for ( j = 0; j < 3; j++ ) {
                        eqns[ i + nc * j ] = this.elements[ i + 3 * j ];
                    }
                }
                eqns[ 3 + 6 * 0 ] = 1;
                eqns[ 3 + 6 * 1 ] = 0;
                eqns[ 3 + 6 * 2 ] = 0;
                eqns[ 4 + 6 * 0 ] = 0;
                eqns[ 4 + 6 * 1 ] = 1;
                eqns[ 4 + 6 * 2 ] = 0;
                eqns[ 5 + 6 * 0 ] = 0;
                eqns[ 5 + 6 * 1 ] = 0;
                eqns[ 5 + 6 * 2 ] = 1; // Compute right upper triangular version of the matrix - Gauss elimination
                var n = 3;
                var k = n;
                var np;
                var kp = nc; // num rows
                var p;
                do {
                    i = k - n;
                    if ( eqns[ i + nc * i ] === 0 ) { // the pivot is null, swap lines
                        for ( j = i + 1; j < k; j++ ) {
                            if ( eqns[ i + nc * j ] !== 0 ) {
                                np = kp;
                                do { // do line( i ) = line( i ) + line( k )
                                    p = kp - np;
                                    eqns[ p + nc * i ] += eqns[ p + nc * j ];
                                } while ( --np );
                                break;
                            }
                        }
                    }
                    if ( eqns[ i + nc * i ] !== 0 ) {
                        for ( j = i + 1; j < k; j++ ) {
                            var multiplier = eqns[ i + nc * j ] / eqns[ i + nc * i ];
                            np = kp;
                            do { // do line( k ) = line( k ) - multiplier * line( i )
                                p = kp - np;
                                eqns[ p + nc * j ] = p <= i ? 0 : eqns[ p + nc * j ] - eqns[ p + nc * i ] * multiplier;
                            } while ( --np );
                        }
                    }
                } while ( --n ); // eliminate the upper left triangle of the matrix
                i = 2;
                do {
                    j = i - 1;
                    do {
                        var _multiplier = eqns[ i + nc * j ] / eqns[ i + nc * i ];
                        np = nc;
                        do {
                            p = nc - np;
                            eqns[ p + nc * j ] = eqns[ p + nc * j ] - eqns[ p + nc * i ] * _multiplier;
                        } while ( --np );
                    } while ( j-- );
                } while ( --i ); // operations on the diagonal
                i = 2;
                do {
                    var _multiplier2 = 1 / eqns[ i + nc * i ];
                    np = nc;
                    do {
                        p = nc - np;
                        eqns[ p + nc * i ] = eqns[ p + nc * i ] * _multiplier2;
                    } while ( --np );
                } while ( i-- );
                i = 2;
                do {
                    j = 2;
                    do {
                        p = eqns[ nr + j + nc * i ];
                        if ( isNaN( p ) || p === Infinity ) {
                            throw "Could not reverse! A=[".concat( this.toString( ), "]" );
                        }
                        target.e( i, j, p );
                    } while ( j-- );
                } while ( i-- );
                return target;
            }
            /**
             * Set the matrix from a quaterion
             */
        }, {
            key: "setRotationFromQuaternion",
            value: function setRotationFromQuaternion( q ) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                var e = this.elements;
                e[ 3 * 0 + 0 ] = 1 - ( yy + zz );
                e[ 3 * 0 + 1 ] = xy - wz;
                e[ 3 * 0 + 2 ] = xz + wy;
                e[ 3 * 1 + 0 ] = xy + wz;
                e[ 3 * 1 + 1 ] = 1 - ( xx + zz );
                e[ 3 * 1 + 2 ] = yz - wx;
                e[ 3 * 2 + 0 ] = xz - wy;
                e[ 3 * 2 + 1 ] = yz + wx;
                e[ 3 * 2 + 2 ] = 1 - ( xx + yy );
                return this;
            }
            /**
             * Transpose the matrix
             * @param target Optional. Where to store the result.
             * @return The target Mat3, or a new Mat3 if target was omitted.
             */
        }, {
            key: "transpose",
            value: function transpose( target ) {
                if ( target === void 0 ) {
                    target = new Mat3( );
                }
                var M = this.elements;
                var T = target.elements;
                var tmp; //Set diagonals
                T[ 0 ] = M[ 0 ];
                T[ 4 ] = M[ 4 ];
                T[ 8 ] = M[ 8 ];
                tmp = M[ 1 ];
                T[ 1 ] = M[ 3 ];
                T[ 3 ] = tmp;
                tmp = M[ 2 ];
                T[ 2 ] = M[ 6 ];
                T[ 6 ] = tmp;
                tmp = M[ 5 ];
                T[ 5 ] = M[ 7 ];
                T[ 7 ] = tmp;
                return target;
            }
        } ] );
        return Mat3;
    }( );
    var reverse_eqns = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    /**
     * 3-dimensional vector
     * @example
     *     const v = new Vec3(1, 2, 3)
     *     console.log('x=' + v.x) // x=1
     */
    var Vec3 = /*#__PURE__*/ function( ) {
        function Vec3( x, y, z ) {
            _classCallCheck( this, Vec3 );
            if ( x === void 0 ) {
                x = 0.0;
            }
            if ( y === void 0 ) {
                y = 0.0;
            }
            if ( z === void 0 ) {
                z = 0.0;
            }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        /**
         * Vector cross product
         * @param target Optional target to save in.
         */
        _createClass( Vec3, [ {
            key: "cross",
            value: function cross( vector, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var vx = vector.x;
                var vy = vector.y;
                var vz = vector.z;
                var x = this.x;
                var y = this.y;
                var z = this.z;
                target.x = y * vz - z * vy;
                target.y = z * vx - x * vz;
                target.z = x * vy - y * vx;
                return target;
            }
            /**
             * Set the vectors' 3 elements
             */
        }, {
            key: "set",
            value: function set( x, y, z ) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            /**
             * Set all components of the vector to zero.
             */
        }, {
            key: "setZero",
            value: function setZero( ) {
                this.x = this.y = this.z = 0;
            }
            /**
             * Vector addition
             */
        }, {
            key: "vadd",
            value: function vadd( vector, target ) {
                if ( target ) {
                    target.x = vector.x + this.x;
                    target.y = vector.y + this.y;
                    target.z = vector.z + this.z;
                } else {
                    return new Vec3( this.x + vector.x, this.y + vector.y, this.z + vector.z );
                }
            }
            /**
             * Vector subtraction
             * @param target Optional target to save in.
             */
        }, {
            key: "vsub",
            value: function vsub( vector, target ) {
                if ( target ) {
                    target.x = this.x - vector.x;
                    target.y = this.y - vector.y;
                    target.z = this.z - vector.z;
                } else {
                    return new Vec3( this.x - vector.x, this.y - vector.y, this.z - vector.z );
                }
            }
            /**
             * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
             *
             * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
             */
        }, {
            key: "crossmat",
            value: function crossmat( ) {
                return new Mat3( [ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ] );
            }
            /**
             * Normalize the vector. Note that this changes the values in the vector.
             * @return Returns the norm of the vector
             */
        }, {
            key: "normalize",
            value: function normalize( ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var n = Math.sqrt( x * x + y * y + z * z );
                if ( n > 0.0 ) {
                    var invN = 1 / n;
                    this.x *= invN;
                    this.y *= invN;
                    this.z *= invN;
                } else { // Make something up
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                }
                return n;
            }
            /**
             * Get the version of this vector that is of length 1.
             * @param target Optional target to save in
             * @return Returns the unit vector
             */
        }, {
            key: "unit",
            value: function unit( target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var ninv = Math.sqrt( x * x + y * y + z * z );
                if ( ninv > 0.0 ) {
                    ninv = 1.0 / ninv;
                    target.x = x * ninv;
                    target.y = y * ninv;
                    target.z = z * ninv;
                } else {
                    target.x = 1;
                    target.y = 0;
                    target.z = 0;
                }
                return target;
            }
            /**
             * Get the length of the vector
             */
        }, {
            key: "length",
            value: function length( ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                return Math.sqrt( x * x + y * y + z * z );
            }
            /**
             * Get the squared length of the vector.
             */
        }, {
            key: "lengthSquared",
            value: function lengthSquared( ) {
                return this.dot( this );
            }
            /**
             * Get distance from this point to another point
             */
        }, {
            key: "distanceTo",
            value: function distanceTo( p ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var px = p.x;
                var py = p.y;
                var pz = p.z;
                return Math.sqrt( ( px - x ) * ( px - x ) + ( py - y ) * ( py - y ) + ( pz - z ) * ( pz - z ) );
            }
            /**
             * Get squared distance from this point to another point
             */
        }, {
            key: "distanceSquared",
            value: function distanceSquared( p ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var px = p.x;
                var py = p.y;
                var pz = p.z;
                return ( px - x ) * ( px - x ) + ( py - y ) * ( py - y ) + ( pz - z ) * ( pz - z );
            }
            /**
             * Multiply all the components of the vector with a scalar.
             * @param target The vector to save the result in.
             */
        }, {
            key: "scale",
            value: function scale( scalar, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var x = this.x;
                var y = this.y;
                var z = this.z;
                target.x = scalar * x;
                target.y = scalar * y;
                target.z = scalar * z;
                return target;
            }
            /**
             * Multiply the vector with an other vector, component-wise.
             * @param target The vector to save the result in.
             */
        }, {
            key: "vmul",
            value: function vmul( vector, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                target.x = vector.x * this.x;
                target.y = vector.y * this.y;
                target.z = vector.z * this.z;
                return target;
            }
            /**
             * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
             * @param target The vector to save the result in.
             */
        }, {
            key: "addScaledVector",
            value: function addScaledVector( scalar, vector, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                target.x = this.x + scalar * vector.x;
                target.y = this.y + scalar * vector.y;
                target.z = this.z + scalar * vector.z;
                return target;
            }
            /**
             * Calculate dot product
             * @param vector
             */
        }, {
            key: "dot",
            value: function dot( vector ) {
                return this.x * vector.x + this.y * vector.y + this.z * vector.z;
            }
        }, {
            key: "isZero",
            value: function isZero( ) {
                return this.x === 0 && this.y === 0 && this.z === 0;
            }
            /**
             * Make the vector point in the opposite direction.
             * @param target Optional target to save in
             */
        }, {
            key: "negate",
            value: function negate( target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                return target;
            }
            /**
             * Compute two artificial tangents to the vector
             * @param t1 Vector object to save the first tangent in
             * @param t2 Vector object to save the second tangent in
             */
        }, {
            key: "tangents",
            value: function tangents( t1, t2 ) {
                var norm = this.length( );
                if ( norm > 0.0 ) {
                    var n = Vec3_tangents_n;
                    var inorm = 1 / norm;
                    n.set( this.x * inorm, this.y * inorm, this.z * inorm );
                    var randVec = Vec3_tangents_randVec;
                    if ( Math.abs( n.x ) < 0.9 ) {
                        randVec.set( 1, 0, 0 );
                        n.cross( randVec, t1 );
                    } else {
                        randVec.set( 0, 1, 0 );
                        n.cross( randVec, t1 );
                    }
                    n.cross( t1, t2 );
                } else { // The normal length is zero, make something up
                    t1.set( 1, 0, 0 );
                    t2.set( 0, 1, 0 );
                }
            }
            /**
             * Converts to a more readable format
             */
        }, {
            key: "toString",
            value: function toString( ) {
                return "".concat( this.x, "," ).concat( this.y, "," ).concat( this.z );
            }
            /**
             * Converts to an array
             */
        }, {
            key: "toArray",
            value: function toArray( ) {
                return [ this.x, this.y, this.z ];
            }
            /**
             * Copies value of source to this vector.
             */
        }, {
            key: "copy",
            value: function copy( vector ) {
                this.x = vector.x;
                this.y = vector.y;
                this.z = vector.z;
                return this;
            }
            /**
             * Do a linear interpolation between two vectors
             * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
             */
        }, {
            key: "lerp",
            value: function lerp( vector, t, target ) {
                var x = this.x;
                var y = this.y;
                var z = this.z;
                target.x = x + ( vector.x - x ) * t;
                target.y = y + ( vector.y - y ) * t;
                target.z = z + ( vector.z - z ) * t;
            }
            /**
             * Check if a vector equals is almost equal to another one.
             */
        }, {
            key: "almostEquals",
            value: function almostEquals( vector, precision ) {
                if ( precision === void 0 ) {
                    precision = 1e-6;
                }
                if ( Math.abs( this.x - vector.x ) > precision || Math.abs( this.y - vector.y ) > precision || Math.abs( this.z - vector.z ) > precision ) {
                    return false;
                }
                return true;
            }
            /**
             * Check if a vector is almost zero
             */
        }, {
            key: "almostZero",
            value: function almostZero( precision ) {
                if ( precision === void 0 ) {
                    precision = 1e-6;
                }
                if ( Math.abs( this.x ) > precision || Math.abs( this.y ) > precision || Math.abs( this.z ) > precision ) {
                    return false;
                }
                return true;
            }
            /**
             * Check if the vector is anti-parallel to another vector.
             * @param precision Set to zero for exact comparisons
             */
        }, {
            key: "isAntiparallelTo",
            value: function isAntiparallelTo( vector, precision ) {
                this.negate( antip_neg );
                return antip_neg.almostEquals( vector, precision );
            }
            /**
             * Clone the vector
             */
        }, {
            key: "clone",
            value: function clone( ) {
                return new Vec3( this.x, this.y, this.z );
            }
        } ] );
        return Vec3;
    }( );
    Vec3.ZERO = new Vec3( 0, 0, 0 );
    Vec3.UNIT_X = new Vec3( 1, 0, 0 );
    Vec3.UNIT_Y = new Vec3( 0, 1, 0 );
    Vec3.UNIT_Z = new Vec3( 0, 0, 1 );
    var Vec3_tangents_n = new Vec3( );
    var Vec3_tangents_randVec = new Vec3( );
    var antip_neg = new Vec3( );
    /**
     * Axis aligned bounding box class.
     */
    var AABB = /*#__PURE__*/ function( ) {
        /**
         * The lower bound of the bounding box
         */
        /**
         * The upper bound of the bounding box
         */
        function AABB( options ) {
            _classCallCheck( this, AABB );
            if ( options === void 0 ) {
                options = {};
            }
            this.lowerBound = new Vec3( );
            this.upperBound = new Vec3( );
            if ( options.lowerBound ) {
                this.lowerBound.copy( options.lowerBound );
            }
            if ( options.upperBound ) {
                this.upperBound.copy( options.upperBound );
            }
        }
        /**
         * Set the AABB bounds from a set of points.
         * @param points An array of Vec3's.
         * @return The self object
         */
        _createClass( AABB, [ {
            key: "setFromPoints",
            value: function setFromPoints( points, position, quaternion, skinSize ) {
                var l = this.lowerBound;
                var u = this.upperBound;
                var q = quaternion; // Set to the first point
                l.copy( points[ 0 ] );
                if ( q ) {
                    q.vmult( l, l );
                }
                u.copy( l );
                for ( var _i289 = 1; _i289 < points.length; _i289++ ) {
                    var p = points[ _i289 ];
                    if ( q ) {
                        q.vmult( p, tmp$1 );
                        p = tmp$1;
                    }
                    if ( p.x > u.x ) {
                        u.x = p.x;
                    }
                    if ( p.x < l.x ) {
                        l.x = p.x;
                    }
                    if ( p.y > u.y ) {
                        u.y = p.y;
                    }
                    if ( p.y < l.y ) {
                        l.y = p.y;
                    }
                    if ( p.z > u.z ) {
                        u.z = p.z;
                    }
                    if ( p.z < l.z ) {
                        l.z = p.z;
                    }
                } // Add offset
                if ( position ) {
                    position.vadd( l, l );
                    position.vadd( u, u );
                }
                if ( skinSize ) {
                    l.x -= skinSize;
                    l.y -= skinSize;
                    l.z -= skinSize;
                    u.x += skinSize;
                    u.y += skinSize;
                    u.z += skinSize;
                }
                return this;
            }
            /**
             * Copy bounds from an AABB to this AABB
             * @param aabb Source to copy from
             * @return The this object, for chainability
             */
        }, {
            key: "copy",
            value: function copy( aabb ) {
                this.lowerBound.copy( aabb.lowerBound );
                this.upperBound.copy( aabb.upperBound );
                return this;
            }
            /**
             * Clone an AABB
             */
        }, {
            key: "clone",
            value: function clone( ) {
                return new AABB( ).copy( this );
            }
            /**
             * Extend this AABB so that it covers the given AABB too.
             */
        }, {
            key: "extend",
            value: function extend( aabb ) {
                this.lowerBound.x = Math.min( this.lowerBound.x, aabb.lowerBound.x );
                this.upperBound.x = Math.max( this.upperBound.x, aabb.upperBound.x );
                this.lowerBound.y = Math.min( this.lowerBound.y, aabb.lowerBound.y );
                this.upperBound.y = Math.max( this.upperBound.y, aabb.upperBound.y );
                this.lowerBound.z = Math.min( this.lowerBound.z, aabb.lowerBound.z );
                this.upperBound.z = Math.max( this.upperBound.z, aabb.upperBound.z );
            }
            /**
             * Returns true if the given AABB overlaps this AABB.
             */
        }, {
            key: "overlaps",
            value: function overlaps( aabb ) {
                var l1 = this.lowerBound;
                var u1 = this.upperBound;
                var l2 = aabb.lowerBound;
                var u2 = aabb.upperBound; //      l2        u2
                //      |---------|
                // |--------|
                // l1       u1
                var overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
                var overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
                var overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
                return overlapsX && overlapsY && overlapsZ;
            } // Mostly for debugging
        }, {
            key: "volume",
            value: function volume( ) {
                var l = this.lowerBound;
                var u = this.upperBound;
                return ( u.x - l.x ) * ( u.y - l.y ) * ( u.z - l.z );
            }
            /**
             * Returns true if the given AABB is fully contained in this AABB.
             */
        }, {
            key: "contains",
            value: function contains( aabb ) {
                var l1 = this.lowerBound;
                var u1 = this.upperBound;
                var l2 = aabb.lowerBound;
                var u2 = aabb.upperBound; //      l2        u2
                //      |---------|
                // |---------------|
                // l1              u1
                return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
            }
        }, {
            key: "getCorners",
            value: function getCorners( a, b, c, d, e, f, g, h ) {
                var l = this.lowerBound;
                var u = this.upperBound;
                a.copy( l );
                b.set( u.x, l.y, l.z );
                c.set( u.x, u.y, l.z );
                d.set( l.x, u.y, u.z );
                e.set( u.x, l.y, u.z );
                f.set( l.x, u.y, l.z );
                g.set( l.x, l.y, u.z );
                h.copy( u );
            }
            /**
             * Get the representation of an AABB in another frame.
             * @return The "target" AABB object.
             */
        }, {
            key: "toLocalFrame",
            value: function toLocalFrame( frame, target ) {
                var corners = transformIntoFrame_corners;
                var a = corners[ 0 ];
                var b = corners[ 1 ];
                var c = corners[ 2 ];
                var d = corners[ 3 ];
                var e = corners[ 4 ];
                var f = corners[ 5 ];
                var g = corners[ 6 ];
                var h = corners[ 7 ]; // Get corners in current frame
                this.getCorners( a, b, c, d, e, f, g, h ); // Transform them to new local frame
                for ( var _i290 = 0; _i290 !== 8; _i290++ ) {
                    var corner = corners[ _i290 ];
                    frame.pointToLocal( corner, corner );
                }
                return target.setFromPoints( corners );
            }
            /**
             * Get the representation of an AABB in the global frame.
             * @return The "target" AABB object.
             */
        }, {
            key: "toWorldFrame",
            value: function toWorldFrame( frame, target ) {
                var corners = transformIntoFrame_corners;
                var a = corners[ 0 ];
                var b = corners[ 1 ];
                var c = corners[ 2 ];
                var d = corners[ 3 ];
                var e = corners[ 4 ];
                var f = corners[ 5 ];
                var g = corners[ 6 ];
                var h = corners[ 7 ]; // Get corners in current frame
                this.getCorners( a, b, c, d, e, f, g, h ); // Transform them to new local frame
                for ( var _i291 = 0; _i291 !== 8; _i291++ ) {
                    var corner = corners[ _i291 ];
                    frame.pointToWorld( corner, corner );
                }
                return target.setFromPoints( corners );
            }
            /**
             * Check if the AABB is hit by a ray.
             */
        }, {
            key: "overlapsRay",
            value: function overlapsRay( ray ) {
                var direction = ray.direction,
                    from = ray.from; // const t = 0
                // ray.direction is unit direction vector of ray
                var dirFracX = 1 / direction.x;
                var dirFracY = 1 / direction.y;
                var dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
                var t1 = ( this.lowerBound.x - from.x ) * dirFracX;
                var t2 = ( this.upperBound.x - from.x ) * dirFracX;
                var t3 = ( this.lowerBound.y - from.y ) * dirFracY;
                var t4 = ( this.upperBound.y - from.y ) * dirFracY;
                var t5 = ( this.lowerBound.z - from.z ) * dirFracZ;
                var t6 = ( this.upperBound.z - from.z ) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
                // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
                var tmin = Math.max( Math.max( Math.min( t1, t2 ), Math.min( t3, t4 ) ), Math.min( t5, t6 ) );
                var tmax = Math.min( Math.min( Math.max( t1, t2 ), Math.max( t3, t4 ) ), Math.max( t5, t6 ) ); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
                if ( tmax < 0 ) { //t = tmax;
                    return false;
                } // if tmin > tmax, ray doesn't intersect AABB
                if ( tmin > tmax ) { //t = tmax;
                    return false;
                }
                return true;
            }
        } ] );
        return AABB;
    }( );
    var tmp$1 = new Vec3( );
    var transformIntoFrame_corners = [ new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ) ];
    /**
     * Collision "matrix".
     * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
     */
    var ArrayCollisionMatrix = /*#__PURE__*/ function( ) {
        /**
         * The matrix storage.
         */
        function ArrayCollisionMatrix( ) {
            _classCallCheck( this, ArrayCollisionMatrix );
            this.matrix = [ ];
        }
        /**
         * Get an element
         */
        _createClass( ArrayCollisionMatrix, [ {
            key: "get",
            value: function get( bi, bj ) {
                var i = bi.index;
                var j = bj.index;
                if ( j > i ) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                return this.matrix[ ( i * ( i + 1 ) >> 1 ) + j - 1 ];
            }
            /**
             * Set an element
             */
        }, {
            key: "set",
            value: function set( bi, bj, value ) {
                var i = bi.index;
                var j = bj.index;
                if ( j > i ) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                this.matrix[ ( i * ( i + 1 ) >> 1 ) + j - 1 ] = value ? 1 : 0;
            }
            /**
             * Sets all elements to zero
             */
        }, {
            key: "reset",
            value: function reset( ) {
                for ( var _i292 = 0, l = this.matrix.length; _i292 !== l; _i292++ ) {
                    this.matrix[ _i292 ] = 0;
                }
            }
            /**
             * Sets the max number of objects
             */
        }, {
            key: "setNumObjects",
            value: function setNumObjects( n ) {
                this.matrix.length = n * ( n - 1 ) >> 1;
            }
        } ] );
        return ArrayCollisionMatrix;
    }( );
    /**
     * Base class for objects that dispatches events.
     */
    var EventTarget = /*#__PURE__*/ function( ) {
        function EventTarget( ) {
            _classCallCheck( this, EventTarget );
        }
        _createClass( EventTarget, [ {
            key: "addEventListener",
            value:
                /**
                 * Add an event listener
                 * @return The self object, for chainability.
                 */
                function addEventListener( type, listener ) {
                    if ( this._listeners === undefined ) {
                        this._listeners = {};
                    }
                    var listeners = this._listeners;
                    if ( listeners[ type ] === undefined ) {
                        listeners[ type ] = [ ];
                    }
                    if ( !listeners[ type ].includes( listener ) ) {
                        listeners[ type ].push( listener );
                    }
                    return this;
                }
            /**
             * Check if an event listener is added
             */
        }, {
            key: "hasEventListener",
            value: function hasEventListener( type, listener ) {
                if ( this._listeners === undefined ) {
                    return false;
                }
                var listeners = this._listeners;
                if ( listeners[ type ] !== undefined && listeners[ type ].includes( listener ) ) {
                    return true;
                }
                return false;
            }
            /**
             * Check if any event listener of the given type is added
             */
        }, {
            key: "hasAnyEventListener",
            value: function hasAnyEventListener( type ) {
                if ( this._listeners === undefined ) {
                    return false;
                }
                var listeners = this._listeners;
                return listeners[ type ] !== undefined;
            }
            /**
             * Remove an event listener
             * @return The self object, for chainability.
             */
        }, {
            key: "removeEventListener",
            value: function removeEventListener( type, listener ) {
                if ( this._listeners === undefined ) {
                    return this;
                }
                var listeners = this._listeners;
                if ( listeners[ type ] === undefined ) {
                    return this;
                }
                var index = listeners[ type ].indexOf( listener );
                if ( index !== -1 ) {
                    listeners[ type ].splice( index, 1 );
                }
                return this;
            }
            /**
             * Emit an event.
             * @return The self object, for chainability.
             */
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent( event ) {
                if ( this._listeners === undefined ) {
                    return this;
                }
                var listeners = this._listeners;
                var listenerArray = listeners[ event.type ];
                if ( listenerArray !== undefined ) {
                    event.target = this;
                    for ( var _i293 = 0, l = listenerArray.length; _i293 < l; _i293++ ) {
                        listenerArray[ _i293 ].call( this, event );
                    }
                }
                return this;
            }
        } ] );
        return EventTarget;
    }( );
    /**
     * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
     * @param x Multiplier of the imaginary basis vector i.
     * @param y Multiplier of the imaginary basis vector j.
     * @param z Multiplier of the imaginary basis vector k.
     * @param w Multiplier of the real part.
     * @see http://en.wikipedia.org/wiki/Quaternion
     */
    var Quaternion = /*#__PURE__*/ function( ) {
        function Quaternion( x, y, z, w ) {
            _classCallCheck( this, Quaternion );
            if ( x === void 0 ) {
                x = 0;
            }
            if ( y === void 0 ) {
                y = 0;
            }
            if ( z === void 0 ) {
                z = 0;
            }
            if ( w === void 0 ) {
                w = 1;
            }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        /**
         * Set the value of the quaternion.
         */
        _createClass( Quaternion, [ {
            key: "set",
            value: function set( x, y, z, w ) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
            }
            /**
             * Convert to a readable format
             * @return "x,y,z,w"
             */
        }, {
            key: "toString",
            value: function toString( ) {
                return "".concat( this.x, "," ).concat( this.y, "," ).concat( this.z, "," ).concat( this.w );
            }
            /**
             * Convert to an Array
             * @return [x, y, z, w]
             */
        }, {
            key: "toArray",
            value: function toArray( ) {
                return [ this.x, this.y, this.z, this.w ];
            }
            /**
             * Set the quaternion components given an axis and an angle in radians.
             */
        }, {
            key: "setFromAxisAngle",
            value: function setFromAxisAngle( vector, angle ) {
                var s = Math.sin( angle * 0.5 );
                this.x = vector.x * s;
                this.y = vector.y * s;
                this.z = vector.z * s;
                this.w = Math.cos( angle * 0.5 );
                return this;
            }
            /**
             * Converts the quaternion to [ axis, angle ] representation.
             * @param targetAxis A vector object to reuse for storing the axis.
             * @return An array, first element is the axis and the second is the angle in radians.
             */
        }, {
            key: "toAxisAngle",
            value: function toAxisAngle( targetAxis ) {
                if ( targetAxis === void 0 ) {
                    targetAxis = new Vec3( );
                }
                this.normalize( ); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
                var angle = 2 * Math.acos( this.w );
                var s = Math.sqrt( 1 - this.w * this.w ); // assuming quaternion normalised then w is less than 1, so term always positive.
                if ( s < 0.001 ) { // test to avoid divide by zero, s is always positive due to sqrt
                    // if s close to zero then direction of axis not important
                    targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
                    targetAxis.y = this.y;
                    targetAxis.z = this.z;
                } else {
                    targetAxis.x = this.x / s; // normalise axis
                    targetAxis.y = this.y / s;
                    targetAxis.z = this.z / s;
                }
                return [ targetAxis, angle ];
            }
            /**
             * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
             */
        }, {
            key: "setFromVectors",
            value: function setFromVectors( u, v ) {
                if ( u.isAntiparallelTo( v ) ) {
                    var t1 = sfv_t1;
                    var t2 = sfv_t2;
                    u.tangents( t1, t2 );
                    this.setFromAxisAngle( t1, Math.PI );
                } else {
                    var _a12 = u.cross( v );
                    this.x = _a12.x;
                    this.y = _a12.y;
                    this.z = _a12.z;
                    this.w = Math.sqrt( Math.pow( u.length( ), 2 ) * Math.pow( v.length( ), 2 ) ) + u.dot( v );
                    this.normalize( );
                }
                return this;
            }
            /**
             * Multiply the quaternion with an other quaternion.
             */
        }, {
            key: "mult",
            value: function mult( quat, target ) {
                if ( target === void 0 ) {
                    target = new Quaternion( );
                }
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bx = quat.x;
                var by = quat.y;
                var bz = quat.z;
                var bw = quat.w;
                target.x = ax * bw + aw * bx + ay * bz - az * by;
                target.y = ay * bw + aw * by + az * bx - ax * bz;
                target.z = az * bw + aw * bz + ax * by - ay * bx;
                target.w = aw * bw - ax * bx - ay * by - az * bz;
                return target;
            }
            /**
             * Get the inverse quaternion rotation.
             */
        }, {
            key: "inverse",
            value: function inverse( target ) {
                if ( target === void 0 ) {
                    target = new Quaternion( );
                }
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                this.conjugate( target );
                var inorm2 = 1 / ( x * x + y * y + z * z + w * w );
                target.x *= inorm2;
                target.y *= inorm2;
                target.z *= inorm2;
                target.w *= inorm2;
                return target;
            }
            /**
             * Get the quaternion conjugate
             */
        }, {
            key: "conjugate",
            value: function conjugate( target ) {
                if ( target === void 0 ) {
                    target = new Quaternion( );
                }
                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                target.w = this.w;
                return target;
            }
            /**
             * Normalize the quaternion. Note that this changes the values of the quaternion.
             */
        }, {
            key: "normalize",
            value: function normalize( ) {
                var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
                if ( l === 0 ) {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 0;
                } else {
                    l = 1 / l;
                    this.x *= l;
                    this.y *= l;
                    this.z *= l;
                    this.w *= l;
                }
                return this;
            }
            /**
             * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
             * @author unphased, https://github.com/unphased
             */
        }, {
            key: "normalizeFast",
            value: function normalizeFast( ) {
                var f = ( 3.0 - ( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ) ) / 2.0;
                if ( f === 0 ) {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 0;
                } else {
                    this.x *= f;
                    this.y *= f;
                    this.z *= f;
                    this.w *= f;
                }
                return this;
            }
            /**
             * Multiply the quaternion by a vector
             */
        }, {
            key: "vmult",
            value: function vmult( v, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var x = v.x;
                var y = v.y;
                var z = v.z;
                var qx = this.x;
                var qy = this.y;
                var qz = this.z;
                var qw = this.w; // q*v
                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z;
                target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return target;
            }
            /**
             * Copies value of source to this quaternion.
             * @return this
             */
        }, {
            key: "copy",
            value: function copy( quat ) {
                this.x = quat.x;
                this.y = quat.y;
                this.z = quat.z;
                this.w = quat.w;
                return this;
            }
            /**
             * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
             * @param order Three-character string, defaults to "YZX"
             */
        }, {
            key: "toEuler",
            value: function toEuler( target, order ) {
                if ( order === void 0 ) {
                    order = 'YZX';
                }
                var heading;
                var attitude;
                var bank;
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w = this.w;
                switch ( order ) {
                    case 'YZX':
                        var test = x * y + z * w;
                        if ( test > 0.499 ) { // singularity at north pole
                            heading = 2 * Math.atan2( x, w );
                            attitude = Math.PI / 2;
                            bank = 0;
                        }
                        if ( test < -0.499 ) { // singularity at south pole
                            heading = -2 * Math.atan2( x, w );
                            attitude = -Math.PI / 2;
                            bank = 0;
                        }
                        if ( heading === undefined ) {
                            var sqx = x * x;
                            var sqy = y * y;
                            var sqz = z * z;
                            heading = Math.atan2( 2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz ); // Heading
                            attitude = Math.asin( 2 * test ); // attitude
                            bank = Math.atan2( 2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz ); // bank
                        }
                        break;
                    default:
                        throw new Error( "Euler order ".concat( order, " not supported yet." ) );
                }
                target.y = heading;
                target.z = attitude;
                target.x = bank;
            }
            /**
             * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
             *
             * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
             */
        }, {
            key: "setFromEuler",
            value: function setFromEuler( x, y, z, order ) {
                if ( order === void 0 ) {
                    order = 'XYZ';
                }
                var c1 = Math.cos( x / 2 );
                var c2 = Math.cos( y / 2 );
                var c3 = Math.cos( z / 2 );
                var s1 = Math.sin( x / 2 );
                var s2 = Math.sin( y / 2 );
                var s3 = Math.sin( z / 2 );
                if ( order === 'XYZ' ) {
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if ( order === 'YXZ' ) {
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if ( order === 'ZXY' ) {
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if ( order === 'ZYX' ) {
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if ( order === 'YZX' ) {
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if ( order === 'XZY' ) {
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                }
                return this;
            }
        }, {
            key: "clone",
            value: function clone( ) {
                return new Quaternion( this.x, this.y, this.z, this.w );
            }
            /**
             * Performs a spherical linear interpolation between two quat
             *
             * @param toQuat second operand
             * @param t interpolation amount between the self quaternion and toQuat
             * @param target A quaternion to store the result in. If not provided, a new one will be created.
             * @returns {Quaternion} The "target" object
             */
        }, {
            key: "slerp",
            value: function slerp( toQuat, t, target ) {
                if ( target === void 0 ) {
                    target = new Quaternion( );
                }
                var ax = this.x;
                var ay = this.y;
                var az = this.z;
                var aw = this.w;
                var bx = toQuat.x;
                var by = toQuat.y;
                var bz = toQuat.z;
                var bw = toQuat.w;
                var omega;
                var cosom;
                var sinom;
                var scale0;
                var scale1; // calc cosine
                cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)
                if ( cosom < 0.0 ) {
                    cosom = -cosom;
                    bx = -bx;
                    by = -by;
                    bz = -bz;
                    bw = -bw;
                } // calculate coefficients
                if ( 1.0 - cosom > 0.000001 ) { // standard case (slerp)
                    omega = Math.acos( cosom );
                    sinom = Math.sin( omega );
                    scale0 = Math.sin( ( 1.0 - t ) * omega ) / sinom;
                    scale1 = Math.sin( t * omega ) / sinom;
                } else { // "from" and "to" quaternions are very close
                    //  ... so we can do a linear interpolation
                    scale0 = 1.0 - t;
                    scale1 = t;
                } // calculate final values
                target.x = scale0 * ax + scale1 * bx;
                target.y = scale0 * ay + scale1 * by;
                target.z = scale0 * az + scale1 * bz;
                target.w = scale0 * aw + scale1 * bw;
                return target;
            }
            /**
             * Rotate an absolute orientation quaternion given an angular velocity and a time step.
             */
        }, {
            key: "integrate",
            value: function integrate( angularVelocity, dt, angularFactor, target ) {
                if ( target === void 0 ) {
                    target = new Quaternion( );
                }
                var ax = angularVelocity.x * angularFactor.x,
                    ay = angularVelocity.y * angularFactor.y,
                    az = angularVelocity.z * angularFactor.z,
                    bx = this.x,
                    by = this.y,
                    bz = this.z,
                    bw = this.w;
                var half_dt = dt * 0.5;
                target.x += half_dt * ( ax * bw + ay * bz - az * by );
                target.y += half_dt * ( ay * bw + az * bx - ax * bz );
                target.z += half_dt * ( az * bw + ax * by - ay * bx );
                target.w += half_dt * ( -ax * bx - ay * by - az * bz );
                return target;
            }
        } ] );
        return Quaternion;
    }( );
    var sfv_t1 = new Vec3( );
    var sfv_t2 = new Vec3( );
    /**
     * The available shape types.
     */
    var SHAPE_TYPES = {
        /** SPHERE */
        SPHERE: 1,
        /** PLANE */ PLANE: 2,
        /** BOX */ BOX: 4,
        /** COMPOUND */ COMPOUND: 8,
        /** CONVEXPOLYHEDRON */ CONVEXPOLYHEDRON: 16,
        /** HEIGHTFIELD */ HEIGHTFIELD: 32,
        /** PARTICLE */ PARTICLE: 64,
        /** CYLINDER */ CYLINDER: 128,
        /** TRIMESH */ TRIMESH: 256
    };
    /**
     * ShapeType
     */
    /**
     * Base class for shapes
     */
    var Shape = /*#__PURE__*/ function( ) {
        /**
         * Identifier of the Shape.
         */
        /**
         * The type of this shape. Must be set to an int > 0 by subclasses.
         */
        /**
         * The local bounding sphere radius of this shape.
         */
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
         * @default true
         */
        /**
         * @default 1
         */
        /**
         * @default -1
         */
        /**
         * Optional material of the shape that regulates contact properties.
         */
        /**
         * The body to which the shape is added to.
         */
        /**
         * All the Shape types.
         */
        function Shape( options ) {
            _classCallCheck( this, Shape );
            if ( options === void 0 ) {
                options = {};
            }
            this.id = Shape.idCounter++;
            this.type = options.type || 0;
            this.boundingSphereRadius = 0;
            this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
            this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
            this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
            this.material = options.material ? options.material : null;
            this.body = null;
        }
        /**
         * Computes the bounding sphere radius.
         * The result is stored in the property `.boundingSphereRadius`
         */
        _createClass( Shape, [ {
            key: "updateBoundingSphereRadius",
            value: function updateBoundingSphereRadius( ) {
                throw "computeBoundingSphereRadius() not implemented for shape type ".concat( this.type );
            }
            /**
             * Get the volume of this shape
             */
        }, {
            key: "volume",
            value: function volume( ) {
                throw "volume() not implemented for shape type ".concat( this.type );
            }
            /**
             * Calculates the inertia in the local frame for this shape.
             * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
             */
        }, {
            key: "calculateLocalInertia",
            value: function calculateLocalInertia( mass, target ) {
                throw "calculateLocalInertia() not implemented for shape type ".concat( this.type );
            }
            /**
             * @todo use abstract for these kind of methods
             */
        }, {
            key: "calculateWorldAABB",
            value: function calculateWorldAABB( pos, quat, min, max ) {
                throw "calculateWorldAABB() not implemented for shape type ".concat( this.type );
            }
        } ] );
        return Shape;
    }( );
    Shape.idCounter = 0;
    Shape.types = SHAPE_TYPES;
    /**
     * Transformation utilities.
     */
    var Transform = /*#__PURE__*/ function( ) {
        /**
         * position
         */
        /**
         * quaternion
         */
        function Transform( options ) {
            _classCallCheck( this, Transform );
            if ( options === void 0 ) {
                options = {};
            }
            this.position = new Vec3( );
            this.quaternion = new Quaternion( );
            if ( options.position ) {
                this.position.copy( options.position );
            }
            if ( options.quaternion ) {
                this.quaternion.copy( options.quaternion );
            }
        }
        /**
         * Get a global point in local transform coordinates.
         */
        _createClass( Transform, [ {
            key: "pointToLocal",
            value: function pointToLocal( worldPoint, result ) {
                return Transform.pointToLocalFrame( this.position, this.quaternion, worldPoint, result );
            }
            /**
             * Get a local point in global transform coordinates.
             */
        }, {
            key: "pointToWorld",
            value: function pointToWorld( localPoint, result ) {
                return Transform.pointToWorldFrame( this.position, this.quaternion, localPoint, result );
            }
            /**
             * vectorToWorldFrame
             */
        }, {
            key: "vectorToWorldFrame",
            value: function vectorToWorldFrame( localVector, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                this.quaternion.vmult( localVector, result );
                return result;
            }
            /**
             * pointToLocalFrame
             */
        } ], [ {
            key: "pointToLocalFrame",
            value: function pointToLocalFrame( position, quaternion, worldPoint, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                worldPoint.vsub( position, result );
                quaternion.conjugate( tmpQuat$1 );
                tmpQuat$1.vmult( result, result );
                return result;
            }
            /**
             * pointToWorldFrame
             */
        }, {
            key: "pointToWorldFrame",
            value: function pointToWorldFrame( position, quaternion, localPoint, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                quaternion.vmult( localPoint, result );
                result.vadd( position, result );
                return result;
            }
            /**
             * vectorToWorldFrame
             */
        }, {
            key: "vectorToWorldFrame",
            value: function vectorToWorldFrame( quaternion, localVector, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                quaternion.vmult( localVector, result );
                return result;
            }
            /**
             * vectorToLocalFrame
             */
        }, {
            key: "vectorToLocalFrame",
            value: function vectorToLocalFrame( position, quaternion, worldVector, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                quaternion.w *= -1;
                quaternion.vmult( worldVector, result );
                quaternion.w *= -1;
                return result;
            }
        } ] );
        return Transform;
    }( );
    var tmpQuat$1 = new Quaternion( );
    /**
     * A set of polygons describing a convex shape.
     *
     * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
     * in the same 3D plane), instead these should be merged into one polygon.
     *
     * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
     * @author schteppe / https://github.com/schteppe
     * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
     *
     * @todo Move the clipping functions to ContactGenerator?
     * @todo Automatically merge coplanar polygons in constructor.
     * @example
     *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
     *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
     *     world.addBody(convexBody)
     */
    var ConvexPolyhedron = /*#__PURE__*/ function( _Shape ) {
        _inherits( ConvexPolyhedron, _Shape );
        var _super71 = _createSuper( ConvexPolyhedron ); /** vertices */
        /**
         * Array of integer arrays, indicating which vertices each face consists of
         */
        /** faceNormals */ /** worldVertices */ /** worldVerticesNeedsUpdate */ /** worldFaceNormals */ /** worldFaceNormalsNeedsUpdate */
        /**
         * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
         */
        /** uniqueEdges */
        /**
         * @param vertices An array of Vec3's
         * @param faces Array of integer arrays, describing which vertices that is included in each face.
         */
        function ConvexPolyhedron( props ) {
            var _this57;
            _classCallCheck( this, ConvexPolyhedron );
            if ( props === void 0 ) {
                props = {};
            }
            var _props = props,
                _props$vertices = _props.vertices,
                vertices = _props$vertices === void 0 ? [ ] : _props$vertices,
                _props$faces = _props.faces,
                faces = _props$faces === void 0 ? [ ] : _props$faces,
                _props$normals = _props.normals,
                normals = _props$normals === void 0 ? [ ] : _props$normals,
                axes = _props.axes,
                boundingSphereRadius = _props.boundingSphereRadius;
            _this57 = _super71.call( this, {
                type: Shape.types.CONVEXPOLYHEDRON
            } );
            _this57.vertices = vertices;
            _this57.faces = faces;
            _this57.faceNormals = normals;
            if ( _this57.faceNormals.length === 0 ) {
                _this57.computeNormals( );
            }
            if ( !boundingSphereRadius ) {
                _this57.updateBoundingSphereRadius( );
            } else {
                _this57.boundingSphereRadius = boundingSphereRadius;
            }
            _this57.worldVertices = [ ]; // World transformed version of .vertices
            _this57.worldVerticesNeedsUpdate = true;
            _this57.worldFaceNormals = [ ]; // World transformed version of .faceNormals
            _this57.worldFaceNormalsNeedsUpdate = true;
            _this57.uniqueAxes = axes ? axes.slice( ) : null;
            _this57.uniqueEdges = [ ];
            _this57.computeEdges( );
            return _this57;
        }
        /**
         * Computes uniqueEdges
         */
        _createClass( ConvexPolyhedron, [ {
            key: "computeEdges",
            value: function computeEdges( ) {
                var faces = this.faces;
                var vertices = this.vertices;
                var edges = this.uniqueEdges;
                edges.length = 0;
                var edge = new Vec3( );
                for ( var _i294 = 0; _i294 !== faces.length; _i294++ ) {
                    var face = faces[ _i294 ];
                    var numVertices = face.length;
                    for ( var j = 0; j !== numVertices; j++ ) {
                        var k = ( j + 1 ) % numVertices;
                        vertices[ face[ j ] ].vsub( vertices[ face[ k ] ], edge );
                        edge.normalize( );
                        var found = false;
                        for ( var p = 0; p !== edges.length; p++ ) {
                            if ( edges[ p ].almostEquals( edge ) || edges[ p ].almostEquals( edge ) ) {
                                found = true;
                                break;
                            }
                        }
                        if ( !found ) {
                            edges.push( edge.clone( ) );
                        }
                    }
                }
            }
            /**
             * Compute the normals of the faces.
             * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
             */
        }, {
            key: "computeNormals",
            value: function computeNormals( ) {
                this.faceNormals.length = this.faces.length; // Generate normals
                for ( var _i295 = 0; _i295 < this.faces.length; _i295++ ) { // Check so all vertices exists for this face
                    for ( var j = 0; j < this.faces[ _i295 ].length; j++ ) {
                        if ( !this.vertices[ this.faces[ _i295 ][ j ] ] ) {
                            throw new Error( "Vertex ".concat( this.faces[ _i295 ][ j ], " not found!" ) );
                        }
                    }
                    var n = this.faceNormals[ _i295 ] || new Vec3( );
                    this.getFaceNormal( _i295, n );
                    n.negate( n );
                    this.faceNormals[ _i295 ] = n;
                    var _vertex = this.vertices[ this.faces[ _i295 ][ 0 ] ];
                    if ( n.dot( _vertex ) < 0 ) {
                        console.error( ".faceNormals[".concat( _i295, "] = Vec3(" ).concat( n.toString( ), ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule." ) );
                        for ( var _j9 = 0; _j9 < this.faces[ _i295 ].length; _j9++ ) {
                            console.warn( ".vertices[".concat( this.faces[ _i295 ][ _j9 ], "] = Vec3(" ).concat( this.vertices[ this.faces[ _i295 ][ _j9 ] ].toString( ), ")" ) );
                        }
                    }
                }
            }
            /**
             * Compute the normal of a face from its vertices
             */
        }, {
            key: "getFaceNormal",
            value: function getFaceNormal( i, target ) {
                var f = this.faces[ i ];
                var va = this.vertices[ f[ 0 ] ];
                var vb = this.vertices[ f[ 1 ] ];
                var vc = this.vertices[ f[ 2 ] ];
                ConvexPolyhedron.computeNormal( va, vb, vc, target );
            }
            /**
             * Get face normal given 3 vertices
             */
        }, {
            key: "clipAgainstHull",
            value:
                /**
                 * @param minDist Clamp distance
                 * @param result The an array of contact point objects, see clipFaceAgainstHull
                 */
                function clipAgainstHull( posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result ) {
                    var WorldNormal = new Vec3( );
                    var closestFaceB = -1;
                    var dmax = -Number.MAX_VALUE;
                    for ( var face = 0; face < hullB.faces.length; face++ ) {
                        WorldNormal.copy( hullB.faceNormals[ face ] );
                        quatB.vmult( WorldNormal, WorldNormal );
                        var d = WorldNormal.dot( separatingNormal );
                        if ( d > dmax ) {
                            dmax = d;
                            closestFaceB = face;
                        }
                    }
                    var worldVertsB1 = [ ];
                    for ( var _i296 = 0; _i296 < hullB.faces[ closestFaceB ].length; _i296++ ) {
                        var _b11 = hullB.vertices[ hullB.faces[ closestFaceB ][ _i296 ] ];
                        var worldb = new Vec3( );
                        worldb.copy( _b11 );
                        quatB.vmult( worldb, worldb );
                        posB.vadd( worldb, worldb );
                        worldVertsB1.push( worldb );
                    }
                    if ( closestFaceB >= 0 ) {
                        this.clipFaceAgainstHull( separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result );
                    }
                }
            /**
             * Find the separating axis between this hull and another
             * @param target The target vector to save the axis in
             * @return Returns false if a separation is found, else true
             */
        }, {
            key: "findSeparatingAxis",
            value: function findSeparatingAxis( hullB, posA, quatA, posB, quatB, target, faceListA, faceListB ) {
                var faceANormalWS3 = new Vec3( );
                var Worldnormal1 = new Vec3( );
                var deltaC = new Vec3( );
                var worldEdge0 = new Vec3( );
                var worldEdge1 = new Vec3( );
                var Cross = new Vec3( );
                var dmin = Number.MAX_VALUE;
                var hullA = this;
                if ( !hullA.uniqueAxes ) {
                    var numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA
                    for ( var _i297 = 0; _i297 < numFacesA; _i297++ ) {
                        var fi = faceListA ? faceListA[ _i297 ] : _i297; // Get world face normal
                        faceANormalWS3.copy( hullA.faceNormals[ fi ] );
                        quatA.vmult( faceANormalWS3, faceANormalWS3 );
                        var d = hullA.testSepAxis( faceANormalWS3, hullB, posA, quatA, posB, quatB );
                        if ( d === false ) {
                            return false;
                        }
                        if ( d < dmin ) {
                            dmin = d;
                            target.copy( faceANormalWS3 );
                        }
                    }
                } else { // Test unique axes
                    for ( var _i298 = 0; _i298 !== hullA.uniqueAxes.length; _i298++ ) { // Get world axis
                        quatA.vmult( hullA.uniqueAxes[ _i298 ], faceANormalWS3 );
                        var _d2 = hullA.testSepAxis( faceANormalWS3, hullB, posA, quatA, posB, quatB );
                        if ( _d2 === false ) {
                            return false;
                        }
                        if ( _d2 < dmin ) {
                            dmin = _d2;
                            target.copy( faceANormalWS3 );
                        }
                    }
                }
                if ( !hullB.uniqueAxes ) { // Test face normals from hullB
                    var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
                    for ( var _i299 = 0; _i299 < numFacesB; _i299++ ) {
                        var _fi = faceListB ? faceListB[ _i299 ] : _i299;
                        Worldnormal1.copy( hullB.faceNormals[ _fi ] );
                        quatB.vmult( Worldnormal1, Worldnormal1 );
                        var _d3 = hullA.testSepAxis( Worldnormal1, hullB, posA, quatA, posB, quatB );
                        if ( _d3 === false ) {
                            return false;
                        }
                        if ( _d3 < dmin ) {
                            dmin = _d3;
                            target.copy( Worldnormal1 );
                        }
                    }
                } else { // Test unique axes in B
                    for ( var _i300 = 0; _i300 !== hullB.uniqueAxes.length; _i300++ ) {
                        quatB.vmult( hullB.uniqueAxes[ _i300 ], Worldnormal1 );
                        var _d4 = hullA.testSepAxis( Worldnormal1, hullB, posA, quatA, posB, quatB );
                        if ( _d4 === false ) {
                            return false;
                        }
                        if ( _d4 < dmin ) {
                            dmin = _d4;
                            target.copy( Worldnormal1 );
                        }
                    }
                } // Test edges
                for ( var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++ ) { // Get world edge
                    quatA.vmult( hullA.uniqueEdges[ e0 ], worldEdge0 );
                    for ( var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++ ) { // Get world edge 2
                        quatB.vmult( hullB.uniqueEdges[ e1 ], worldEdge1 );
                        worldEdge0.cross( worldEdge1, Cross );
                        if ( !Cross.almostZero( ) ) {
                            Cross.normalize( );
                            var dist = hullA.testSepAxis( Cross, hullB, posA, quatA, posB, quatB );
                            if ( dist === false ) {
                                return false;
                            }
                            if ( dist < dmin ) {
                                dmin = dist;
                                target.copy( Cross );
                            }
                        }
                    }
                }
                posB.vsub( posA, deltaC );
                if ( deltaC.dot( target ) > 0.0 ) {
                    target.negate( target );
                }
                return true;
            }
            /**
             * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
             * @return The overlap depth, or FALSE if no penetration.
             */
        }, {
            key: "testSepAxis",
            value: function testSepAxis( axis, hullB, posA, quatA, posB, quatB ) {
                var hullA = this;
                ConvexPolyhedron.project( hullA, axis, posA, quatA, maxminA );
                ConvexPolyhedron.project( hullB, axis, posB, quatB, maxminB );
                var maxA = maxminA[ 0 ];
                var minA = maxminA[ 1 ];
                var maxB = maxminB[ 0 ];
                var minB = maxminB[ 1 ];
                if ( maxA < minB || maxB < minA ) {
                    return false; // Separated
                }
                var d0 = maxA - minB;
                var d1 = maxB - minA;
                var depth = d0 < d1 ? d0 : d1;
                return depth;
            }
            /**
             * calculateLocalInertia
             */
        }, {
            key: "calculateLocalInertia",
            value: function calculateLocalInertia( mass, target ) { // Approximate with box inertia
                // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
                var aabbmax = new Vec3( );
                var aabbmin = new Vec3( );
                this.computeLocalAABB( aabbmin, aabbmax );
                var x = aabbmax.x - aabbmin.x;
                var y = aabbmax.y - aabbmin.y;
                var z = aabbmax.z - aabbmin.z;
                target.x = 1.0 / 12.0 * mass * ( 2 * y * 2 * y + 2 * z * 2 * z );
                target.y = 1.0 / 12.0 * mass * ( 2 * x * 2 * x + 2 * z * 2 * z );
                target.z = 1.0 / 12.0 * mass * ( 2 * y * 2 * y + 2 * x * 2 * x );
            }
            /**
             * @param face_i Index of the face
             */
        }, {
            key: "getPlaneConstantOfFace",
            value: function getPlaneConstantOfFace( face_i ) {
                var f = this.faces[ face_i ];
                var n = this.faceNormals[ face_i ];
                var v = this.vertices[ f[ 0 ] ];
                var c = -n.dot( v );
                return c;
            }
            /**
             * Clip a face against a hull.
             * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
             * @param minDist Distance clamping
             * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
             */
        }, {
            key: "clipFaceAgainstHull",
            value: function clipFaceAgainstHull( separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result ) {
                var faceANormalWS = new Vec3( );
                var edge0 = new Vec3( );
                var WorldEdge0 = new Vec3( );
                var worldPlaneAnormal1 = new Vec3( );
                var planeNormalWS1 = new Vec3( );
                var worldA1 = new Vec3( );
                var localPlaneNormal = new Vec3( );
                var planeNormalWS = new Vec3( );
                var hullA = this;
                var worldVertsB2 = [ ];
                var pVtxIn = worldVertsB1;
                var pVtxOut = worldVertsB2;
                var closestFaceA = -1;
                var dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis
                for ( var face = 0; face < hullA.faces.length; face++ ) {
                    faceANormalWS.copy( hullA.faceNormals[ face ] );
                    quatA.vmult( faceANormalWS, faceANormalWS );
                    var d = faceANormalWS.dot( separatingNormal );
                    if ( d < dmin ) {
                        dmin = d;
                        closestFaceA = face;
                    }
                }
                if ( closestFaceA < 0 ) {
                    return;
                } // Get the face and construct connected faces
                var polyA = hullA.faces[ closestFaceA ];
                polyA.connectedFaces = [ ];
                for ( var _i301 = 0; _i301 < hullA.faces.length; _i301++ ) {
                    for ( var j = 0; j < hullA.faces[ _i301 ].length; j++ ) {
                        if ( /* Sharing a vertex*/ polyA.indexOf( hullA.faces[ _i301 ][ j ] ) !== -1 && /* Not the one we are looking for connections from */ _i301 !== closestFaceA && /* Not already added */ polyA.connectedFaces.indexOf( _i301 ) === -1 ) {
                            polyA.connectedFaces.push( _i301 );
                        }
                    }
                } // Clip the polygon to the back of the planes of all faces of hull A,
                // that are adjacent to the witness face
                var numVerticesA = polyA.length;
                for ( var _i302 = 0; _i302 < numVerticesA; _i302++ ) {
                    var _a13 = hullA.vertices[ polyA[ _i302 ] ];
                    var _b12 = hullA.vertices[ polyA[ ( _i302 + 1 ) % numVerticesA ] ];
                    _a13.vsub( _b12, edge0 );
                    WorldEdge0.copy( edge0 );
                    quatA.vmult( WorldEdge0, WorldEdge0 );
                    posA.vadd( WorldEdge0, WorldEdge0 );
                    worldPlaneAnormal1.copy( this.faceNormals[ closestFaceA ] );
                    quatA.vmult( worldPlaneAnormal1, worldPlaneAnormal1 );
                    posA.vadd( worldPlaneAnormal1, worldPlaneAnormal1 );
                    WorldEdge0.cross( worldPlaneAnormal1, planeNormalWS1 );
                    planeNormalWS1.negate( planeNormalWS1 );
                    worldA1.copy( _a13 );
                    quatA.vmult( worldA1, worldA1 );
                    posA.vadd( worldA1, worldA1 );
                    var otherFace = polyA.connectedFaces[ _i302 ];
                    localPlaneNormal.copy( this.faceNormals[ otherFace ] );
                    var _localPlaneEq = this.getPlaneConstantOfFace( otherFace );
                    planeNormalWS.copy( localPlaneNormal );
                    quatA.vmult( planeNormalWS, planeNormalWS );
                    var _planeEqWS = _localPlaneEq - planeNormalWS.dot( posA ); // Clip face against our constructed plane
                    this.clipFaceAgainstPlane( pVtxIn, pVtxOut, planeNormalWS, _planeEqWS ); // Throw away all clipped points, but save the remaining until next clip
                    while ( pVtxIn.length ) {
                        pVtxIn.shift( );
                    }
                    while ( pVtxOut.length ) {
                        pVtxIn.push( pVtxOut.shift( ) );
                    }
                } // only keep contact points that are behind the witness face
                localPlaneNormal.copy( this.faceNormals[ closestFaceA ] );
                var localPlaneEq = this.getPlaneConstantOfFace( closestFaceA );
                planeNormalWS.copy( localPlaneNormal );
                quatA.vmult( planeNormalWS, planeNormalWS );
                var planeEqWS = localPlaneEq - planeNormalWS.dot( posA );
                for ( var _i303 = 0; _i303 < pVtxIn.length; _i303++ ) {
                    var depth = planeNormalWS.dot( pVtxIn[ _i303 ] ) + planeEqWS; // ???
                    if ( depth <= minDist ) {
                        console.log( "clamped: depth=".concat( depth, " to minDist=" ).concat( minDist ) );
                        depth = minDist;
                    }
                    if ( depth <= maxDist ) {
                        var point = pVtxIn[ _i303 ];
                        if ( depth <= 1e-6 ) {
                            var p = {
                                point: point,
                                normal: planeNormalWS,
                                depth: depth
                            };
                            result.push( p );
                        }
                    }
                }
            }
            /**
             * Clip a face in a hull against the back of a plane.
             * @param planeConstant The constant in the mathematical plane equation
             */
        }, {
            key: "clipFaceAgainstPlane",
            value: function clipFaceAgainstPlane( inVertices, outVertices, planeNormal, planeConstant ) {
                var n_dot_first;
                var n_dot_last;
                var numVerts = inVertices.length;
                if ( numVerts < 2 ) {
                    return outVertices;
                }
                var firstVertex = inVertices[ inVertices.length - 1 ];
                var lastVertex = inVertices[ 0 ];
                n_dot_first = planeNormal.dot( firstVertex ) + planeConstant;
                for ( var vi = 0; vi < numVerts; vi++ ) {
                    lastVertex = inVertices[ vi ];
                    n_dot_last = planeNormal.dot( lastVertex ) + planeConstant;
                    if ( n_dot_first < 0 ) {
                        if ( n_dot_last < 0 ) { // Start < 0, end < 0, so output lastVertex
                            var newv = new Vec3( );
                            newv.copy( lastVertex );
                            outVertices.push( newv );
                        } else { // Start < 0, end >= 0, so output intersection
                            var _newv = new Vec3( );
                            firstVertex.lerp( lastVertex, n_dot_first / ( n_dot_first - n_dot_last ), _newv );
                            outVertices.push( _newv );
                        }
                    } else {
                        if ( n_dot_last < 0 ) { // Start >= 0, end < 0 so output intersection and end
                            var _newv2 = new Vec3( );
                            firstVertex.lerp( lastVertex, n_dot_first / ( n_dot_first - n_dot_last ), _newv2 );
                            outVertices.push( _newv2 );
                            outVertices.push( lastVertex );
                        }
                    }
                    firstVertex = lastVertex;
                    n_dot_first = n_dot_last;
                }
                return outVertices;
            }
            /**
             * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
             */
        }, {
            key: "computeWorldVertices",
            value: function computeWorldVertices( position, quat ) {
                while ( this.worldVertices.length < this.vertices.length ) {
                    this.worldVertices.push( new Vec3( ) );
                }
                var verts = this.vertices;
                var worldVerts = this.worldVertices;
                for ( var _i304 = 0; _i304 !== this.vertices.length; _i304++ ) {
                    quat.vmult( verts[ _i304 ], worldVerts[ _i304 ] );
                    position.vadd( worldVerts[ _i304 ], worldVerts[ _i304 ] );
                }
                this.worldVerticesNeedsUpdate = false;
            }
        }, {
            key: "computeLocalAABB",
            value: function computeLocalAABB( aabbmin, aabbmax ) {
                var vertices = this.vertices;
                aabbmin.set( Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE );
                aabbmax.set( -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE );
                for ( var _i305 = 0; _i305 < this.vertices.length; _i305++ ) {
                    var v = vertices[ _i305 ];
                    if ( v.x < aabbmin.x ) {
                        aabbmin.x = v.x;
                    } else if ( v.x > aabbmax.x ) {
                        aabbmax.x = v.x;
                    }
                    if ( v.y < aabbmin.y ) {
                        aabbmin.y = v.y;
                    } else if ( v.y > aabbmax.y ) {
                        aabbmax.y = v.y;
                    }
                    if ( v.z < aabbmin.z ) {
                        aabbmin.z = v.z;
                    } else if ( v.z > aabbmax.z ) {
                        aabbmax.z = v.z;
                    }
                }
            }
            /**
             * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
             */
        }, {
            key: "computeWorldFaceNormals",
            value: function computeWorldFaceNormals( quat ) {
                var N = this.faceNormals.length;
                while ( this.worldFaceNormals.length < N ) {
                    this.worldFaceNormals.push( new Vec3( ) );
                }
                var normals = this.faceNormals;
                var worldNormals = this.worldFaceNormals;
                for ( var _i306 = 0; _i306 !== N; _i306++ ) {
                    quat.vmult( normals[ _i306 ], worldNormals[ _i306 ] );
                }
                this.worldFaceNormalsNeedsUpdate = false;
            }
            /**
             * updateBoundingSphereRadius
             */
        }, {
            key: "updateBoundingSphereRadius",
            value: function updateBoundingSphereRadius( ) { // Assume points are distributed with local (0,0,0) as center
                var max2 = 0;
                var verts = this.vertices;
                for ( var _i307 = 0; _i307 !== verts.length; _i307++ ) {
                    var norm2 = verts[ _i307 ].lengthSquared( );
                    if ( norm2 > max2 ) {
                        max2 = norm2;
                    }
                }
                this.boundingSphereRadius = Math.sqrt( max2 );
            }
            /**
             * calculateWorldAABB
             */
        }, {
            key: "calculateWorldAABB",
            value: function calculateWorldAABB( pos, quat, min, max ) {
                var verts = this.vertices;
                var minx;
                var miny;
                var minz;
                var maxx;
                var maxy;
                var maxz;
                var tempWorldVertex = new Vec3( );
                for ( var _i308 = 0; _i308 < verts.length; _i308++ ) {
                    tempWorldVertex.copy( verts[ _i308 ] );
                    quat.vmult( tempWorldVertex, tempWorldVertex );
                    pos.vadd( tempWorldVertex, tempWorldVertex );
                    var v = tempWorldVertex;
                    if ( minx === undefined || v.x < minx ) {
                        minx = v.x;
                    }
                    if ( maxx === undefined || v.x > maxx ) {
                        maxx = v.x;
                    }
                    if ( miny === undefined || v.y < miny ) {
                        miny = v.y;
                    }
                    if ( maxy === undefined || v.y > maxy ) {
                        maxy = v.y;
                    }
                    if ( minz === undefined || v.z < minz ) {
                        minz = v.z;
                    }
                    if ( maxz === undefined || v.z > maxz ) {
                        maxz = v.z;
                    }
                }
                min.set( minx, miny, minz );
                max.set( maxx, maxy, maxz );
            }
            /**
             * Get approximate convex volume
             */
        }, {
            key: "volume",
            value: function volume( ) {
                return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
            }
            /**
             * Get an average of all the vertices positions
             */
        }, {
            key: "getAveragePointLocal",
            value: function getAveragePointLocal( target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                var verts = this.vertices;
                for ( var _i309 = 0; _i309 < verts.length; _i309++ ) {
                    target.vadd( verts[ _i309 ], target );
                }
                target.scale( 1 / verts.length, target );
                return target;
            }
            /**
             * Transform all local points. Will change the .vertices
             */
        }, {
            key: "transformAllPoints",
            value: function transformAllPoints( offset, quat ) {
                var n = this.vertices.length;
                var verts = this.vertices; // Apply rotation
                if ( quat ) { // Rotate vertices
                    for ( var _i310 = 0; _i310 < n; _i310++ ) {
                        var v = verts[ _i310 ];
                        quat.vmult( v, v );
                    } // Rotate face normals
                    for ( var _i311 = 0; _i311 < this.faceNormals.length; _i311++ ) {
                        var _v3 = this.faceNormals[ _i311 ];
                        quat.vmult( _v3, _v3 );
                    }
                    /*
                    	            // Rotate edges
                    	            for(let i=0; i<this.uniqueEdges.length; i++){
                    	                const v = this.uniqueEdges[i];
                    	                quat.vmult(v,v);
                    	            }*/
                } // Apply offset
                if ( offset ) {
                    for ( var _i312 = 0; _i312 < n; _i312++ ) {
                        var _v4 = verts[ _i312 ];
                        _v4.vadd( offset, _v4 );
                    }
                }
            }
            /**
             * Checks whether p is inside the polyhedra. Must be in local coords.
             * The point lies outside of the convex hull of the other points if and only if the direction
             * of all the vectors from it to those other points are on less than one half of a sphere around it.
             * @param p A point given in local coordinates
             */
        }, {
            key: "pointIsInside",
            value: function pointIsInside( p ) {
                var verts = this.vertices;
                var faces = this.faces;
                var normals = this.faceNormals;
                var positiveResult = null;
                var pointInside = new Vec3( );
                this.getAveragePointLocal( pointInside );
                for ( var _i313 = 0; _i313 < this.faces.length; _i313++ ) {
                    var n = normals[ _i313 ];
                    var v = verts[ faces[ _i313 ][ 0 ] ]; // We only need one point in the face
                    // This dot product determines which side of the edge the point is
                    var vToP = new Vec3( );
                    p.vsub( v, vToP );
                    var r1 = n.dot( vToP );
                    var vToPointInside = new Vec3( );
                    pointInside.vsub( v, vToPointInside );
                    var r2 = n.dot( vToPointInside );
                    if ( r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0 ) {
                        return false; // Encountered some other sign. Exit.
                    }
                } // If we got here, all dot products were of the same sign.
                return positiveResult ? 1 : -1;
            }
            /**
             * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
             * Results are saved in the array maxmin.
             * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
             */
        } ], [ {
            key: "computeNormal",
            value: function computeNormal( va, vb, vc, target ) {
                var cb = new Vec3( );
                var ab = new Vec3( );
                vb.vsub( va, ab );
                vc.vsub( vb, cb );
                cb.cross( ab, target );
                if ( !target.isZero( ) ) {
                    target.normalize( );
                }
            }
        }, {
            key: "project",
            value: function project( shape, axis, pos, quat, result ) {
                var n = shape.vertices.length;
                var localAxis = project_localAxis;
                var max = 0;
                var min = 0;
                var localOrigin = project_localOrigin;
                var vs = shape.vertices;
                localOrigin.setZero( ); // Transform the axis to local
                Transform.vectorToLocalFrame( pos, quat, axis, localAxis );
                Transform.pointToLocalFrame( pos, quat, localOrigin, localOrigin );
                var add = localOrigin.dot( localAxis );
                min = max = vs[ 0 ].dot( localAxis );
                for ( var _i314 = 1; _i314 < n; _i314++ ) {
                    var val = vs[ _i314 ].dot( localAxis );
                    if ( val > max ) {
                        max = val;
                    }
                    if ( val < min ) {
                        min = val;
                    }
                }
                min -= add;
                max -= add;
                if ( min > max ) { // Inconsistent - swap
                    var temp = min;
                    min = max;
                    max = temp;
                } // Output
                result[ 0 ] = max;
                result[ 1 ] = min;
            }
        } ] );
        return ConvexPolyhedron;
    }( Shape );
    var maxminA = [ ];
    var maxminB = [ ];
    new Vec3( );
    var project_localAxis = new Vec3( );
    var project_localOrigin = new Vec3( );
    /**
     * A 3d box shape.
     * @example
     *     const size = 1
     *     const halfExtents = new CANNON.Vec3(size, size, size)
     *     const boxShape = new CANNON.Box(halfExtents)
     *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
     *     world.addBody(boxBody)
     */
    var Box = /*#__PURE__*/ function( _Shape2 ) {
        _inherits( Box, _Shape2 );
        var _super72 = _createSuper( Box );
        /**
         * The half extents of the box.
         */
        /**
         * Used by the contact generator to make contacts with other convex polyhedra for example.
         */
        function Box( halfExtents ) {
            var _this58;
            _classCallCheck( this, Box );
            _this58 = _super72.call( this, {
                type: Shape.types.BOX
            } );
            _this58.halfExtents = halfExtents;
            _this58.convexPolyhedronRepresentation = null;
            _this58.updateConvexPolyhedronRepresentation( );
            _this58.updateBoundingSphereRadius( );
            return _this58;
        }
        /**
         * Updates the local convex polyhedron representation used for some collisions.
         */
        _createClass( Box, [ {
            key: "updateConvexPolyhedronRepresentation",
            value: function updateConvexPolyhedronRepresentation( ) {
                var sx = this.halfExtents.x;
                var sy = this.halfExtents.y;
                var sz = this.halfExtents.z;
                var V = Vec3;
                var vertices = [ new V( -sx, -sy, -sz ), new V( sx, -sy, -sz ), new V( sx, sy, -sz ), new V( -sx, sy, -sz ), new V( -sx, -sy, sz ), new V( sx, -sy, sz ), new V( sx, sy, sz ), new V( -sx, sy, sz ) ];
                var faces = [
                    [ 3, 2, 1, 0 ], // -z
                    [ 4, 5, 6, 7 ], // +z
                    [ 5, 4, 0, 1 ], // -y
                    [ 2, 3, 7, 6 ], // +y
                    [ 0, 4, 7, 3 ], // -x
                    [ 1, 2, 6, 5 ] // +x
                ];
                var axes = [ new V( 0, 0, 1 ), new V( 0, 1, 0 ), new V( 1, 0, 0 ) ];
                var h = new ConvexPolyhedron( {
                    vertices: vertices,
                    faces: faces,
                    axes: axes
                } );
                this.convexPolyhedronRepresentation = h;
                h.material = this.material;
            }
            /**
             * Calculate the inertia of the box.
             */
        }, {
            key: "calculateLocalInertia",
            value: function calculateLocalInertia( mass, target ) {
                if ( target === void 0 ) {
                    target = new Vec3( );
                }
                Box.calculateInertia( this.halfExtents, mass, target );
                return target;
            }
        }, {
            key: "getSideNormals",
            value:
                /**
                 * Get the box 6 side normals
                 * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
                 * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
                 */
                function getSideNormals( sixTargetVectors, quat ) {
                    var sides = sixTargetVectors;
                    var ex = this.halfExtents;
                    sides[ 0 ].set( ex.x, 0, 0 );
                    sides[ 1 ].set( 0, ex.y, 0 );
                    sides[ 2 ].set( 0, 0, ex.z );
                    sides[ 3 ].set( -ex.x, 0, 0 );
                    sides[ 4 ].set( 0, -ex.y, 0 );
                    sides[ 5 ].set( 0, 0, -ex.z );
                    if ( quat !== undefined ) {
                        for ( var _i315 = 0; _i315 !== sides.length; _i315++ ) {
                            quat.vmult( sides[ _i315 ], sides[ _i315 ] );
                        }
                    }
                    return sides;
                }
            /**
             * Returns the volume of the box.
             */
        }, {
            key: "volume",
            value: function volume( ) {
                return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
            }
            /**
             * updateBoundingSphereRadius
             */
        }, {
            key: "updateBoundingSphereRadius",
            value: function updateBoundingSphereRadius( ) {
                this.boundingSphereRadius = this.halfExtents.length( );
            }
            /**
             * forEachWorldCorner
             */
        }, {
            key: "forEachWorldCorner",
            value: function forEachWorldCorner( pos, quat, callback ) {
                var e = this.halfExtents;
                var corners = [
                    [ e.x, e.y, e.z ],
                    [ -e.x, e.y, e.z ],
                    [ -e.x, -e.y, e.z ],
                    [ -e.x, -e.y, -e.z ],
                    [ e.x, -e.y, -e.z ],
                    [ e.x, e.y, -e.z ],
                    [ -e.x, e.y, -e.z ],
                    [ e.x, -e.y, e.z ]
                ];
                for ( var _i316 = 0; _i316 < corners.length; _i316++ ) {
                    worldCornerTempPos.set( corners[ _i316 ][ 0 ], corners[ _i316 ][ 1 ], corners[ _i316 ][ 2 ] );
                    quat.vmult( worldCornerTempPos, worldCornerTempPos );
                    pos.vadd( worldCornerTempPos, worldCornerTempPos );
                    callback( worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z );
                }
            }
            /**
             * calculateWorldAABB
             */
        }, {
            key: "calculateWorldAABB",
            value: function calculateWorldAABB( pos, quat, min, max ) {
                var e = this.halfExtents;
                worldCornersTemp[ 0 ].set( e.x, e.y, e.z );
                worldCornersTemp[ 1 ].set( -e.x, e.y, e.z );
                worldCornersTemp[ 2 ].set( -e.x, -e.y, e.z );
                worldCornersTemp[ 3 ].set( -e.x, -e.y, -e.z );
                worldCornersTemp[ 4 ].set( e.x, -e.y, -e.z );
                worldCornersTemp[ 5 ].set( e.x, e.y, -e.z );
                worldCornersTemp[ 6 ].set( -e.x, e.y, -e.z );
                worldCornersTemp[ 7 ].set( e.x, -e.y, e.z );
                var wc = worldCornersTemp[ 0 ];
                quat.vmult( wc, wc );
                pos.vadd( wc, wc );
                max.copy( wc );
                min.copy( wc );
                for ( var _i317 = 1; _i317 < 8; _i317++ ) {
                    var _wc = worldCornersTemp[ _i317 ];
                    quat.vmult( _wc, _wc );
                    pos.vadd( _wc, _wc );
                    var _x19 = _wc.x;
                    var y = _wc.y;
                    var z = _wc.z;
                    if ( _x19 > max.x ) {
                        max.x = _x19;
                    }
                    if ( y > max.y ) {
                        max.y = y;
                    }
                    if ( z > max.z ) {
                        max.z = z;
                    }
                    if ( _x19 < min.x ) {
                        min.x = _x19;
                    }
                    if ( y < min.y ) {
                        min.y = y;
                    }
                    if ( z < min.z ) {
                        min.z = z;
                    }
                } // Get each axis max
                // min.set(Infinity,Infinity,Infinity);
                // max.set(-Infinity,-Infinity,-Infinity);
                // this.forEachWorldCorner(pos,quat,function(x,y,z){
                //     if(x > max.x){
                //         max.x = x;
                //     }
                //     if(y > max.y){
                //         max.y = y;
                //     }
                //     if(z > max.z){
                //         max.z = z;
                //     }
                //     if(x < min.x){
                //         min.x = x;
                //     }
                //     if(y < min.y){
                //         min.y = y;
                //     }
                //     if(z < min.z){
                //         min.z = z;
                //     }
                // });
            }
        } ], [ {
            key: "calculateInertia",
            value: function calculateInertia( halfExtents, mass, target ) {
                var e = halfExtents;
                target.x = 1.0 / 12.0 * mass * ( 2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z );
                target.y = 1.0 / 12.0 * mass * ( 2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z );
                target.z = 1.0 / 12.0 * mass * ( 2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x );
            }
        } ] );
        return Box;
    }( Shape );
    var worldCornerTempPos = new Vec3( );
    var worldCornersTemp = [ new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ) ];
    /**
     * BODY_TYPES
     */
    var BODY_TYPES = {
        /** DYNAMIC */
        DYNAMIC: 1,
        /** STATIC */ STATIC: 2,
        /** KINEMATIC */ KINEMATIC: 4
    };
    /**
     * BodyType
     */
    /**
     * BODY_SLEEP_STATES
     */
    var BODY_SLEEP_STATES = {
        /** AWAKE */
        AWAKE: 0,
        /** SLEEPY */ SLEEPY: 1,
        /** SLEEPING */ SLEEPING: 2
    };
    /**
     * BodySleepState
     */
    /**
     * Base class for all body types.
     * @example
     *     const shape = new CANNON.Sphere(1)
     *     const body = new CANNON.Body({
     *       mass: 1,
     *       shape,
     *     })
     *     world.addBody(body)
     */
    var Body = /*#__PURE__*/ function( _EventTarget ) {
        _inherits( Body, _EventTarget );
        var _super73 = _createSuper( Body );
        /**
         * Dispatched after two bodies collide. This event is dispatched on each
         * of the two bodies involved in the collision.
         * @event collide
         * @param body The body that was involved in the collision.
         * @param contact The details of the collision.
         */
        /**
         * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
         */
        /**
         * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
         */
        /**
         * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
         */
        /**
         * AWAKE
         */
        /**
         * SLEEPY
         */
        /**
         * SLEEPING
         */
        /**
         * Dispatched after a sleeping body has woken up.
         * @event wakeup
         */
        /**
         * Dispatched after a body has gone in to the sleepy state.
         * @event sleepy
         */
        /**
         * Dispatched after a body has fallen asleep.
         * @event sleep
         */
        function Body( options ) {
            var _this59;
            _classCallCheck( this, Body );
            if ( options === void 0 ) {
                options = {};
            }
            _this59 = _super73.call( this );
            _this59.id = Body.idCounter++;
            _this59.index = -1;
            _this59.world = null;
            _this59.vlambda = new Vec3( );
            _this59.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
            _this59.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
            _this59.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;
            _this59.position = new Vec3( );
            _this59.previousPosition = new Vec3( );
            _this59.interpolatedPosition = new Vec3( );
            _this59.initPosition = new Vec3( );
            if ( options.position ) {
                _this59.position.copy( options.position );
                _this59.previousPosition.copy( options.position );
                _this59.interpolatedPosition.copy( options.position );
                _this59.initPosition.copy( options.position );
            }
            _this59.velocity = new Vec3( );
            if ( options.velocity ) {
                _this59.velocity.copy( options.velocity );
            }
            _this59.initVelocity = new Vec3( );
            _this59.force = new Vec3( );
            var mass = typeof options.mass === 'number' ? options.mass : 0;
            _this59.mass = mass;
            _this59.invMass = mass > 0 ? 1.0 / mass : 0;
            _this59.material = options.material || null;
            _this59.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
            _this59.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;
            if ( _typeof( options.type ) === _typeof( Body.STATIC ) ) {
                _this59.type = options.type;
            }
            _this59.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
            _this59.sleepState = Body.AWAKE;
            _this59.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
            _this59.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
            _this59.timeLastSleepy = 0;
            _this59.wakeUpAfterNarrowphase = false;
            _this59.torque = new Vec3( );
            _this59.quaternion = new Quaternion( );
            _this59.initQuaternion = new Quaternion( );
            _this59.previousQuaternion = new Quaternion( );
            _this59.interpolatedQuaternion = new Quaternion( );
            if ( options.quaternion ) {
                _this59.quaternion.copy( options.quaternion );
                _this59.initQuaternion.copy( options.quaternion );
                _this59.previousQuaternion.copy( options.quaternion );
                _this59.interpolatedQuaternion.copy( options.quaternion );
            }
            _this59.angularVelocity = new Vec3( );
            if ( options.angularVelocity ) {
                _this59.angularVelocity.copy( options.angularVelocity );
            }
            _this59.initAngularVelocity = new Vec3( );
            _this59.shapes = [ ];
            _this59.shapeOffsets = [ ];
            _this59.shapeOrientations = [ ];
            _this59.inertia = new Vec3( );
            _this59.invInertia = new Vec3( );
            _this59.invInertiaWorld = new Mat3( );
            _this59.invMassSolve = 0;
            _this59.invInertiaSolve = new Vec3( );
            _this59.invInertiaWorldSolve = new Mat3( );
            _this59.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;
            _this59.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
            _this59.linearFactor = new Vec3( 1, 1, 1 );
            if ( options.linearFactor ) {
                _this59.linearFactor.copy( options.linearFactor );
            }
            _this59.angularFactor = new Vec3( 1, 1, 1 );
            if ( options.angularFactor ) {
                _this59.angularFactor.copy( options.angularFactor );
            }
            _this59.aabb = new AABB( );
            _this59.aabbNeedsUpdate = true;
            _this59.boundingRadius = 0;
            _this59.wlambda = new Vec3( );
            _this59.isTrigger = Boolean( options.isTrigger );
            if ( options.shape ) {
                _this59.addShape( options.shape );
            }
            _this59.updateMassProperties( );
            return _this59;
        }
        /**
         * Wake the body up.
         */
        _createClass( Body, [ {
            key: "wakeUp",
            value: function wakeUp( ) {
                var prevState = this.sleepState;
                this.sleepState = Body.AWAKE;
                this.wakeUpAfterNarrowphase = false;
                if ( prevState === Body.SLEEPING ) {
                    this.dispatchEvent( Body.wakeupEvent );
                }
            }
            /**
             * Force body sleep
             */
        }, {
            key: "sleep",
            value: function sleep( ) {
                this.sleepState = Body.SLEEPING;
                this.velocity.set( 0, 0, 0 );
                this.angularVelocity.set( 0, 0, 0 );
                this.wakeUpAfterNarrowphase = false;
            }
            /**
             * Called every timestep to update internal sleep timer and change sleep state if needed.
             * @param time The world time in seconds
             */
        }, {
            key: "sleepTick",
            value: function sleepTick( time ) {
                if ( this.allowSleep ) {
                    var sleepState = this.sleepState;
                    var speedSquared = this.velocity.lengthSquared( ) + this.angularVelocity.lengthSquared( );
                    var speedLimitSquared = Math.pow( this.sleepSpeedLimit, 2 );
                    if ( sleepState === Body.AWAKE && speedSquared < speedLimitSquared ) {
                        this.sleepState = Body.SLEEPY; // Sleepy
                        this.timeLastSleepy = time;
                        this.dispatchEvent( Body.sleepyEvent );
                    } else if ( sleepState === Body.SLEEPY && speedSquared > speedLimitSquared ) {
                        this.wakeUp( ); // Wake up
                    } else if ( sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit ) {
                        this.sleep( ); // Sleeping
                        this.dispatchEvent( Body.sleepEvent );
                    }
                }
            }
            /**
             * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
             */
        }, {
            key: "updateSolveMassProperties",
            value: function updateSolveMassProperties( ) {
                if ( this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC ) {
                    this.invMassSolve = 0;
                    this.invInertiaSolve.setZero( );
                    this.invInertiaWorldSolve.setZero( );
                } else {
                    this.invMassSolve = this.invMass;
                    this.invInertiaSolve.copy( this.invInertia );
                    this.invInertiaWorldSolve.copy( this.invInertiaWorld );
                }
            }
            /**
             * Convert a world point to local body frame.
             */
        }, {
            key: "pointToLocalFrame",
            value: function pointToLocalFrame( worldPoint, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                worldPoint.vsub( this.position, result );
                this.quaternion.conjugate( ).vmult( result, result );
                return result;
            }
            /**
             * Convert a world vector to local body frame.
             */
        }, {
            key: "vectorToLocalFrame",
            value: function vectorToLocalFrame( worldVector, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                this.quaternion.conjugate( ).vmult( worldVector, result );
                return result;
            }
            /**
             * Convert a local body point to world frame.
             */
        }, {
            key: "pointToWorldFrame",
            value: function pointToWorldFrame( localPoint, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                this.quaternion.vmult( localPoint, result );
                result.vadd( this.position, result );
                return result;
            }
            /**
             * Convert a local body point to world frame.
             */
        }, {
            key: "vectorToWorldFrame",
            value: function vectorToWorldFrame( localVector, result ) {
                if ( result === void 0 ) {
                    result = new Vec3( );
                }
                this.quaternion.vmult( localVector, result );
                return result;
            }
            /**
             * Add a shape to the body with a local offset and orientation.
             * @return The body object, for chainability.
             */
        }, {
            key: "addShape",
            value: function addShape( shape, _offset, _orientation ) {
                var offset = new Vec3( );
                var orientation = new Quaternion( );
                if ( _offset ) {
                    offset.copy( _offset );
                }
                if ( _orientation ) {
                    orientation.copy( _orientation );
                }
                this.shapes.push( shape );
                this.shapeOffsets.push( offset );
                this.shapeOrientations.push( orientation );
                this.updateMassProperties( );
                this.updateBoundingRadius( );
                this.aabbNeedsUpdate = true;
                shape.body = this;
                return this;
            }
            /**
             * Remove a shape from the body.
             * @return The body object, for chainability.
             */
        }, {
            key: "removeShape",
            value: function removeShape( shape ) {
                var index = this.shapes.indexOf( shape );
                if ( index === -1 ) {
                    console.warn( 'Shape does not belong to the body' );
                    return this;
                }
                this.shapes.splice( index, 1 );
                this.shapeOffsets.splice( index, 1 );
                this.shapeOrientations.splice( index, 1 );
                this.updateMassProperties( );
                this.updateBoundingRadius( );
                this.aabbNeedsUpdate = true;
                shape.body = null;
                return this;
            }
            /**
             * Update the bounding radius of the body. Should be done if any of the shapes are changed.
             */
        }, {
            key: "updateBoundingRadius",
            value: function updateBoundingRadius( ) {
                var shapes = this.shapes;
                var shapeOffsets = this.shapeOffsets;
                var N = shapes.length;
                var radius = 0;
                for ( var _i318 = 0; _i318 !== N; _i318++ ) {
                    var shape = shapes[ _i318 ];
                    shape.updateBoundingSphereRadius( );
                    var offset = shapeOffsets[ _i318 ].length( );
                    var r = shape.boundingSphereRadius;
                    if ( offset + r > radius ) {
                        radius = offset + r;
                    }
                }
                this.boundingRadius = radius;
            }
            /**
             * Updates the .aabb
             */
        }, {
            key: "updateAABB",
            value: function updateAABB( ) {
                var shapes = this.shapes;
                var shapeOffsets = this.shapeOffsets;
                var shapeOrientations = this.shapeOrientations;
                var N = shapes.length;
                var offset = tmpVec;
                var orientation = tmpQuat;
                var bodyQuat = this.quaternion;
                var aabb = this.aabb;
                var shapeAABB = updateAABB_shapeAABB;
                for ( var _i319 = 0; _i319 !== N; _i319++ ) {
                    var shape = shapes[ _i319 ]; // Get shape world position
                    bodyQuat.vmult( shapeOffsets[ _i319 ], offset );
                    offset.vadd( this.position, offset ); // Get shape world quaternion
                    bodyQuat.mult( shapeOrientations[ _i319 ], orientation ); // Get shape AABB
                    shape.calculateWorldAABB( offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound );
                    if ( _i319 === 0 ) {
                        aabb.copy( shapeAABB );
                    } else {
                        aabb.extend( shapeAABB );
                    }
                }
                this.aabbNeedsUpdate = false;
            }
            /**
             * Update `.inertiaWorld` and `.invInertiaWorld`
             */
        }, {
            key: "updateInertiaWorld",
            value: function updateInertiaWorld( force ) {
                var I = this.invInertia;
                if ( I.x === I.y && I.y === I.z && !force );
                else {
                    var m1 = uiw_m1;
                    var m2 = uiw_m2;
                    uiw_m3;
                    m1.setRotationFromQuaternion( this.quaternion );
                    m1.transpose( m2 );
                    m1.scale( I, m1 );
                    m1.mmult( m2, this.invInertiaWorld );
                }
            }
            /**
             * Apply force to a point of the body. This could for example be a point on the Body surface.
             * Applying force this way will add to Body.force and Body.torque.
             * @param force The amount of force to add.
             * @param relativePoint A point relative to the center of mass to apply the force on.
             */
        }, {
            key: "applyForce",
            value: function applyForce( force, relativePoint ) {
                if ( relativePoint === void 0 ) {
                    relativePoint = new Vec3( );
                } // Needed?
                if ( this.type !== Body.DYNAMIC ) {
                    return;
                }
                if ( this.sleepState === Body.SLEEPING ) {
                    this.wakeUp( );
                } // Compute produced rotational force
                var rotForce = Body_applyForce_rotForce;
                relativePoint.cross( force, rotForce ); // Add linear force
                this.force.vadd( force, this.force ); // Add rotational force
                this.torque.vadd( rotForce, this.torque );
            }
            /**
             * Apply force to a local point in the body.
             * @param force The force vector to apply, defined locally in the body frame.
             * @param localPoint A local point in the body to apply the force on.
             */
        }, {
            key: "applyLocalForce",
            value: function applyLocalForce( localForce, localPoint ) {
                if ( localPoint === void 0 ) {
                    localPoint = new Vec3( );
                }
                if ( this.type !== Body.DYNAMIC ) {
                    return;
                }
                var worldForce = Body_applyLocalForce_worldForce;
                var relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space
                this.vectorToWorldFrame( localForce, worldForce );
                this.vectorToWorldFrame( localPoint, relativePointWorld );
                this.applyForce( worldForce, relativePointWorld );
            }
            /**
             * Apply torque to the body.
             * @param torque The amount of torque to add.
             */
        }, {
            key: "applyTorque",
            value: function applyTorque( torque ) {
                if ( this.type !== Body.DYNAMIC ) {
                    return;
                }
                if ( this.sleepState === Body.SLEEPING ) {
                    this.wakeUp( );
                } // Add rotational force
                this.torque.vadd( torque, this.torque );
            }
            /**
             * Apply impulse to a point of the body. This could for example be a point on the Body surface.
             * An impulse is a force added to a body during a short period of time (impulse = force * time).
             * Impulses will be added to Body.velocity and Body.angularVelocity.
             * @param impulse The amount of impulse to add.
             * @param relativePoint A point relative to the center of mass to apply the force on.
             */
        }, {
            key: "applyImpulse",
            value: function applyImpulse( impulse, relativePoint ) {
                if ( relativePoint === void 0 ) {
                    relativePoint = new Vec3( );
                }
                if ( this.type !== Body.DYNAMIC ) {
                    return;
                }
                if ( this.sleepState === Body.SLEEPING ) {
                    this.wakeUp( );
                } // Compute point position relative to the body center
                var r = relativePoint; // Compute produced central impulse velocity
                var velo = Body_applyImpulse_velo;
                velo.copy( impulse );
                velo.scale( this.invMass, velo ); // Add linear impulse
                this.velocity.vadd( velo, this.velocity ); // Compute produced rotational impulse velocity
                var rotVelo = Body_applyImpulse_rotVelo;
                r.cross( impulse, rotVelo );
                /*
                	     rotVelo.x *= this.invInertia.x;
                	     rotVelo.y *= this.invInertia.y;
                	     rotVelo.z *= this.invInertia.z;
                	     */
                this.invInertiaWorld.vmult( rotVelo, rotVelo ); // Add rotational Impulse
                this.angularVelocity.vadd( rotVelo, this.angularVelocity );
            }
            /**
             * Apply locally-defined impulse to a local point in the body.
             * @param force The force vector to apply, defined locally in the body frame.
             * @param localPoint A local point in the body to apply the force on.
             */
        }, {
            key: "applyLocalImpulse",
            value: function applyLocalImpulse( localImpulse, localPoint ) {
                if ( localPoint === void 0 ) {
                    localPoint = new Vec3( );
                }
                if ( this.type !== Body.DYNAMIC ) {
                    return;
                }
                var worldImpulse = Body_applyLocalImpulse_worldImpulse;
                var relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space
                this.vectorToWorldFrame( localImpulse, worldImpulse );
                this.vectorToWorldFrame( localPoint, relativePointWorld );
                this.applyImpulse( worldImpulse, relativePointWorld );
            }
            /**
             * Should be called whenever you change the body shape or mass.
             */
        }, {
            key: "updateMassProperties",
            value: function updateMassProperties( ) {
                var halfExtents = Body_updateMassProperties_halfExtents;
                this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
                var I = this.inertia;
                var fixed = this.fixedRotation; // Approximate with AABB box
                this.updateAABB( );
                halfExtents.set( ( this.aabb.upperBound.x - this.aabb.lowerBound.x ) / 2, ( this.aabb.upperBound.y - this.aabb.lowerBound.y ) / 2, ( this.aabb.upperBound.z - this.aabb.lowerBound.z ) / 2 );
                Box.calculateInertia( halfExtents, this.mass, I );
                this.invInertia.set( I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0 );
                this.updateInertiaWorld( true );
            }
            /**
             * Get world velocity of a point in the body.
             * @param worldPoint
             * @param result
             * @return The result vector.
             */
        }, {
            key: "getVelocityAtWorldPoint",
            value: function getVelocityAtWorldPoint( worldPoint, result ) {
                var r = new Vec3( );
                worldPoint.vsub( this.position, r );
                this.angularVelocity.cross( r, result );
                this.velocity.vadd( result, result );
                return result;
            }
            /**
             * Move the body forward in time.
             * @param dt Time step
             * @param quatNormalize Set to true to normalize the body quaternion
             * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
             */
        }, {
            key: "integrate",
            value: function integrate( dt, quatNormalize, quatNormalizeFast ) { // Save previous position
                this.previousPosition.copy( this.position );
                this.previousQuaternion.copy( this.quaternion );
                if ( !( this.type === Body.DYNAMIC || this.type === Body.KINEMATIC ) || this.sleepState === Body.SLEEPING ) { // Only for dynamic
                    return;
                }
                var velo = this.velocity;
                var angularVelo = this.angularVelocity;
                var pos = this.position;
                var force = this.force;
                var torque = this.torque;
                var quat = this.quaternion;
                var invMass = this.invMass;
                var invInertia = this.invInertiaWorld;
                var linearFactor = this.linearFactor;
                var iMdt = invMass * dt;
                velo.x += force.x * iMdt * linearFactor.x;
                velo.y += force.y * iMdt * linearFactor.y;
                velo.z += force.z * iMdt * linearFactor.z;
                var e = invInertia.elements;
                var angularFactor = this.angularFactor;
                var tx = torque.x * angularFactor.x;
                var ty = torque.y * angularFactor.y;
                var tz = torque.z * angularFactor.z;
                angularVelo.x += dt * ( e[ 0 ] * tx + e[ 1 ] * ty + e[ 2 ] * tz );
                angularVelo.y += dt * ( e[ 3 ] * tx + e[ 4 ] * ty + e[ 5 ] * tz );
                angularVelo.z += dt * ( e[ 6 ] * tx + e[ 7 ] * ty + e[ 8 ] * tz ); // Use new velocity  - leap frog
                pos.x += velo.x * dt;
                pos.y += velo.y * dt;
                pos.z += velo.z * dt;
                quat.integrate( this.angularVelocity, dt, this.angularFactor, quat );
                if ( quatNormalize ) {
                    if ( quatNormalizeFast ) {
                        quat.normalizeFast( );
                    } else {
                        quat.normalize( );
                    }
                }
                this.aabbNeedsUpdate = true; // Update world inertia
                this.updateInertiaWorld( );
            }
        } ] );
        return Body;
    }( EventTarget );
    Body.idCounter = 0;
    Body.COLLIDE_EVENT_NAME = 'collide';
    Body.DYNAMIC = BODY_TYPES.DYNAMIC;
    Body.STATIC = BODY_TYPES.STATIC;
    Body.KINEMATIC = BODY_TYPES.KINEMATIC;
    Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
    Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
    Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
    Body.wakeupEvent = {
        type: 'wakeup'
    };
    Body.sleepyEvent = {
        type: 'sleepy'
    };
    Body.sleepEvent = {
        type: 'sleep'
    };
    var tmpVec = new Vec3( );
    var tmpQuat = new Quaternion( );
    var updateAABB_shapeAABB = new AABB( );
    var uiw_m1 = new Mat3( );
    var uiw_m2 = new Mat3( );
    var uiw_m3 = new Mat3( );
    var Body_applyForce_rotForce = new Vec3( );
    var Body_applyLocalForce_worldForce = new Vec3( );
    var Body_applyLocalForce_relativePointWorld = new Vec3( );
    var Body_applyImpulse_velo = new Vec3( );
    var Body_applyImpulse_rotVelo = new Vec3( );
    var Body_applyLocalImpulse_worldImpulse = new Vec3( );
    var Body_applyLocalImpulse_relativePoint = new Vec3( );
    var Body_updateMassProperties_halfExtents = new Vec3( );
    /**
     * Base class for broadphase implementations
     * @author schteppe
     */
    var Broadphase = /*#__PURE__*/ function( ) {
        /**
         * The world to search for collisions in.
         */
        /**
         * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
         */
        /**
         * Set to true if the objects in the world moved.
         */
        function Broadphase( ) {
            _classCallCheck( this, Broadphase );
            this.world = null;
            this.useBoundingBoxes = false;
            this.dirty = true;
        }
        /**
         * Get the collision pairs from the world
         * @param world The world to search in
         * @param p1 Empty array to be filled with body objects
         * @param p2 Empty array to be filled with body objects
         */
        _createClass( Broadphase, [ {
            key: "collisionPairs",
            value: function collisionPairs( world, p1, p2 ) {
                throw new Error( 'collisionPairs not implemented for this BroadPhase class!' );
            }
            /**
             * Check if a body pair needs to be intersection tested at all.
             */
        }, {
            key: "needBroadphaseCollision",
            value: function needBroadphaseCollision( bodyA, bodyB ) { // Check collision filter masks
                if ( ( bodyA.collisionFilterGroup & bodyB.collisionFilterMask ) === 0 || ( bodyB.collisionFilterGroup & bodyA.collisionFilterMask ) === 0 ) {
                    return false;
                } // Check types
                if ( ( ( bodyA.type & Body.STATIC ) !== 0 || bodyA.sleepState === Body.SLEEPING ) && ( ( bodyB.type & Body.STATIC ) !== 0 || bodyB.sleepState === Body.SLEEPING ) ) { // Both bodies are static or sleeping. Skip.
                    return false;
                }
                return true;
            }
            /**
             * Check if the bounding volumes of two bodies intersect.
             */
        }, {
            key: "intersectionTest",
            value: function intersectionTest( bodyA, bodyB, pairs1, pairs2 ) {
                if ( this.useBoundingBoxes ) {
                    this.doBoundingBoxBroadphase( bodyA, bodyB, pairs1, pairs2 );
                } else {
                    this.doBoundingSphereBroadphase( bodyA, bodyB, pairs1, pairs2 );
                }
            }
            /**
             * Check if the bounding spheres of two bodies are intersecting.
             * @param pairs1 bodyA is appended to this array if intersection
             * @param pairs2 bodyB is appended to this array if intersection
             */
        }, {
            key: "doBoundingSphereBroadphase",
            value: function doBoundingSphereBroadphase( bodyA, bodyB, pairs1, pairs2 ) {
                var r = Broadphase_collisionPairs_r;
                bodyB.position.vsub( bodyA.position, r );
                var boundingRadiusSum2 = Math.pow( bodyA.boundingRadius + bodyB.boundingRadius, 2 );
                var norm2 = r.lengthSquared( );
                if ( norm2 < boundingRadiusSum2 ) {
                    pairs1.push( bodyA );
                    pairs2.push( bodyB );
                }
            }
            /**
             * Check if the bounding boxes of two bodies are intersecting.
             */
        }, {
            key: "doBoundingBoxBroadphase",
            value: function doBoundingBoxBroadphase( bodyA, bodyB, pairs1, pairs2 ) {
                if ( bodyA.aabbNeedsUpdate ) {
                    bodyA.updateAABB( );
                }
                if ( bodyB.aabbNeedsUpdate ) {
                    bodyB.updateAABB( );
                } // Check AABB / AABB
                if ( bodyA.aabb.overlaps( bodyB.aabb ) ) {
                    pairs1.push( bodyA );
                    pairs2.push( bodyB );
                }
            }
            /**
             * Removes duplicate pairs from the pair arrays.
             */
        }, {
            key: "makePairsUnique",
            value: function makePairsUnique( pairs1, pairs2 ) {
                var t = Broadphase_makePairsUnique_temp;
                var p1 = Broadphase_makePairsUnique_p1;
                var p2 = Broadphase_makePairsUnique_p2;
                var N = pairs1.length;
                for ( var _i320 = 0; _i320 !== N; _i320++ ) {
                    p1[ _i320 ] = pairs1[ _i320 ];
                    p2[ _i320 ] = pairs2[ _i320 ];
                }
                pairs1.length = 0;
                pairs2.length = 0;
                for ( var _i321 = 0; _i321 !== N; _i321++ ) {
                    var id1 = p1[ _i321 ].id;
                    var id2 = p2[ _i321 ].id;
                    var key = id1 < id2 ? "".concat( id1, "," ).concat( id2 ) : "".concat( id2, "," ).concat( id1 );
                    t[ key ] = _i321;
                    t.keys.push( key );
                }
                for ( var _i322 = 0; _i322 !== t.keys.length; _i322++ ) {
                    var _key3 = t.keys.pop( );
                    var pairIndex = t[ _key3 ];
                    pairs1.push( p1[ pairIndex ] );
                    pairs2.push( p2[ pairIndex ] );
                    delete t[ _key3 ];
                }
            }
            /**
             * To be implemented by subcasses
             */
        }, {
            key: "setWorld",
            value: function setWorld( world ) {}
            /**
             * Check if the bounding spheres of two bodies overlap.
             */
        }, {
            key: "aabbQuery",
            value:
                /**
                 * Returns all the bodies within the AABB.
                 */
                function aabbQuery( world, aabb, result ) {
                    console.warn( '.aabbQuery is not implemented in this Broadphase subclass.' );
                    return [ ];
                }
        } ], [ {
            key: "boundingSphereCheck",
            value: function boundingSphereCheck( bodyA, bodyB ) {
                var dist = new Vec3( ); // bsc_dist;
                bodyA.position.vsub( bodyB.position, dist );
                var sa = bodyA.shapes[ 0 ];
                var sb = bodyB.shapes[ 0 ];
                return Math.pow( sa.boundingSphereRadius + sb.boundingSphereRadius, 2 ) > dist.lengthSquared( );
            }
        } ] );
        return Broadphase;
    }( ); // Temp objects
    var Broadphase_collisionPairs_r = new Vec3( );
    new Vec3( );
    new Quaternion( );
    new Vec3( );
    var Broadphase_makePairsUnique_temp = {
        keys: [ ]
    };
    var Broadphase_makePairsUnique_p1 = [ ];
    var Broadphase_makePairsUnique_p2 = [ ];
    new Vec3( );
    new Vec3( );
    new Vec3( );
    /**
     * Naive broadphase implementation, used in lack of better ones.
     *
     * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
     */
    var NaiveBroadphase = /*#__PURE__*/ function( _Broadphase ) {
        _inherits( NaiveBroadphase, _Broadphase );
        var _super74 = _createSuper( NaiveBroadphase );
        /**
         * @todo Remove useless constructor
         */
        function NaiveBroadphase( ) {
            _classCallCheck( this, NaiveBroadphase );
            return _super74.call( this );
        }
        /**
         * Get all the collision pairs in the physics world
         */
        _createClass( NaiveBroadphase, [ {
            key: "collisionPairs",
            value: function collisionPairs( world, pairs1, pairs2 ) {
                var bodies = world.bodies;
                var n = bodies.length;
                var bi;
                var bj; // Naive N^2 ftw!
                for ( var _i323 = 0; _i323 !== n; _i323++ ) {
                    for ( var j = 0; j !== _i323; j++ ) {
                        bi = bodies[ _i323 ];
                        bj = bodies[ j ];
                        if ( !this.needBroadphaseCollision( bi, bj ) ) {
                            continue;
                        }
                        this.intersectionTest( bi, bj, pairs1, pairs2 );
                    }
                }
            }
            /**
             * Returns all the bodies within an AABB.
             * @param result An array to store resulting bodies in.
             */
        }, {
            key: "aabbQuery",
            value: function aabbQuery( world, aabb, result ) {
                if ( result === void 0 ) {
                    result = [ ];
                }
                for ( var _i324 = 0; _i324 < world.bodies.length; _i324++ ) {
                    var _b13 = world.bodies[ _i324 ];
                    if ( _b13.aabbNeedsUpdate ) {
                        _b13.updateAABB( );
                    } // Ugly hack until Body gets aabb
                    if ( _b13.aabb.overlaps( aabb ) ) {
                        result.push( _b13 );
                    }
                }
                return result;
            }
        } ] );
        return NaiveBroadphase;
    }( Broadphase );
    /**
     * Storage for Ray casting data
     */
    var RaycastResult = /*#__PURE__*/ function( ) {
        /**
         * rayFromWorld
         */
        /**
         * rayToWorld
         */
        /**
         * hitNormalWorld
         */
        /**
         * hitPointWorld
         */
        /**
         * hasHit
         */
        /**
         * shape
         */
        /**
         * body
         */
        /**
         * The index of the hit triangle, if the hit shape was a trimesh
         */
        /**
         * Distance to the hit. Will be set to -1 if there was no hit
         */
        /**
         * If the ray should stop traversing the bodies
         */
        function RaycastResult( ) {
            _classCallCheck( this, RaycastResult );
            this.rayFromWorld = new Vec3( );
            this.rayToWorld = new Vec3( );
            this.hitNormalWorld = new Vec3( );
            this.hitPointWorld = new Vec3( );
            this.hasHit = false;
            this.shape = null;
            this.body = null;
            this.hitFaceIndex = -1;
            this.distance = -1;
            this.shouldStop = false;
        }
        /**
         * Reset all result data.
         */
        _createClass( RaycastResult, [ {
            key: "reset",
            value: function reset( ) {
                this.rayFromWorld.setZero( );
                this.rayToWorld.setZero( );
                this.hitNormalWorld.setZero( );
                this.hitPointWorld.setZero( );
                this.hasHit = false;
                this.shape = null;
                this.body = null;
                this.hitFaceIndex = -1;
                this.distance = -1;
                this.shouldStop = false;
            }
            /**
             * abort
             */
        }, {
            key: "abort",
            value: function abort( ) {
                this.shouldStop = true;
            }
            /**
             * Set result data.
             */
        }, {
            key: "set",
            value: function set( rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance ) {
                this.rayFromWorld.copy( rayFromWorld );
                this.rayToWorld.copy( rayToWorld );
                this.hitNormalWorld.copy( hitNormalWorld );
                this.hitPointWorld.copy( hitPointWorld );
                this.shape = shape;
                this.body = body;
                this.distance = distance;
            }
        } ] );
        return RaycastResult;
    }( );
    var _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;
    /**
     * RAY_MODES
     */
    var RAY_MODES = {
        /** CLOSEST */
        CLOSEST: 1,
        /** ANY */ ANY: 2,
        /** ALL */ ALL: 4
    };
    /**
     * RayMode
     */
    _Shape$types$SPHERE = Shape.types.SPHERE;
    _Shape$types$PLANE = Shape.types.PLANE;
    _Shape$types$BOX = Shape.types.BOX;
    _Shape$types$CYLINDER = Shape.types.CYLINDER;
    _Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;
    _Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;
    _Shape$types$TRIMESH = Shape.types.TRIMESH;
    /**
     * A line in 3D space that intersects bodies and return points.
     */
    var Ray = /*#__PURE__*/ function( _Shape$types$SPHERE2, _Shape$types$PLANE2, _Shape$types$BOX2, _Shape$types$CYLINDER2, _Shape$types$CONVEXPO2, _Shape$types$HEIGHTFI2, _Shape$types$TRIMESH2 ) {
        function Ray( from, to ) {
            _classCallCheck( this, Ray );
            if ( from === void 0 ) {
                from = new Vec3( );
            }
            if ( to === void 0 ) {
                to = new Vec3( );
            }
            this.from = from.clone( );
            this.to = to.clone( );
            this.direction = new Vec3( );
            this.precision = 0.0001;
            this.checkCollisionResponse = true;
            this.skipBackfaces = false;
            this.collisionFilterMask = -1;
            this.collisionFilterGroup = -1;
            this.mode = Ray.ANY;
            this.result = new RaycastResult( );
            this.hasHit = false;
            this.callback = function( result ) {};
        }
        /**
         * Do itersection against all bodies in the given World.
         * @return True if the ray hit anything, otherwise false.
         */
        _createClass( Ray, [ {
            key: _Shape$types$SPHERE2,
            get:
                /**
                 * from
                 */
                /**
                 * to
                 */
                /**
                 * direction
                 */
                /**
                 * The precision of the ray. Used when checking parallelity etc.
                 * @default 0.0001
                 */
                /**
                 * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
                 * @default true
                 */
                /**
                 * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
                 * @default false
                 */
                /**
                 * collisionFilterMask
                 * @default -1
                 */
                /**
                 * collisionFilterGroup
                 * @default -1
                 */
                /**
                 * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
                 * @default RAY.ANY
                 */
                /**
                 * Current result object.
                 */
                /**
                 * Will be set to `true` during intersectWorld() if the ray hit anything.
                 */
                /**
                 * User-provided result callback. Will be used if mode is Ray.ALL.
                 */
                /**
                 * CLOSEST
                 */
                /**
                 * ANY
                 */
                /**
                 * ALL
                 */
                function get( ) {
                    return this._intersectSphere;
                }
        }, {
            key: _Shape$types$PLANE2,
            get: function get( ) {
                return this._intersectPlane;
            }
        }, {
            key: _Shape$types$BOX2,
            get: function get( ) {
                return this._intersectBox;
            }
        }, {
            key: _Shape$types$CYLINDER2,
            get: function get( ) {
                return this._intersectConvex;
            }
        }, {
            key: _Shape$types$CONVEXPO2,
            get: function get( ) {
                return this._intersectConvex;
            }
        }, {
            key: _Shape$types$HEIGHTFI2,
            get: function get( ) {
                return this._intersectHeightfield;
            }
        }, {
            key: _Shape$types$TRIMESH2,
            get: function get( ) {
                return this._intersectTrimesh;
            }
        }, {
            key: "intersectWorld",
            value: function intersectWorld( world, options ) {
                this.mode = options.mode || Ray.ANY;
                this.result = options.result || new RaycastResult( );
                this.skipBackfaces = !!options.skipBackfaces;
                this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
                this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;
                this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;
                if ( options.from ) {
                    this.from.copy( options.from );
                }
                if ( options.to ) {
                    this.to.copy( options.to );
                }
                this.callback = options.callback || function( ) {};
                this.hasHit = false;
                this.result.reset( );
                this.updateDirection( );
                this.getAABB( tmpAABB$1 );
                tmpArray.length = 0;
                world.broadphase.aabbQuery( world, tmpAABB$1, tmpArray );
                this.intersectBodies( tmpArray );
                return this.hasHit;
            }
            /**
             * Shoot a ray at a body, get back information about the hit.
             * @deprecated @param result set the result property of the Ray instead.
             */
        }, {
            key: "intersectBody",
            value: function intersectBody( body, result ) {
                if ( result ) {
                    this.result = result;
                    this.updateDirection( );
                }
                var checkCollisionResponse = this.checkCollisionResponse;
                if ( checkCollisionResponse && !body.collisionResponse ) {
                    return;
                }
                if ( ( this.collisionFilterGroup & body.collisionFilterMask ) === 0 || ( body.collisionFilterGroup & this.collisionFilterMask ) === 0 ) {
                    return;
                }
                var xi = intersectBody_xi;
                var qi = intersectBody_qi;
                for ( var _i325 = 0, N = body.shapes.length; _i325 < N; _i325++ ) {
                    var shape = body.shapes[ _i325 ];
                    if ( checkCollisionResponse && !shape.collisionResponse ) {
                        continue; // Skip
                    }
                    body.quaternion.mult( body.shapeOrientations[ _i325 ], qi );
                    body.quaternion.vmult( body.shapeOffsets[ _i325 ], xi );
                    xi.vadd( body.position, xi );
                    this.intersectShape( shape, qi, xi, body );
                    if ( this.result.shouldStop ) {
                        break;
                    }
                }
            }
            /**
             * Shoot a ray at an array bodies, get back information about the hit.
             * @param bodies An array of Body objects.
             * @deprecated @param result set the result property of the Ray instead.
             *
             */
        }, {
            key: "intersectBodies",
            value: function intersectBodies( bodies, result ) {
                if ( result ) {
                    this.result = result;
                    this.updateDirection( );
                }
                for ( var _i326 = 0, l = bodies.length; !this.result.shouldStop && _i326 < l; _i326++ ) {
                    this.intersectBody( bodies[ _i326 ] );
                }
            }
            /**
             * Updates the direction vector.
             */
        }, {
            key: "updateDirection",
            value: function updateDirection( ) {
                this.to.vsub( this.from, this.direction );
                this.direction.normalize( );
            }
        }, {
            key: "intersectShape",
            value: function intersectShape( shape, quat, position, body ) {
                var from = this.from; // Checking boundingSphere
                var distance = distanceFromIntersection( from, this.direction, position );
                if ( distance > shape.boundingSphereRadius ) {
                    return;
                }
                var intersectMethod = this[ shape.type ];
                if ( intersectMethod ) {
                    intersectMethod.call( this, shape, quat, position, body, shape );
                }
            }
        }, {
            key: "_intersectBox",
            value: function _intersectBox( box, quat, position, body, reportedShape ) {
                return this._intersectConvex( box.convexPolyhedronRepresentation, quat, position, body, reportedShape );
            }
        }, {
            key: "_intersectPlane",
            value: function _intersectPlane( shape, quat, position, body, reportedShape ) {
                var from = this.from;
                var to = this.to;
                var direction = this.direction; // Get plane normal
                var worldNormal = new Vec3( 0, 0, 1 );
                quat.vmult( worldNormal, worldNormal );
                var len = new Vec3( );
                from.vsub( position, len );
                var planeToFrom = len.dot( worldNormal );
                to.vsub( position, len );
                var planeToTo = len.dot( worldNormal );
                if ( planeToFrom * planeToTo > 0 ) { // "from" and "to" are on the same side of the plane... bail out
                    return;
                }
                if ( from.distanceTo( to ) < planeToFrom ) {
                    return;
                }
                var n_dot_dir = worldNormal.dot( direction );
                if ( Math.abs( n_dot_dir ) < this.precision ) { // No intersection
                    return;
                }
                var planePointToFrom = new Vec3( );
                var dir_scaled_with_t = new Vec3( );
                var hitPointWorld = new Vec3( );
                from.vsub( position, planePointToFrom );
                var t = -worldNormal.dot( planePointToFrom ) / n_dot_dir;
                direction.scale( t, dir_scaled_with_t );
                from.vadd( dir_scaled_with_t, hitPointWorld );
                this.reportIntersection( worldNormal, hitPointWorld, reportedShape, body, -1 );
            }
            /**
             * Get the world AABB of the ray.
             */
        }, {
            key: "getAABB",
            value: function getAABB( aabb ) {
                var lowerBound = aabb.lowerBound,
                    upperBound = aabb.upperBound;
                var to = this.to;
                var from = this.from;
                lowerBound.x = Math.min( to.x, from.x );
                lowerBound.y = Math.min( to.y, from.y );
                lowerBound.z = Math.min( to.z, from.z );
                upperBound.x = Math.max( to.x, from.x );
                upperBound.y = Math.max( to.y, from.y );
                upperBound.z = Math.max( to.z, from.z );
            }
        }, {
            key: "_intersectHeightfield",
            value: function _intersectHeightfield( shape, quat, position, body, reportedShape ) {
                shape.data;
                shape.elementSize; // Convert the ray to local heightfield coordinates
                var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);
                localRay.from.copy( this.from );
                localRay.to.copy( this.to );
                Transform.pointToLocalFrame( position, quat, localRay.from, localRay.from );
                Transform.pointToLocalFrame( position, quat, localRay.to, localRay.to );
                localRay.updateDirection( ); // Get the index of the data points to test against
                var index = intersectHeightfield_index;
                var iMinX;
                var iMinY;
                var iMaxX;
                var iMaxY; // Set to max
                iMinX = iMinY = 0;
                iMaxX = iMaxY = shape.data.length - 1;
                var aabb = new AABB( );
                localRay.getAABB( aabb );
                shape.getIndexOfPosition( aabb.lowerBound.x, aabb.lowerBound.y, index, true );
                iMinX = Math.max( iMinX, index[ 0 ] );
                iMinY = Math.max( iMinY, index[ 1 ] );
                shape.getIndexOfPosition( aabb.upperBound.x, aabb.upperBound.y, index, true );
                iMaxX = Math.min( iMaxX, index[ 0 ] + 1 );
                iMaxY = Math.min( iMaxY, index[ 1 ] + 1 );
                for ( var _i327 = iMinX; _i327 < iMaxX; _i327++ ) {
                    for ( var j = iMinY; j < iMaxY; j++ ) {
                        if ( this.result.shouldStop ) {
                            return;
                        }
                        shape.getAabbAtIndex( _i327, j, aabb );
                        if ( !aabb.overlapsRay( localRay ) ) {
                            continue;
                        } // Lower triangle
                        shape.getConvexTrianglePillar( _i327, j, false );
                        Transform.pointToWorldFrame( position, quat, shape.pillarOffset, worldPillarOffset );
                        this._intersectConvex( shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions );
                        if ( this.result.shouldStop ) {
                            return;
                        } // Upper triangle
                        shape.getConvexTrianglePillar( _i327, j, true );
                        Transform.pointToWorldFrame( position, quat, shape.pillarOffset, worldPillarOffset );
                        this._intersectConvex( shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions );
                    }
                }
            }
        }, {
            key: "_intersectSphere",
            value: function _intersectSphere( sphere, quat, position, body, reportedShape ) {
                var from = this.from;
                var to = this.to;
                var r = sphere.radius;
                var a = Math.pow( to.x - from.x, 2 ) + Math.pow( to.y - from.y, 2 ) + Math.pow( to.z - from.z, 2 );
                var b = 2 * ( ( to.x - from.x ) * ( from.x - position.x ) + ( to.y - from.y ) * ( from.y - position.y ) + ( to.z - from.z ) * ( from.z - position.z ) );
                var c = Math.pow( from.x - position.x, 2 ) + Math.pow( from.y - position.y, 2 ) + Math.pow( from.z - position.z, 2 ) - Math.pow( r, 2 );
                var delta = Math.pow( b, 2 ) - 4 * a * c;
                var intersectionPoint = Ray_intersectSphere_intersectionPoint;
                var normal = Ray_intersectSphere_normal;
                if ( delta < 0 ) { // No intersection
                    return;
                } else if ( delta === 0 ) { // single intersection point
                    from.lerp( to, delta, intersectionPoint );
                    intersectionPoint.vsub( position, normal );
                    normal.normalize( );
                    this.reportIntersection( normal, intersectionPoint, reportedShape, body, -1 );
                } else {
                    var d1 = ( -b - Math.sqrt( delta ) ) / ( 2 * a );
                    var d2 = ( -b + Math.sqrt( delta ) ) / ( 2 * a );
                    if ( d1 >= 0 && d1 <= 1 ) {
                        from.lerp( to, d1, intersectionPoint );
                        intersectionPoint.vsub( position, normal );
                        normal.normalize( );
                        this.reportIntersection( normal, intersectionPoint, reportedShape, body, -1 );
                    }
                    if ( this.result.shouldStop ) {
                        return;
                    }
                    if ( d2 >= 0 && d2 <= 1 ) {
                        from.lerp( to, d2, intersectionPoint );
                        intersectionPoint.vsub( position, normal );
                        normal.normalize( );
                        this.reportIntersection( normal, intersectionPoint, reportedShape, body, -1 );
                    }
                }
            }
        }, {
            key: "_intersectConvex",
            value: function _intersectConvex( shape, quat, position, body, reportedShape, options ) {
                var normal = intersectConvex_normal;
                var vector = intersectConvex_vector;
                var faceList = options && options.faceList || null; // Checking faces
                var faces = shape.faces;
                var vertices = shape.vertices;
                var normals = shape.faceNormals;
                var direction = this.direction;
                var from = this.from;
                var to = this.to;
                var fromToDistance = from.distanceTo( to );
                var Nfaces = faceList ? faceList.length : faces.length;
                var result = this.result;
                for ( var j = 0; !result.shouldStop && j < Nfaces; j++ ) {
                    var fi = faceList ? faceList[ j ] : j;
                    var face = faces[ fi ];
                    var faceNormal = normals[ fi ];
                    var q = quat;
                    var _x20 = position; // determine if ray intersects the plane of the face
                    // note: this works regardless of the direction of the face normal
                    // Get plane point in world coordinates...
                    vector.copy( vertices[ face[ 0 ] ] );
                    q.vmult( vector, vector );
                    vector.vadd( _x20, vector ); // ...but make it relative to the ray from. We'll fix this later.
                    vector.vsub( from, vector ); // Get plane normal
                    q.vmult( faceNormal, normal ); // If this dot product is negative, we have something interesting
                    var dot = direction.dot( normal ); // Bail out if ray and plane are parallel
                    if ( Math.abs( dot ) < this.precision ) {
                        continue;
                    } // calc distance to plane
                    var scalar = normal.dot( vector ) / dot; // if negative distance, then plane is behind ray
                    if ( scalar < 0 ) {
                        continue;
                    } // if (dot < 0) {
                    // Intersection point is from + direction * scalar
                    direction.scale( scalar, intersectPoint );
                    intersectPoint.vadd( from, intersectPoint ); // a is the point we compare points b and c with.
                    a.copy( vertices[ face[ 0 ] ] );
                    q.vmult( a, a );
                    _x20.vadd( a, a );
                    for ( var _i328 = 1; !result.shouldStop && _i328 < face.length - 1; _i328++ ) { // Transform 3 vertices to world coords
                        b.copy( vertices[ face[ _i328 ] ] );
                        c.copy( vertices[ face[ _i328 + 1 ] ] );
                        q.vmult( b, b );
                        q.vmult( c, c );
                        _x20.vadd( b, b );
                        _x20.vadd( c, c );
                        var distance = intersectPoint.distanceTo( from );
                        if ( !( Ray.pointInTriangle( intersectPoint, a, b, c ) || Ray.pointInTriangle( intersectPoint, b, a, c ) ) || distance > fromToDistance ) {
                            continue;
                        }
                        this.reportIntersection( normal, intersectPoint, reportedShape, body, fi );
                    } // }
                }
            }
            /**
             * @todo Optimize by transforming the world to local space first.
             * @todo Use Octree lookup
             */
        }, {
            key: "_intersectTrimesh",
            value: function _intersectTrimesh( mesh, quat, position, body, reportedShape, options ) {
                var normal = intersectTrimesh_normal;
                var triangles = intersectTrimesh_triangles;
                var treeTransform = intersectTrimesh_treeTransform;
                var vector = intersectConvex_vector;
                var localDirection = intersectTrimesh_localDirection;
                var localFrom = intersectTrimesh_localFrom;
                var localTo = intersectTrimesh_localTo;
                var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
                var worldNormal = intersectTrimesh_worldNormal; // Checking faces
                var indices = mesh.indices;
                mesh.vertices; // const normals = mesh.faceNormals
                var from = this.from;
                var to = this.to;
                var direction = this.direction;
                treeTransform.position.copy( position );
                treeTransform.quaternion.copy( quat ); // Transform ray to local space!
                Transform.vectorToLocalFrame( position, quat, direction, localDirection );
                Transform.pointToLocalFrame( position, quat, from, localFrom );
                Transform.pointToLocalFrame( position, quat, to, localTo );
                localTo.x *= mesh.scale.x;
                localTo.y *= mesh.scale.y;
                localTo.z *= mesh.scale.z;
                localFrom.x *= mesh.scale.x;
                localFrom.y *= mesh.scale.y;
                localFrom.z *= mesh.scale.z;
                localTo.vsub( localFrom, localDirection );
                localDirection.normalize( );
                var fromToDistanceSquared = localFrom.distanceSquared( localTo );
                mesh.tree.rayQuery( this, treeTransform, triangles );
                for ( var _i329 = 0, N = triangles.length; !this.result.shouldStop && _i329 !== N; _i329++ ) {
                    var trianglesIndex = triangles[ _i329 ];
                    mesh.getNormal( trianglesIndex, normal ); // determine if ray intersects the plane of the face
                    // note: this works regardless of the direction of the face normal
                    // Get plane point in world coordinates...
                    mesh.getVertex( indices[ trianglesIndex * 3 ], a ); // ...but make it relative to the ray from. We'll fix this later.
                    a.vsub( localFrom, vector ); // If this dot product is negative, we have something interesting
                    var dot = localDirection.dot( normal ); // Bail out if ray and plane are parallel
                    // if (Math.abs( dot ) < this.precision){
                    //     continue;
                    // }
                    // calc distance to plane
                    var scalar = normal.dot( vector ) / dot; // if negative distance, then plane is behind ray
                    if ( scalar < 0 ) {
                        continue;
                    } // Intersection point is from + direction * scalar
                    localDirection.scale( scalar, intersectPoint );
                    intersectPoint.vadd( localFrom, intersectPoint ); // Get triangle vertices
                    mesh.getVertex( indices[ trianglesIndex * 3 + 1 ], b );
                    mesh.getVertex( indices[ trianglesIndex * 3 + 2 ], c );
                    var squaredDistance = intersectPoint.distanceSquared( localFrom );
                    if ( !( Ray.pointInTriangle( intersectPoint, b, a, c ) || Ray.pointInTriangle( intersectPoint, a, b, c ) ) || squaredDistance > fromToDistanceSquared ) {
                        continue;
                    } // transform intersectpoint and normal to world
                    Transform.vectorToWorldFrame( quat, normal, worldNormal );
                    Transform.pointToWorldFrame( position, quat, intersectPoint, worldIntersectPoint );
                    this.reportIntersection( worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex );
                }
                triangles.length = 0;
            }
            /**
             * @return True if the intersections should continue
             */
        }, {
            key: "reportIntersection",
            value: function reportIntersection( normal, hitPointWorld, shape, body, hitFaceIndex ) {
                var from = this.from;
                var to = this.to;
                var distance = from.distanceTo( hitPointWorld );
                var result = this.result; // Skip back faces?
                if ( this.skipBackfaces && normal.dot( this.direction ) > 0 ) {
                    return;
                }
                result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;
                switch ( this.mode ) {
                    case Ray.ALL:
                        this.hasHit = true;
                        result.set( from, to, normal, hitPointWorld, shape, body, distance );
                        result.hasHit = true;
                        this.callback( result );
                        break;
                    case Ray.CLOSEST: // Store if closer than current closest
                        if ( distance < result.distance || !result.hasHit ) {
                            this.hasHit = true;
                            result.hasHit = true;
                            result.set( from, to, normal, hitPointWorld, shape, body, distance );
                        }
                        break;
                    case Ray.ANY: // Report and stop.
                        this.hasHit = true;
                        result.hasHit = true;
                        result.set( from, to, normal, hitPointWorld, shape, body, distance );
                        result.shouldStop = true;
                        break;
                }
            }
            /**
             * As per "Barycentric Technique" as named
             * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
             */
        } ], [ {
            key: "pointInTriangle",
            value: function pointInTriangle( p, a, b, c ) {
                c.vsub( a, v0 );
                b.vsub( a, v1 );
                p.vsub( a, v2 );
                var dot00 = v0.dot( v0 );
                var dot01 = v0.dot( v1 );
                var dot02 = v0.dot( v2 );
                var dot11 = v1.dot( v1 );
                var dot12 = v1.dot( v2 );
                var u;
                var v;
                return ( u = dot11 * dot02 - dot01 * dot12 ) >= 0 && ( v = dot00 * dot12 - dot01 * dot02 ) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
            }
        } ] );
        return Ray;
    }( _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH );
    Ray.CLOSEST = RAY_MODES.CLOSEST;
    Ray.ANY = RAY_MODES.ANY;
    Ray.ALL = RAY_MODES.ALL;
    var tmpAABB$1 = new AABB( );
    var tmpArray = [ ];
    var v1 = new Vec3( );
    var v2 = new Vec3( );
    var intersectBody_xi = new Vec3( );
    var intersectBody_qi = new Quaternion( );
    var intersectPoint = new Vec3( );
    var a = new Vec3( );
    var b = new Vec3( );
    var c = new Vec3( );
    new Vec3( );
    new RaycastResult( );
    var intersectConvexOptions = {
        faceList: [ 0 ]
    };
    var worldPillarOffset = new Vec3( );
    var intersectHeightfield_localRay = new Ray( );
    var intersectHeightfield_index = [ ];
    var Ray_intersectSphere_intersectionPoint = new Vec3( );
    var Ray_intersectSphere_normal = new Vec3( );
    var intersectConvex_normal = new Vec3( );
    new Vec3( );
    new Vec3( );
    var intersectConvex_vector = new Vec3( );
    var intersectTrimesh_normal = new Vec3( );
    var intersectTrimesh_localDirection = new Vec3( );
    var intersectTrimesh_localFrom = new Vec3( );
    var intersectTrimesh_localTo = new Vec3( );
    var intersectTrimesh_worldNormal = new Vec3( );
    var intersectTrimesh_worldIntersectPoint = new Vec3( );
    new AABB( );
    var intersectTrimesh_triangles = [ ];
    var intersectTrimesh_treeTransform = new Transform( );
    var v0 = new Vec3( );
    var intersect = new Vec3( );

    function distanceFromIntersection( from, direction, position ) { // v0 is vector from from to position
        position.vsub( from, v0 );
        var dot = v0.dot( direction ); // intersect = direction*dot + from
        direction.scale( dot, intersect );
        intersect.vadd( from, intersect );
        var distance = position.distanceTo( intersect );
        return distance;
    }
    var Utils = /*#__PURE__*/ function( ) {
        function Utils( ) {
            _classCallCheck( this, Utils );
        }
        _createClass( Utils, null, [ {
            key: "defaults",
            value:
                /**
                 * Extend an options object with default values.
                 * @param options The options object. May be falsy: in this case, a new object is created and returned.
                 * @param defaults An object containing default values.
                 * @return The modified options object.
                 */
                function defaults( options, _defaults ) {
                    if ( options === void 0 ) {
                        options = {};
                    }
                    for ( var key in _defaults ) {
                        if ( !( key in options ) ) {
                            options[ key ] = _defaults[ key ];
                        }
                    }
                    return options;
                }
        } ] );
        return Utils;
    }( );
    /**
     * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
     */
    var JacobianElement = /*#__PURE__*/ function( ) {
        /**
         * spatial
         */
        /**
         * rotational
         */
        function JacobianElement( ) {
            _classCallCheck( this, JacobianElement );
            this.spatial = new Vec3( );
            this.rotational = new Vec3( );
        }
        /**
         * Multiply with other JacobianElement
         */
        _createClass( JacobianElement, [ {
            key: "multiplyElement",
            value: function multiplyElement( element ) {
                return element.spatial.dot( this.spatial ) + element.rotational.dot( this.rotational );
            }
            /**
             * Multiply with two vectors
             */
        }, {
            key: "multiplyVectors",
            value: function multiplyVectors( spatial, rotational ) {
                return spatial.dot( this.spatial ) + rotational.dot( this.rotational );
            }
        } ] );
        return JacobianElement;
    }( );
    /**
     * Equation base class.
     *
     * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
     */
    var Equation = /*#__PURE__*/ function( ) {
        /**
         * Minimum (read: negative max) force to be applied by the constraint.
         */
        /**
         * Maximum (read: positive max) force to be applied by the constraint.
         */
        /**
         * SPOOK parameter
         */
        /**
         * SPOOK parameter
         */
        /**
         * SPOOK parameter
         */
        /**
         * A number, proportional to the force added to the bodies.
         */
        function Equation( bi, bj, minForce, maxForce ) {
            _classCallCheck( this, Equation );
            if ( minForce === void 0 ) {
                minForce = -1e6;
            }
            if ( maxForce === void 0 ) {
                maxForce = 1e6;
            }
            this.id = Equation.idCounter++;
            this.minForce = minForce;
            this.maxForce = maxForce;
            this.bi = bi;
            this.bj = bj;
            this.a = 0.0; // SPOOK parameter
            this.b = 0.0; // SPOOK parameter
            this.eps = 0.0; // SPOOK parameter
            this.jacobianElementA = new JacobianElement( );
            this.jacobianElementB = new JacobianElement( );
            this.enabled = true;
            this.multiplier = 0;
            this.setSpookParams( 1e7, 4, 1 / 60 ); // Set typical spook params
        }
        /**
         * Recalculates a, b, and eps.
         *
         * The Equation constructor sets typical SPOOK parameters as such:
         * * `stiffness` = 1e7
         * * `relaxation` = 4
         * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
         */
        _createClass( Equation, [ {
            key: "setSpookParams",
            value: function setSpookParams( stiffness, relaxation, timeStep ) {
                var d = relaxation;
                var k = stiffness;
                var h = timeStep;
                this.a = 4.0 / ( h * ( 1 + 4 * d ) );
                this.b = 4.0 * d / ( 1 + 4 * d );
                this.eps = 4.0 / ( h * h * k * ( 1 + 4 * d ) );
            }
            /**
             * Computes the right hand side of the SPOOK equation
             */
        }, {
            key: "computeB",
            value: function computeB( a, b, h ) {
                var GW = this.computeGW( );
                var Gq = this.computeGq( );
                var GiMf = this.computeGiMf( );
                return -Gq * a - GW * b - GiMf * h;
            }
            /**
             * Computes G*q, where q are the generalized body coordinates
             */
        }, {
            key: "computeGq",
            value: function computeGq( ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var xi = bi.position;
                var xj = bj.position;
                return GA.spatial.dot( xi ) + GB.spatial.dot( xj );
            }
            /**
             * Computes G*W, where W are the body velocities
             */
        }, {
            key: "computeGW",
            value: function computeGW( ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var vi = bi.velocity;
                var vj = bj.velocity;
                var wi = bi.angularVelocity;
                var wj = bj.angularVelocity;
                return GA.multiplyVectors( vi, wi ) + GB.multiplyVectors( vj, wj );
            }
            /**
             * Computes G*Wlambda, where W are the body velocities
             */
        }, {
            key: "computeGWlambda",
            value: function computeGWlambda( ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var vi = bi.vlambda;
                var vj = bj.vlambda;
                var wi = bi.wlambda;
                var wj = bj.wlambda;
                return GA.multiplyVectors( vi, wi ) + GB.multiplyVectors( vj, wj );
            }
            /**
             * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
             */
        }, {
            key: "computeGiMf",
            value: function computeGiMf( ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var fi = bi.force;
                var ti = bi.torque;
                var fj = bj.force;
                var tj = bj.torque;
                var invMassi = bi.invMassSolve;
                var invMassj = bj.invMassSolve;
                fi.scale( invMassi, iMfi );
                fj.scale( invMassj, iMfj );
                bi.invInertiaWorldSolve.vmult( ti, invIi_vmult_taui );
                bj.invInertiaWorldSolve.vmult( tj, invIj_vmult_tauj );
                return GA.multiplyVectors( iMfi, invIi_vmult_taui ) + GB.multiplyVectors( iMfj, invIj_vmult_tauj );
            }
            /**
             * Computes G*inv(M)*G'
             */
        }, {
            key: "computeGiMGt",
            value: function computeGiMGt( ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var invMassi = bi.invMassSolve;
                var invMassj = bj.invMassSolve;
                var invIi = bi.invInertiaWorldSolve;
                var invIj = bj.invInertiaWorldSolve;
                var result = invMassi + invMassj;
                invIi.vmult( GA.rotational, tmp );
                result += tmp.dot( GA.rotational );
                invIj.vmult( GB.rotational, tmp );
                result += tmp.dot( GB.rotational );
                return result;
            }
            /**
             * Add constraint velocity to the bodies.
             */
        }, {
            key: "addToWlambda",
            value: function addToWlambda( deltalambda ) {
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var bi = this.bi;
                var bj = this.bj;
                var temp = addToWlambda_temp; // Add to linear velocity
                // v_lambda += inv(M) * delta_lamba * G
                bi.vlambda.addScaledVector( bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda );
                bj.vlambda.addScaledVector( bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda ); // Add to angular velocity
                bi.invInertiaWorldSolve.vmult( GA.rotational, temp );
                bi.wlambda.addScaledVector( deltalambda, temp, bi.wlambda );
                bj.invInertiaWorldSolve.vmult( GB.rotational, temp );
                bj.wlambda.addScaledVector( deltalambda, temp, bj.wlambda );
            }
            /**
             * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
             */
        }, {
            key: "computeC",
            value: function computeC( ) {
                return this.computeGiMGt( ) + this.eps;
            }
        } ] );
        return Equation;
    }( );
    Equation.idCounter = 0;
    var iMfi = new Vec3( );
    var iMfj = new Vec3( );
    var invIi_vmult_taui = new Vec3( );
    var invIj_vmult_tauj = new Vec3( );
    var tmp = new Vec3( );
    var addToWlambda_temp = new Vec3( );
    /**
     * Contact/non-penetration constraint equation
     */
    var ContactEquation = /*#__PURE__*/ function( _Equation ) {
        _inherits( ContactEquation, _Equation );
        var _super75 = _createSuper( ContactEquation );
        /**
         * "bounciness": u1 = -e*u0
         */
        /**
         * World-oriented vector that goes from the center of bi to the contact point.
         */
        /**
         * World-oriented vector that starts in body j position and goes to the contact point.
         */
        /**
         * Contact normal, pointing out of body i.
         */
        function ContactEquation( bodyA, bodyB, maxForce ) {
            var _this60;
            _classCallCheck( this, ContactEquation );
            if ( maxForce === void 0 ) {
                maxForce = 1e6;
            }
            _this60 = _super75.call( this, bodyA, bodyB, 0, maxForce );
            _this60.restitution = 0.0;
            _this60.ri = new Vec3( );
            _this60.rj = new Vec3( );
            _this60.ni = new Vec3( );
            return _this60;
        }
        _createClass( ContactEquation, [ {
            key: "computeB",
            value: function computeB( h ) {
                var a = this.a;
                var b = this.b;
                var bi = this.bi;
                var bj = this.bj;
                var ri = this.ri;
                var rj = this.rj;
                var rixn = ContactEquation_computeB_temp1;
                var rjxn = ContactEquation_computeB_temp2;
                var vi = bi.velocity;
                var wi = bi.angularVelocity;
                bi.force;
                bi.torque;
                var vj = bj.velocity;
                var wj = bj.angularVelocity;
                bj.force;
                bj.torque;
                var penetrationVec = ContactEquation_computeB_temp3;
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                var n = this.ni; // Caluclate cross products
                ri.cross( n, rixn );
                rj.cross( n, rjxn ); // g = xj+rj -(xi+ri)
                // G = [ -ni  -rixn  ni  rjxn ]
                n.negate( GA.spatial );
                rixn.negate( GA.rotational );
                GB.spatial.copy( n );
                GB.rotational.copy( rjxn ); // Calculate the penetration vector
                penetrationVec.copy( bj.position );
                penetrationVec.vadd( rj, penetrationVec );
                penetrationVec.vsub( bi.position, penetrationVec );
                penetrationVec.vsub( ri, penetrationVec );
                var g = n.dot( penetrationVec ); // Compute iteration
                var ePlusOne = this.restitution + 1;
                var GW = ePlusOne * vj.dot( n ) - ePlusOne * vi.dot( n ) + wj.dot( rjxn ) - wi.dot( rixn );
                var GiMf = this.computeGiMf( );
                var B = -g * a - GW * b - h * GiMf;
                return B;
            }
            /**
             * Get the current relative velocity in the contact point.
             */
        }, {
            key: "getImpactVelocityAlongNormal",
            value: function getImpactVelocityAlongNormal( ) {
                var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
                var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
                var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
                var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
                var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
                this.bi.position.vadd( this.ri, xi );
                this.bj.position.vadd( this.rj, xj );
                this.bi.getVelocityAtWorldPoint( xi, vi );
                this.bj.getVelocityAtWorldPoint( xj, vj );
                vi.vsub( vj, relVel );
                return this.ni.dot( relVel );
            }
        } ] );
        return ContactEquation;
    }( Equation );
    var ContactEquation_computeB_temp1 = new Vec3( ); // Temp vectors
    var ContactEquation_computeB_temp2 = new Vec3( );
    var ContactEquation_computeB_temp3 = new Vec3( );
    var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3( );
    var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3( );
    var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3( );
    var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3( );
    var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    /**
     * Constrains the slipping in a contact along a tangent
     */
    var FrictionEquation = /*#__PURE__*/ function( _Equation2 ) {
        _inherits( FrictionEquation, _Equation2 );
        var _super76 = _createSuper( FrictionEquation ); // Tangent
        /**
         * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
         */
        function FrictionEquation( bodyA, bodyB, slipForce ) {
            var _this61;
            _classCallCheck( this, FrictionEquation );
            _this61 = _super76.call( this, bodyA, bodyB, -slipForce, slipForce );
            _this61.ri = new Vec3( );
            _this61.rj = new Vec3( );
            _this61.t = new Vec3( );
            return _this61;
        }
        _createClass( FrictionEquation, [ {
            key: "computeB",
            value: function computeB( h ) {
                this.a;
                var b = this.b;
                this.bi;
                this.bj;
                var ri = this.ri;
                var rj = this.rj;
                var rixt = FrictionEquation_computeB_temp1;
                var rjxt = FrictionEquation_computeB_temp2;
                var t = this.t; // Caluclate cross products
                ri.cross( t, rixt );
                rj.cross( t, rjxt ); // G = [-t -rixt t rjxt]
                // And remember, this is a pure velocity constraint, g is always zero!
                var GA = this.jacobianElementA;
                var GB = this.jacobianElementB;
                t.negate( GA.spatial );
                rixt.negate( GA.rotational );
                GB.spatial.copy( t );
                GB.rotational.copy( rjxt );
                var GW = this.computeGW( );
                var GiMf = this.computeGiMf( );
                var B = -GW * b - h * GiMf;
                return B;
            }
        } ] );
        return FrictionEquation;
    }( Equation );
    var FrictionEquation_computeB_temp1 = new Vec3( );
    var FrictionEquation_computeB_temp2 = new Vec3( );
    /**
     * Defines what happens when two materials meet.
     * @todo Refactor materials to materialA and materialB
     */
    var ContactMaterial = /*#__PURE__*/ _createClass(
        /**
         * Identifier of this material.
         */
        /**
         * Participating materials.
         */
        /**
         * Friction coefficient.
         * @default 0.3
         */
        /**
         * Restitution coefficient.
         * @default 0.3
         */
        /**
         * Stiffness of the produced contact equations.
         * @default 1e7
         */
        /**
         * Relaxation time of the produced contact equations.
         * @default 3
         */
        /**
         * Stiffness of the produced friction equations.
         * @default 1e7
         */
        /**
         * Relaxation time of the produced friction equations
         * @default 3
         */
        function ContactMaterial( m1, m2, options ) {
            _classCallCheck( this, ContactMaterial );
            options = Utils.defaults( options, {
                friction: 0.3,
                restitution: 0.3,
                contactEquationStiffness: 1e7,
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e7,
                frictionEquationRelaxation: 3
            } );
            this.id = ContactMaterial.idCounter++;
            this.materials = [ m1, m2 ];
            this.friction = options.friction;
            this.restitution = options.restitution;
            this.contactEquationStiffness = options.contactEquationStiffness;
            this.contactEquationRelaxation = options.contactEquationRelaxation;
            this.frictionEquationStiffness = options.frictionEquationStiffness;
            this.frictionEquationRelaxation = options.frictionEquationRelaxation;
        } );
    ContactMaterial.idCounter = 0;
    /**
     * Defines a physics material.
     */
    var Material = /*#__PURE__*/ _createClass(
        /**
         * Material name.
         * If options is a string, name will be set to that string.
         * @todo Deprecate this
         */
        /** Material id. */
        /**
         * Friction for this material.
         * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
         */
        /**
         * Restitution for this material.
         * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
         */
        function Material( options ) {
            _classCallCheck( this, Material );
            if ( options === void 0 ) {
                options = {};
            }
            var name = ''; // Backwards compatibility fix
            if ( typeof options === 'string' ) { //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)
                name = options;
                options = {};
            }
            this.name = name;
            this.id = Material.idCounter++;
            this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
            this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
        } );
    Material.idCounter = 0;
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Ray( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    [ new Vec3( 1, 0, 0 ), new Vec3( 0, 1, 0 ), new Vec3( 0, 0, 1 ) ];
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( ); // bilateral constraint between two dynamic objects
    new Vec3( );
    new Vec3( );
    new Vec3( ); // Temp vectors for calculation
    new Vec3( ); // Relative velocity
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( ); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system
    new Vec3( );
    new AABB( );
    new Vec3( );
    new AABB( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new Vec3( );
    new AABB( );
    new Vec3( );
    new Transform( );
    new AABB( );
    /**
     * Constraint equation solver base class.
     */
    var Solver = /*#__PURE__*/ function( ) {
        /**
         * All equations to be solved
         */
        /**
         * @todo remove useless constructor
         */
        function Solver( ) {
            _classCallCheck( this, Solver );
            this.equations = [ ];
        }
        /**
         * Should be implemented in subclasses!
         * @todo use abstract
         * @return number of iterations performed
         */
        _createClass( Solver, [ {
            key: "solve",
            value: function solve( dt, world ) {
                return ( // Should return the number of iterations done!
                    0 );
            }
            /**
             * Add an equation
             */
        }, {
            key: "addEquation",
            value: function addEquation( eq ) {
                if ( eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger ) {
                    this.equations.push( eq );
                }
            }
            /**
             * Remove an equation
             */
        }, {
            key: "removeEquation",
            value: function removeEquation( eq ) {
                var eqs = this.equations;
                var i = eqs.indexOf( eq );
                if ( i !== -1 ) {
                    eqs.splice( i, 1 );
                }
            }
            /**
             * Add all equations
             */
        }, {
            key: "removeAllEquations",
            value: function removeAllEquations( ) {
                this.equations.length = 0;
            }
        } ] );
        return Solver;
    }( );
    /**
     * Constraint equation Gauss-Seidel solver.
     * @todo The spook parameters should be specified for each constraint, not globally.
     * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
     */
    var GSSolver = /*#__PURE__*/ function( _Solver ) {
        _inherits( GSSolver, _Solver );
        var _super77 = _createSuper( GSSolver );
        /**
         * The number of solver iterations determines quality of the constraints in the world.
         * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
         */
        /**
         * When tolerance is reached, the system is assumed to be converged.
         */
        /**
         * @todo remove useless constructor
         */
        function GSSolver( ) {
            var _this62;
            _classCallCheck( this, GSSolver );
            _this62 = _super77.call( this );
            _this62.iterations = 10;
            _this62.tolerance = 1e-7;
            return _this62;
        }
        /**
         * Solve
         * @return number of iterations performed
         */
        _createClass( GSSolver, [ {
            key: "solve",
            value: function solve( dt, world ) {
                var iter = 0;
                var maxIter = this.iterations;
                var tolSquared = this.tolerance * this.tolerance;
                var equations = this.equations;
                var Neq = equations.length;
                var bodies = world.bodies;
                var Nbodies = bodies.length;
                var h = dt;
                var B;
                var invC;
                var deltalambda;
                var deltalambdaTot;
                var GWlambda;
                var lambdaj; // Update solve mass
                if ( Neq !== 0 ) {
                    for ( var _i330 = 0; _i330 !== Nbodies; _i330++ ) {
                        bodies[ _i330 ].updateSolveMassProperties( );
                    }
                } // Things that do not change during iteration can be computed once
                var invCs = GSSolver_solve_invCs;
                var Bs = GSSolver_solve_Bs;
                var lambda = GSSolver_solve_lambda;
                invCs.length = Neq;
                Bs.length = Neq;
                lambda.length = Neq;
                for ( var _i331 = 0; _i331 !== Neq; _i331++ ) {
                    var _c13 = equations[ _i331 ];
                    lambda[ _i331 ] = 0.0;
                    Bs[ _i331 ] = _c13.computeB( h );
                    invCs[ _i331 ] = 1.0 / _c13.computeC( );
                }
                if ( Neq !== 0 ) { // Reset vlambda
                    for ( var _i332 = 0; _i332 !== Nbodies; _i332++ ) {
                        var _b14 = bodies[ _i332 ];
                        var vlambda = _b14.vlambda;
                        var wlambda = _b14.wlambda;
                        vlambda.set( 0, 0, 0 );
                        wlambda.set( 0, 0, 0 );
                    } // Iterate over equations
                    for ( iter = 0; iter !== maxIter; iter++ ) { // Accumulate the total error for each iteration.
                        deltalambdaTot = 0.0;
                        for ( var j = 0; j !== Neq; j++ ) {
                            var _c14 = equations[ j ]; // Compute iteration
                            B = Bs[ j ];
                            invC = invCs[ j ];
                            lambdaj = lambda[ j ];
                            GWlambda = _c14.computeGWlambda( );
                            deltalambda = invC * ( B - GWlambda - _c14.eps * lambdaj ); // Clamp if we are not within the min/max interval
                            if ( lambdaj + deltalambda < _c14.minForce ) {
                                deltalambda = _c14.minForce - lambdaj;
                            } else if ( lambdaj + deltalambda > _c14.maxForce ) {
                                deltalambda = _c14.maxForce - lambdaj;
                            }
                            lambda[ j ] += deltalambda;
                            deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)
                            _c14.addToWlambda( deltalambda );
                        } // If the total error is small enough - stop iterate
                        if ( deltalambdaTot * deltalambdaTot < tolSquared ) {
                            break;
                        }
                    } // Add result to velocity
                    for ( var _i333 = 0; _i333 !== Nbodies; _i333++ ) {
                        var _b15 = bodies[ _i333 ];
                        var v = _b15.velocity;
                        var w = _b15.angularVelocity;
                        _b15.vlambda.vmul( _b15.linearFactor, _b15.vlambda );
                        v.vadd( _b15.vlambda, v );
                        _b15.wlambda.vmul( _b15.angularFactor, _b15.wlambda );
                        w.vadd( _b15.wlambda, w );
                    } // Set the `.multiplier` property of each equation
                    var l = equations.length;
                    var invDt = 1 / h;
                    while ( l-- ) {
                        equations[ l ].multiplier = lambda[ l ] * invDt;
                    }
                }
                return iter;
            }
        } ] );
        return GSSolver;
    }( Solver ); // Just temporary number holders that we want to reuse each iteration.
    var GSSolver_solve_lambda = [ ];
    var GSSolver_solve_invCs = [ ];
    var GSSolver_solve_Bs = [ ];
    Body.STATIC;
    /**
     * For pooling objects that can be reused.
     */
    var Pool = /*#__PURE__*/ function( ) {
        function Pool( ) {
            _classCallCheck( this, Pool );
            this.objects = [ ];
            this.type = Object;
        }
        /**
         * Release an object after use
         */
        _createClass( Pool, [ {
            key: "release",
            value: function release( ) {
                var Nargs = arguments.length;
                for ( var _i334 = 0; _i334 !== Nargs; _i334++ ) {
                    this.objects.push( _i334 < 0 || arguments.length <= _i334 ? undefined : arguments[ _i334 ] );
                }
                return this;
            }
            /**
             * Get an object
             */
        }, {
            key: "get",
            value: function get( ) {
                if ( this.objects.length === 0 ) {
                    return this.constructObject( );
                } else {
                    return this.objects.pop( );
                }
            }
            /**
             * Construct an object. Should be implemented in each subclass.
             */
        }, {
            key: "constructObject",
            value: function constructObject( ) {
                throw new Error( 'constructObject() not implemented in this Pool subclass yet!' );
            }
            /**
             * @return Self, for chaining
             */
        }, {
            key: "resize",
            value: function resize( size ) {
                var objects = this.objects;
                while ( objects.length > size ) {
                    objects.pop( );
                }
                while ( objects.length < size ) {
                    objects.push( this.constructObject( ) );
                }
                return this;
            }
        } ] );
        return Pool;
    }( );
    /**
     * Vec3Pool
     */
    var Vec3Pool = /*#__PURE__*/ function( _Pool ) {
        _inherits( Vec3Pool, _Pool );
        var _super78 = _createSuper( Vec3Pool );

        function Vec3Pool( ) {
            var _this63;
            _classCallCheck( this, Vec3Pool );
            _this63 = _super78.apply( this, arguments );
            _this63.type = Vec3;
            return _this63;
        }
        /**
         * Construct a vector
         */
        _createClass( Vec3Pool, [ {
            key: "constructObject",
            value: function constructObject( ) {
                return new Vec3( );
            }
        } ] );
        return Vec3Pool;
    }( Pool ); // Naming rule: based of the order in SHAPE_TYPES,
    // the first part of the method is formed by the
    // shape type that comes before, in the second part
    // there is the shape type that comes after in the SHAPE_TYPES list
    var COLLISION_TYPES = {
        sphereSphere: Shape.types.SPHERE,
        spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
        boxBox: Shape.types.BOX | Shape.types.BOX,
        sphereBox: Shape.types.SPHERE | Shape.types.BOX,
        planeBox: Shape.types.PLANE | Shape.types.BOX,
        convexConvex: Shape.types.CONVEXPOLYHEDRON,
        sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
        planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
        boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
        sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
        boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
        convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
        sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
        planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
        boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
        convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
        cylinderCylinder: Shape.types.CYLINDER,
        sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
        planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
        boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
        convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
        heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
        particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
        sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
        planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
    };
    /**
     * Helper class for the World. Generates ContactEquations.
     * @todo Sphere-ConvexPolyhedron contacts
     * @todo Contact reduction
     * @todo should move methods to prototype
     */
    var Narrowphase = /*#__PURE__*/ function( _COLLISION_TYPES$sphe, _COLLISION_TYPES$sphe2, _COLLISION_TYPES$boxB, _COLLISION_TYPES$sphe3, _COLLISION_TYPES$plan, _COLLISION_TYPES$conv, _COLLISION_TYPES$sphe4, _COLLISION_TYPES$plan2, _COLLISION_TYPES$boxC, _COLLISION_TYPES$sphe5, _COLLISION_TYPES$boxH, _COLLISION_TYPES$conv2, _COLLISION_TYPES$sphe6, _COLLISION_TYPES$plan3, _COLLISION_TYPES$boxP, _COLLISION_TYPES$conv3, _COLLISION_TYPES$cyli, _COLLISION_TYPES$sphe7, _COLLISION_TYPES$plan4, _COLLISION_TYPES$boxC2, _COLLISION_TYPES$conv4, _COLLISION_TYPES$heig, _COLLISION_TYPES$part, _COLLISION_TYPES$sphe8, _COLLISION_TYPES$plan5 ) { // get [COLLISION_TYPES.convexTrimesh]() {
        //   return this.convexTrimesh
        // }
        function Narrowphase( world ) {
            _classCallCheck( this, Narrowphase );
            this.contactPointPool = [ ];
            this.frictionEquationPool = [ ];
            this.result = [ ];
            this.frictionResult = [ ];
            this.v3pool = new Vec3Pool( );
            this.world = world;
            this.currentContactMaterial = world.defaultContactMaterial;
            this.enableFrictionReduction = false;
        }
        /**
         * Make a contact object, by using the internal pool or creating a new one.
         */
        _createClass( Narrowphase, [ {
            key: _COLLISION_TYPES$sphe,
            get:
                /**
                 * Internal storage of pooled contact points.
                 */
                /**
                 * Pooled vectors.
                 */
                function get( ) {
                    return this.sphereSphere;
                }
        }, {
            key: _COLLISION_TYPES$sphe2,
            get: function get( ) {
                return this.spherePlane;
            }
        }, {
            key: _COLLISION_TYPES$boxB,
            get: function get( ) {
                return this.boxBox;
            }
        }, {
            key: _COLLISION_TYPES$sphe3,
            get: function get( ) {
                return this.sphereBox;
            }
        }, {
            key: _COLLISION_TYPES$plan,
            get: function get( ) {
                return this.planeBox;
            }
        }, {
            key: _COLLISION_TYPES$conv,
            get: function get( ) {
                return this.convexConvex;
            }
        }, {
            key: _COLLISION_TYPES$sphe4,
            get: function get( ) {
                return this.sphereConvex;
            }
        }, {
            key: _COLLISION_TYPES$plan2,
            get: function get( ) {
                return this.planeConvex;
            }
        }, {
            key: _COLLISION_TYPES$boxC,
            get: function get( ) {
                return this.boxConvex;
            }
        }, {
            key: _COLLISION_TYPES$sphe5,
            get: function get( ) {
                return this.sphereHeightfield;
            }
        }, {
            key: _COLLISION_TYPES$boxH,
            get: function get( ) {
                return this.boxHeightfield;
            }
        }, {
            key: _COLLISION_TYPES$conv2,
            get: function get( ) {
                return this.convexHeightfield;
            }
        }, {
            key: _COLLISION_TYPES$sphe6,
            get: function get( ) {
                return this.sphereParticle;
            }
        }, {
            key: _COLLISION_TYPES$plan3,
            get: function get( ) {
                return this.planeParticle;
            }
        }, {
            key: _COLLISION_TYPES$boxP,
            get: function get( ) {
                return this.boxParticle;
            }
        }, {
            key: _COLLISION_TYPES$conv3,
            get: function get( ) {
                return this.convexParticle;
            }
        }, {
            key: _COLLISION_TYPES$cyli,
            get: function get( ) {
                return this.convexConvex;
            }
        }, {
            key: _COLLISION_TYPES$sphe7,
            get: function get( ) {
                return this.sphereConvex;
            }
        }, {
            key: _COLLISION_TYPES$plan4,
            get: function get( ) {
                return this.planeConvex;
            }
        }, {
            key: _COLLISION_TYPES$boxC2,
            get: function get( ) {
                return this.boxConvex;
            }
        }, {
            key: _COLLISION_TYPES$conv4,
            get: function get( ) {
                return this.convexConvex;
            }
        }, {
            key: _COLLISION_TYPES$heig,
            get: function get( ) {
                return this.heightfieldCylinder;
            }
        }, {
            key: _COLLISION_TYPES$part,
            get: function get( ) {
                return this.particleCylinder;
            }
        }, {
            key: _COLLISION_TYPES$sphe8,
            get: function get( ) {
                return this.sphereTrimesh;
            }
        }, {
            key: _COLLISION_TYPES$plan5,
            get: function get( ) {
                return this.planeTrimesh;
            }
        }, {
            key: "createContactEquation",
            value: function createContactEquation( bi, bj, si, sj, overrideShapeA, overrideShapeB ) {
                var c;
                if ( this.contactPointPool.length ) {
                    c = this.contactPointPool.pop( );
                    c.bi = bi;
                    c.bj = bj;
                } else {
                    c = new ContactEquation( bi, bj );
                }
                c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                var cm = this.currentContactMaterial;
                c.restitution = cm.restitution;
                c.setSpookParams( cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt );
                var matA = si.material || bi.material;
                var matB = sj.material || bj.material;
                if ( matA && matB && matA.restitution >= 0 && matB.restitution >= 0 ) {
                    c.restitution = matA.restitution * matB.restitution;
                }
                c.si = overrideShapeA || si;
                c.sj = overrideShapeB || sj;
                return c;
            }
        }, {
            key: "createFrictionEquationsFromContact",
            value: function createFrictionEquationsFromContact( contactEquation, outArray ) {
                var bodyA = contactEquation.bi;
                var bodyB = contactEquation.bj;
                var shapeA = contactEquation.si;
                var shapeB = contactEquation.sj;
                var world = this.world;
                var cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them
                var friction = cm.friction;
                var matA = shapeA.material || bodyA.material;
                var matB = shapeB.material || bodyB.material;
                if ( matA && matB && matA.friction >= 0 && matB.friction >= 0 ) {
                    friction = matA.friction * matB.friction;
                }
                if ( friction > 0 ) { // Create 2 tangent equations
                    var mug = friction * world.gravity.length( );
                    var reducedMass = bodyA.invMass + bodyB.invMass;
                    if ( reducedMass > 0 ) {
                        reducedMass = 1 / reducedMass;
                    }
                    var pool = this.frictionEquationPool;
                    var c1 = pool.length ? pool.pop( ) : new FrictionEquation( bodyA, bodyB, mug * reducedMass );
                    var c2 = pool.length ? pool.pop( ) : new FrictionEquation( bodyA, bodyB, mug * reducedMass );
                    c1.bi = c2.bi = bodyA;
                    c1.bj = c2.bj = bodyB;
                    c1.minForce = c2.minForce = -mug * reducedMass;
                    c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors
                    c1.ri.copy( contactEquation.ri );
                    c1.rj.copy( contactEquation.rj );
                    c2.ri.copy( contactEquation.ri );
                    c2.rj.copy( contactEquation.rj ); // Construct tangents
                    contactEquation.ni.tangents( c1.t, c2.t ); // Set spook params
                    c1.setSpookParams( cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt );
                    c2.setSpookParams( cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt );
                    c1.enabled = c2.enabled = contactEquation.enabled;
                    outArray.push( c1, c2 );
                    return true;
                }
                return false;
            }
            /**
             * Take the average N latest contact point on the plane.
             */
        }, {
            key: "createFrictionFromAverage",
            value: function createFrictionFromAverage( numContacts ) { // The last contactEquation
                var c = this.result[ this.result.length - 1 ]; // Create the result: two "average" friction equations
                if ( !this.createFrictionEquationsFromContact( c, this.frictionResult ) || numContacts === 1 ) {
                    return;
                }
                var f1 = this.frictionResult[ this.frictionResult.length - 2 ];
                var f2 = this.frictionResult[ this.frictionResult.length - 1 ];
                averageNormal.setZero( );
                averageContactPointA.setZero( );
                averageContactPointB.setZero( );
                var bodyA = c.bi;
                c.bj;
                for ( var _i335 = 0; _i335 !== numContacts; _i335++ ) {
                    c = this.result[ this.result.length - 1 - _i335 ];
                    if ( c.bi !== bodyA ) {
                        averageNormal.vadd( c.ni, averageNormal );
                        averageContactPointA.vadd( c.ri, averageContactPointA );
                        averageContactPointB.vadd( c.rj, averageContactPointB );
                    } else {
                        averageNormal.vsub( c.ni, averageNormal );
                        averageContactPointA.vadd( c.rj, averageContactPointA );
                        averageContactPointB.vadd( c.ri, averageContactPointB );
                    }
                }
                var invNumContacts = 1 / numContacts;
                averageContactPointA.scale( invNumContacts, f1.ri );
                averageContactPointB.scale( invNumContacts, f1.rj );
                f2.ri.copy( f1.ri ); // Should be the same
                f2.rj.copy( f1.rj );
                averageNormal.normalize( );
                averageNormal.tangents( f1.t, f2.t ); // return eq;
            }
            /**
             * Generate all contacts between a list of body pairs
             * @param p1 Array of body indices
             * @param p2 Array of body indices
             * @param result Array to store generated contacts
             * @param oldcontacts Optional. Array of reusable contact objects
             */
        }, {
            key: "getContacts",
            value: function getContacts( p1, p2, world, result, oldcontacts, frictionResult, frictionPool ) { // Save old contact objects
                this.contactPointPool = oldcontacts;
                this.frictionEquationPool = frictionPool;
                this.result = result;
                this.frictionResult = frictionResult;
                var qi = tmpQuat1;
                var qj = tmpQuat2;
                var xi = tmpVec1;
                var xj = tmpVec2;
                for ( var k = 0, N = p1.length; k !== N; k++ ) { // Get current collision bodies
                    var bi = p1[ k ];
                    var bj = p2[ k ]; // Get contact material
                    var bodyContactMaterial = null;
                    if ( bi.material && bj.material ) {
                        bodyContactMaterial = world.getContactMaterial( bi.material, bj.material ) || null;
                    }
                    var justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;
                    for ( var _i336 = 0; _i336 < bi.shapes.length; _i336++ ) {
                        bi.quaternion.mult( bi.shapeOrientations[ _i336 ], qi );
                        bi.quaternion.vmult( bi.shapeOffsets[ _i336 ], xi );
                        xi.vadd( bi.position, xi );
                        var si = bi.shapes[ _i336 ];
                        for ( var j = 0; j < bj.shapes.length; j++ ) { // Compute world transform of shapes
                            bj.quaternion.mult( bj.shapeOrientations[ j ], qj );
                            bj.quaternion.vmult( bj.shapeOffsets[ j ], xj );
                            xj.vadd( bj.position, xj );
                            var sj = bj.shapes[ j ];
                            if ( !( si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup ) ) {
                                continue;
                            }
                            if ( xi.distanceTo( xj ) > si.boundingSphereRadius + sj.boundingSphereRadius ) {
                                continue;
                            } // Get collision material
                            var shapeContactMaterial = null;
                            if ( si.material && sj.material ) {
                                shapeContactMaterial = world.getContactMaterial( si.material, sj.material ) || null;
                            }
                            this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts
                            var resolverIndex = si.type | sj.type;
                            var resolver = this[ resolverIndex ];
                            if ( resolver ) {
                                var retval = false; // TO DO: investigate why sphereParticle and convexParticle
                                // resolvers expect si and sj shapes to be in reverse order
                                // (i.e. larger integer value type first instead of smaller first)
                                if ( si.type < sj.type ) {
                                    retval = resolver.call( this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest );
                                } else {
                                    retval = resolver.call( this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest );
                                }
                                if ( retval && justTest ) { // Register overlap
                                    world.shapeOverlapKeeper.set( si.id, sj.id );
                                    world.bodyOverlapKeeper.set( bi.id, bj.id );
                                }
                            }
                        }
                    }
                }
            }
        }, {
            key: "sphereSphere",
            value: function sphereSphere( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                if ( justTest ) {
                    return xi.distanceSquared( xj ) < Math.pow( si.radius + sj.radius, 2 );
                } // We will have only one contact in this case
                var contactEq = this.createContactEquation( bi, bj, si, sj, rsi, rsj ); // Contact normal
                xj.vsub( xi, contactEq.ni );
                contactEq.ni.normalize( ); // Contact point locations
                contactEq.ri.copy( contactEq.ni );
                contactEq.rj.copy( contactEq.ni );
                contactEq.ri.scale( si.radius, contactEq.ri );
                contactEq.rj.scale( -sj.radius, contactEq.rj );
                contactEq.ri.vadd( xi, contactEq.ri );
                contactEq.ri.vsub( bi.position, contactEq.ri );
                contactEq.rj.vadd( xj, contactEq.rj );
                contactEq.rj.vsub( bj.position, contactEq.rj );
                this.result.push( contactEq );
                this.createFrictionEquationsFromContact( contactEq, this.frictionResult );
            }
        }, {
            key: "spherePlane",
            value: function spherePlane( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) { // We will have one contact in this case
                var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj ); // Contact normal
                r.ni.set( 0, 0, 1 );
                qj.vmult( r.ni, r.ni );
                r.ni.negate( r.ni ); // body i is the sphere, flip normal
                r.ni.normalize( ); // Needed?
                // Vector from sphere center to contact point
                r.ni.scale( si.radius, r.ri ); // Project down sphere on plane
                xi.vsub( xj, point_on_plane_to_sphere );
                r.ni.scale( r.ni.dot( point_on_plane_to_sphere ), plane_to_sphere_ortho );
                point_on_plane_to_sphere.vsub( plane_to_sphere_ortho, r.rj ); // The sphere position projected to plane
                if ( -point_on_plane_to_sphere.dot( r.ni ) <= si.radius ) {
                    if ( justTest ) {
                        return true;
                    } // Make it relative to the body
                    var ri = r.ri;
                    var rj = r.rj;
                    ri.vadd( xi, ri );
                    ri.vsub( bi.position, ri );
                    rj.vadd( xj, rj );
                    rj.vsub( bj.position, rj );
                    this.result.push( r );
                    this.createFrictionEquationsFromContact( r, this.frictionResult );
                }
            }
        }, {
            key: "boxBox",
            value: function boxBox( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                si.convexPolyhedronRepresentation.material = si.material;
                sj.convexPolyhedronRepresentation.material = sj.material;
                si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
                return this.convexConvex( si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest );
            }
        }, {
            key: "sphereBox",
            value: function sphereBox( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                var v3pool = this.v3pool; // we refer to the box as body j
                var sides = sphereBox_sides;
                xi.vsub( xj, box_to_sphere );
                sj.getSideNormals( sides, qj );
                var R = si.radius;
                var found = false; // Store the resulting side penetration info
                var side_ns = sphereBox_side_ns;
                var side_ns1 = sphereBox_side_ns1;
                var side_ns2 = sphereBox_side_ns2;
                var side_h = null;
                var side_penetrations = 0;
                var side_dot1 = 0;
                var side_dot2 = 0;
                var side_distance = null;
                for ( var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++ ) { // Get the plane side normal (ns)
                    var ns = sphereBox_ns;
                    ns.copy( sides[ idx ] );
                    var h = ns.length( );
                    ns.normalize( ); // The normal/distance dot product tells which side of the plane we are
                    var dot = box_to_sphere.dot( ns );
                    if ( dot < h + R && dot > 0 ) { // Intersects plane. Now check the other two dimensions
                        var ns1 = sphereBox_ns1;
                        var ns2 = sphereBox_ns2;
                        ns1.copy( sides[ ( idx + 1 ) % 3 ] );
                        ns2.copy( sides[ ( idx + 2 ) % 3 ] );
                        var h1 = ns1.length( );
                        var h2 = ns2.length( );
                        ns1.normalize( );
                        ns2.normalize( );
                        var dot1 = box_to_sphere.dot( ns1 );
                        var dot2 = box_to_sphere.dot( ns2 );
                        if ( dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2 ) {
                            var _dist = Math.abs( dot - h - R );
                            if ( side_distance === null || _dist < side_distance ) {
                                side_distance = _dist;
                                side_dot1 = dot1;
                                side_dot2 = dot2;
                                side_h = h;
                                side_ns.copy( ns );
                                side_ns1.copy( ns1 );
                                side_ns2.copy( ns2 );
                                side_penetrations++;
                                if ( justTest ) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                if ( side_penetrations ) {
                    found = true;
                    var _r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                    side_ns.scale( -R, _r.ri ); // Sphere r
                    _r.ni.copy( side_ns );
                    _r.ni.negate( _r.ni ); // Normal should be out of sphere
                    side_ns.scale( side_h, side_ns );
                    side_ns1.scale( side_dot1, side_ns1 );
                    side_ns.vadd( side_ns1, side_ns );
                    side_ns2.scale( side_dot2, side_ns2 );
                    side_ns.vadd( side_ns2, _r.rj ); // Make relative to bodies
                    _r.ri.vadd( xi, _r.ri );
                    _r.ri.vsub( bi.position, _r.ri );
                    _r.rj.vadd( xj, _r.rj );
                    _r.rj.vsub( bj.position, _r.rj );
                    this.result.push( _r );
                    this.createFrictionEquationsFromContact( _r, this.frictionResult );
                } // Check corners
                var rj = v3pool.get( );
                var sphere_to_corner = sphereBox_sphere_to_corner;
                for ( var j = 0; j !== 2 && !found; j++ ) {
                    for ( var k = 0; k !== 2 && !found; k++ ) {
                        for ( var l = 0; l !== 2 && !found; l++ ) {
                            rj.set( 0, 0, 0 );
                            if ( j ) {
                                rj.vadd( sides[ 0 ], rj );
                            } else {
                                rj.vsub( sides[ 0 ], rj );
                            }
                            if ( k ) {
                                rj.vadd( sides[ 1 ], rj );
                            } else {
                                rj.vsub( sides[ 1 ], rj );
                            }
                            if ( l ) {
                                rj.vadd( sides[ 2 ], rj );
                            } else {
                                rj.vsub( sides[ 2 ], rj );
                            } // World position of corner
                            xj.vadd( rj, sphere_to_corner );
                            sphere_to_corner.vsub( xi, sphere_to_corner );
                            if ( sphere_to_corner.lengthSquared( ) < R * R ) {
                                if ( justTest ) {
                                    return true;
                                }
                                found = true;
                                var _r2 = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                                _r2.ri.copy( sphere_to_corner );
                                _r2.ri.normalize( );
                                _r2.ni.copy( _r2.ri );
                                _r2.ri.scale( R, _r2.ri );
                                _r2.rj.copy( rj ); // Make relative to bodies
                                _r2.ri.vadd( xi, _r2.ri );
                                _r2.ri.vsub( bi.position, _r2.ri );
                                _r2.rj.vadd( xj, _r2.rj );
                                _r2.rj.vsub( bj.position, _r2.rj );
                                this.result.push( _r2 );
                                this.createFrictionEquationsFromContact( _r2, this.frictionResult );
                            }
                        }
                    }
                }
                v3pool.release( rj );
                rj = null; // Check edges
                var edgeTangent = v3pool.get( );
                var edgeCenter = v3pool.get( );
                var r = v3pool.get( ); // r = edge center to sphere center
                var orthogonal = v3pool.get( );
                var dist = v3pool.get( );
                var Nsides = sides.length;
                for ( var _j10 = 0; _j10 !== Nsides && !found; _j10++ ) {
                    for ( var _k = 0; _k !== Nsides && !found; _k++ ) {
                        if ( _j10 % 3 !== _k % 3 ) { // Get edge tangent
                            sides[ _k ].cross( sides[ _j10 ], edgeTangent );
                            edgeTangent.normalize( );
                            sides[ _j10 ].vadd( sides[ _k ], edgeCenter );
                            r.copy( xi );
                            r.vsub( edgeCenter, r );
                            r.vsub( xj, r );
                            var orthonorm = r.dot( edgeTangent ); // distance from edge center to sphere center in the tangent direction
                            edgeTangent.scale( orthonorm, orthogonal ); // Vector from edge center to sphere center in the tangent direction
                            // Find the third side orthogonal to this one
                            var _l8 = 0;
                            while ( _l8 === _j10 % 3 || _l8 === _k % 3 ) {
                                _l8++;
                            } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                            dist.copy( xi );
                            dist.vsub( orthogonal, dist );
                            dist.vsub( edgeCenter, dist );
                            dist.vsub( xj, dist ); // Distances in tangent direction and distance in the plane orthogonal to it
                            var tdist = Math.abs( orthonorm );
                            var ndist = dist.length( );
                            if ( tdist < sides[ _l8 ].length( ) && ndist < R ) {
                                if ( justTest ) {
                                    return true;
                                }
                                found = true;
                                var res = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                                edgeCenter.vadd( orthogonal, res.rj ); // box rj
                                res.rj.copy( res.rj );
                                dist.negate( res.ni );
                                res.ni.normalize( );
                                res.ri.copy( res.rj );
                                res.ri.vadd( xj, res.ri );
                                res.ri.vsub( xi, res.ri );
                                res.ri.normalize( );
                                res.ri.scale( R, res.ri ); // Make relative to bodies
                                res.ri.vadd( xi, res.ri );
                                res.ri.vsub( bi.position, res.ri );
                                res.rj.vadd( xj, res.rj );
                                res.rj.vsub( bj.position, res.rj );
                                this.result.push( res );
                                this.createFrictionEquationsFromContact( res, this.frictionResult );
                            }
                        }
                    }
                }
                v3pool.release( edgeTangent, edgeCenter, r, orthogonal, dist );
            }
        }, {
            key: "planeBox",
            value: function planeBox( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                sj.convexPolyhedronRepresentation.material = sj.material;
                sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
                sj.convexPolyhedronRepresentation.id = sj.id;
                return this.planeConvex( si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest );
            }
        }, {
            key: "convexConvex",
            value: function convexConvex( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB ) {
                var sepAxis = convexConvex_sepAxis;
                if ( xi.distanceTo( xj ) > si.boundingSphereRadius + sj.boundingSphereRadius ) {
                    return;
                }
                if ( si.findSeparatingAxis( sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB ) ) {
                    var res = [ ];
                    var q = convexConvex_q;
                    si.clipAgainstHull( xi, qi, sj, xj, qj, sepAxis, -100, 100, res );
                    var numContacts = 0;
                    for ( var j = 0; j !== res.length; j++ ) {
                        if ( justTest ) {
                            return true;
                        }
                        var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                        var ri = r.ri;
                        var rj = r.rj;
                        sepAxis.negate( r.ni );
                        res[ j ].normal.negate( q );
                        q.scale( res[ j ].depth, q );
                        res[ j ].point.vadd( q, ri );
                        rj.copy( res[ j ].point ); // Contact points are in world coordinates. Transform back to relative
                        ri.vsub( xi, ri );
                        rj.vsub( xj, rj ); // Make relative to bodies
                        ri.vadd( xi, ri );
                        ri.vsub( bi.position, ri );
                        rj.vadd( xj, rj );
                        rj.vsub( bj.position, rj );
                        this.result.push( r );
                        numContacts++;
                        if ( !this.enableFrictionReduction ) {
                            this.createFrictionEquationsFromContact( r, this.frictionResult );
                        }
                    }
                    if ( this.enableFrictionReduction && numContacts ) {
                        this.createFrictionFromAverage( numContacts );
                    }
                }
            }
        }, {
            key: "sphereConvex",
            value: function sphereConvex( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                var v3pool = this.v3pool;
                xi.vsub( xj, convex_to_sphere );
                var normals = sj.faceNormals;
                var faces = sj.faces;
                var verts = sj.vertices;
                var R = si.radius; //     return;
                // }
                var found = false; // Check corners
                for ( var _i337 = 0; _i337 !== verts.length; _i337++ ) {
                    var v = verts[ _i337 ]; // World position of corner
                    var worldCorner = sphereConvex_worldCorner;
                    qj.vmult( v, worldCorner );
                    xj.vadd( worldCorner, worldCorner );
                    var sphere_to_corner = sphereConvex_sphereToCorner;
                    worldCorner.vsub( xi, sphere_to_corner );
                    if ( sphere_to_corner.lengthSquared( ) < R * R ) {
                        if ( justTest ) {
                            return true;
                        }
                        found = true;
                        var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                        r.ri.copy( sphere_to_corner );
                        r.ri.normalize( );
                        r.ni.copy( r.ri );
                        r.ri.scale( R, r.ri );
                        worldCorner.vsub( xj, r.rj ); // Should be relative to the body.
                        r.ri.vadd( xi, r.ri );
                        r.ri.vsub( bi.position, r.ri ); // Should be relative to the body.
                        r.rj.vadd( xj, r.rj );
                        r.rj.vsub( bj.position, r.rj );
                        this.result.push( r );
                        this.createFrictionEquationsFromContact( r, this.frictionResult );
                        return;
                    }
                } // Check side (plane) intersections
                for ( var _i338 = 0, nfaces = faces.length; _i338 !== nfaces && found === false; _i338++ ) {
                    var normal = normals[ _i338 ];
                    var face = faces[ _i338 ]; // Get world-transformed normal of the face
                    var worldNormal = sphereConvex_worldNormal;
                    qj.vmult( normal, worldNormal ); // Get a world vertex from the face
                    var worldPoint = sphereConvex_worldPoint;
                    qj.vmult( verts[ face[ 0 ] ], worldPoint );
                    worldPoint.vadd( xj, worldPoint ); // Get a point on the sphere, closest to the face normal
                    var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
                    worldNormal.scale( -R, worldSpherePointClosestToPlane );
                    xi.vadd( worldSpherePointClosestToPlane, worldSpherePointClosestToPlane ); // Vector from a face point to the closest point on the sphere
                    var penetrationVec = sphereConvex_penetrationVec;
                    worldSpherePointClosestToPlane.vsub( worldPoint, penetrationVec ); // The penetration. Negative value means overlap.
                    var penetration = penetrationVec.dot( worldNormal );
                    var worldPointToSphere = sphereConvex_sphereToWorldPoint;
                    xi.vsub( worldPoint, worldPointToSphere );
                    if ( penetration < 0 && worldPointToSphere.dot( worldNormal ) > 0 ) { // Intersects plane. Now check if the sphere is inside the face polygon
                        var faceVerts = [ ]; // Face vertices, in world coords
                        for ( var j = 0, Nverts = face.length; j !== Nverts; j++ ) {
                            var worldVertex = v3pool.get( );
                            qj.vmult( verts[ face[ j ] ], worldVertex );
                            xj.vadd( worldVertex, worldVertex );
                            faceVerts.push( worldVertex );
                        }
                        if ( pointInPolygon( faceVerts, worldNormal, xi ) ) { // Is the sphere center in the face polygon?
                            if ( justTest ) {
                                return true;
                            }
                            found = true;
                            var _r3 = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                            worldNormal.scale( -R, _r3.ri ); // Contact offset, from sphere center to contact
                            worldNormal.negate( _r3.ni ); // Normal pointing out of sphere
                            var penetrationVec2 = v3pool.get( );
                            worldNormal.scale( -penetration, penetrationVec2 );
                            var penetrationSpherePoint = v3pool.get( );
                            worldNormal.scale( -R, penetrationSpherePoint ); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                            xi.vsub( xj, _r3.rj );
                            _r3.rj.vadd( penetrationSpherePoint, _r3.rj );
                            _r3.rj.vadd( penetrationVec2, _r3.rj ); // Should be relative to the body.
                            _r3.rj.vadd( xj, _r3.rj );
                            _r3.rj.vsub( bj.position, _r3.rj ); // Should be relative to the body.
                            _r3.ri.vadd( xi, _r3.ri );
                            _r3.ri.vsub( bi.position, _r3.ri );
                            v3pool.release( penetrationVec2 );
                            v3pool.release( penetrationSpherePoint );
                            this.result.push( _r3 );
                            this.createFrictionEquationsFromContact( _r3, this.frictionResult ); // Release world vertices
                            for ( var _j11 = 0, Nfaceverts = faceVerts.length; _j11 !== Nfaceverts; _j11++ ) {
                                v3pool.release( faceVerts[ _j11 ] );
                            }
                            return; // We only expect *one* face contact
                        } else { // Edge?
                            for ( var _j12 = 0; _j12 !== face.length; _j12++ ) { // Get two world transformed vertices
                                var _v5 = v3pool.get( );
                                var _v6 = v3pool.get( );
                                qj.vmult( verts[ face[ ( _j12 + 1 ) % face.length ] ], _v5 );
                                qj.vmult( verts[ face[ ( _j12 + 2 ) % face.length ] ], _v6 );
                                xj.vadd( _v5, _v5 );
                                xj.vadd( _v6, _v6 ); // Construct edge vector
                                var edge = sphereConvex_edge;
                                _v6.vsub( _v5, edge ); // Construct the same vector, but normalized
                                var edgeUnit = sphereConvex_edgeUnit;
                                edge.unit( edgeUnit ); // p is xi projected onto the edge
                                var p = v3pool.get( );
                                var v1_to_xi = v3pool.get( );
                                xi.vsub( _v5, v1_to_xi );
                                var dot = v1_to_xi.dot( edgeUnit );
                                edgeUnit.scale( dot, p );
                                p.vadd( _v5, p ); // Compute a vector from p to the center of the sphere
                                var xi_to_p = v3pool.get( );
                                p.vsub( xi, xi_to_p ); // Collision if the edge-sphere distance is less than the radius
                                // AND if p is in between v1 and v2
                                if ( dot > 0 && dot * dot < edge.lengthSquared( ) && xi_to_p.lengthSquared( ) < R * R ) { // Collision if the edge-sphere distance is less than the radius
                                    // Edge contact!
                                    if ( justTest ) {
                                        return true;
                                    }
                                    var _r4 = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                                    p.vsub( xj, _r4.rj );
                                    p.vsub( xi, _r4.ni );
                                    _r4.ni.normalize( );
                                    _r4.ni.scale( R, _r4.ri ); // Should be relative to the body.
                                    _r4.rj.vadd( xj, _r4.rj );
                                    _r4.rj.vsub( bj.position, _r4.rj ); // Should be relative to the body.
                                    _r4.ri.vadd( xi, _r4.ri );
                                    _r4.ri.vsub( bi.position, _r4.ri );
                                    this.result.push( _r4 );
                                    this.createFrictionEquationsFromContact( _r4, this.frictionResult ); // Release world vertices
                                    for ( var _j13 = 0, _Nfaceverts = faceVerts.length; _j13 !== _Nfaceverts; _j13++ ) {
                                        v3pool.release( faceVerts[ _j13 ] );
                                    }
                                    v3pool.release( _v5 );
                                    v3pool.release( _v6 );
                                    v3pool.release( p );
                                    v3pool.release( xi_to_p );
                                    v3pool.release( v1_to_xi );
                                    return;
                                }
                                v3pool.release( _v5 );
                                v3pool.release( _v6 );
                                v3pool.release( p );
                                v3pool.release( xi_to_p );
                                v3pool.release( v1_to_xi );
                            }
                        } // Release world vertices
                        for ( var _j14 = 0, _Nfaceverts2 = faceVerts.length; _j14 !== _Nfaceverts2; _j14++ ) {
                            v3pool.release( faceVerts[ _j14 ] );
                        }
                    }
                }
            }
        }, {
            key: "planeConvex",
            value: function planeConvex( planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest ) { // Simply return the points behind the plane.
                var worldVertex = planeConvex_v;
                var worldNormal = planeConvex_normal;
                worldNormal.set( 0, 0, 1 );
                planeQuat.vmult( worldNormal, worldNormal ); // Turn normal according to plane orientation
                var numContacts = 0;
                var relpos = planeConvex_relpos;
                for ( var _i339 = 0; _i339 !== convexShape.vertices.length; _i339++ ) { // Get world convex vertex
                    worldVertex.copy( convexShape.vertices[ _i339 ] );
                    convexQuat.vmult( worldVertex, worldVertex );
                    convexPosition.vadd( worldVertex, worldVertex );
                    worldVertex.vsub( planePosition, relpos );
                    var dot = worldNormal.dot( relpos );
                    if ( dot <= 0.0 ) {
                        if ( justTest ) {
                            return true;
                        }
                        var r = this.createContactEquation( planeBody, convexBody, planeShape, convexShape, si, sj ); // Get vertex position projected on plane
                        var projected = planeConvex_projected;
                        worldNormal.scale( worldNormal.dot( relpos ), projected );
                        worldVertex.vsub( projected, projected );
                        projected.vsub( planePosition, r.ri ); // From plane to vertex projected on plane
                        r.ni.copy( worldNormal ); // Contact normal is the plane normal out from plane
                        // rj is now just the vector from the convex center to the vertex
                        worldVertex.vsub( convexPosition, r.rj ); // Make it relative to the body
                        r.ri.vadd( planePosition, r.ri );
                        r.ri.vsub( planeBody.position, r.ri );
                        r.rj.vadd( convexPosition, r.rj );
                        r.rj.vsub( convexBody.position, r.rj );
                        this.result.push( r );
                        numContacts++;
                        if ( !this.enableFrictionReduction ) {
                            this.createFrictionEquationsFromContact( r, this.frictionResult );
                        }
                    }
                }
                if ( this.enableFrictionReduction && numContacts ) {
                    this.createFrictionFromAverage( numContacts );
                }
            }
        }, {
            key: "boxConvex",
            value: function boxConvex( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                return this.convexConvex( si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest );
            }
        }, {
            key: "sphereHeightfield",
            value: function sphereHeightfield( sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest ) {
                var data = hfShape.data;
                var radius = sphereShape.radius;
                var w = hfShape.elementSize;
                var worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!
                var localSpherePos = sphereHeightfield_tmp1;
                Transform.pointToLocalFrame( hfPos, hfQuat, spherePos, localSpherePos ); // Get the index of the data points to test against
                var iMinX = Math.floor( ( localSpherePos.x - radius ) / w ) - 1;
                var iMaxX = Math.ceil( ( localSpherePos.x + radius ) / w ) + 1;
                var iMinY = Math.floor( ( localSpherePos.y - radius ) / w ) - 1;
                var iMaxY = Math.ceil( ( localSpherePos.y + radius ) / w ) + 1; // Bail out if we are out of the terrain
                if ( iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[ 0 ].length ) {
                    return;
                } // Clamp index to edges
                if ( iMinX < 0 ) {
                    iMinX = 0;
                }
                if ( iMaxX < 0 ) {
                    iMaxX = 0;
                }
                if ( iMinY < 0 ) {
                    iMinY = 0;
                }
                if ( iMaxY < 0 ) {
                    iMaxY = 0;
                }
                if ( iMinX >= data.length ) {
                    iMinX = data.length - 1;
                }
                if ( iMaxX >= data.length ) {
                    iMaxX = data.length - 1;
                }
                if ( iMaxY >= data[ 0 ].length ) {
                    iMaxY = data[ 0 ].length - 1;
                }
                if ( iMinY >= data[ 0 ].length ) {
                    iMinY = data[ 0 ].length - 1;
                }
                var minMax = [ ];
                hfShape.getRectMinMax( iMinX, iMinY, iMaxX, iMaxY, minMax );
                var min = minMax[ 0 ];
                var max = minMax[ 1 ]; // Bail out if we can't touch the bounding height box
                if ( localSpherePos.z - radius > max || localSpherePos.z + radius < min ) {
                    return;
                }
                var result = this.result;
                for ( var _i340 = iMinX; _i340 < iMaxX; _i340++ ) {
                    for ( var j = iMinY; j < iMaxY; j++ ) {
                        var numContactsBefore = result.length;
                        var intersecting = false; // Lower triangle
                        hfShape.getConvexTrianglePillar( _i340, j, false );
                        Transform.pointToWorldFrame( hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset );
                        if ( spherePos.distanceTo( worldPillarOffset ) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius ) {
                            intersecting = this.sphereConvex( sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest );
                        }
                        if ( justTest && intersecting ) {
                            return true;
                        } // Upper triangle
                        hfShape.getConvexTrianglePillar( _i340, j, true );
                        Transform.pointToWorldFrame( hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset );
                        if ( spherePos.distanceTo( worldPillarOffset ) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius ) {
                            intersecting = this.sphereConvex( sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest );
                        }
                        if ( justTest && intersecting ) {
                            return true;
                        }
                        var numContacts = result.length - numContactsBefore;
                        if ( numContacts > 2 ) {
                            return;
                        }
                        /*
                        	          // Skip all but 1
                        	          for (let k = 0; k < numContacts - 1; k++) {
                        	              result.pop();
                        	          }
                        	        */
                    }
                }
            }
        }, {
            key: "boxHeightfield",
            value: function boxHeightfield( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                return this.convexHeightfield( si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest );
            }
        }, {
            key: "convexHeightfield",
            value: function convexHeightfield( convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest ) {
                var data = hfShape.data;
                var w = hfShape.elementSize;
                var radius = convexShape.boundingSphereRadius;
                var worldPillarOffset = convexHeightfield_tmp2;
                var faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!
                var localConvexPos = convexHeightfield_tmp1;
                Transform.pointToLocalFrame( hfPos, hfQuat, convexPos, localConvexPos ); // Get the index of the data points to test against
                var iMinX = Math.floor( ( localConvexPos.x - radius ) / w ) - 1;
                var iMaxX = Math.ceil( ( localConvexPos.x + radius ) / w ) + 1;
                var iMinY = Math.floor( ( localConvexPos.y - radius ) / w ) - 1;
                var iMaxY = Math.ceil( ( localConvexPos.y + radius ) / w ) + 1; // Bail out if we are out of the terrain
                if ( iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[ 0 ].length ) {
                    return;
                } // Clamp index to edges
                if ( iMinX < 0 ) {
                    iMinX = 0;
                }
                if ( iMaxX < 0 ) {
                    iMaxX = 0;
                }
                if ( iMinY < 0 ) {
                    iMinY = 0;
                }
                if ( iMaxY < 0 ) {
                    iMaxY = 0;
                }
                if ( iMinX >= data.length ) {
                    iMinX = data.length - 1;
                }
                if ( iMaxX >= data.length ) {
                    iMaxX = data.length - 1;
                }
                if ( iMaxY >= data[ 0 ].length ) {
                    iMaxY = data[ 0 ].length - 1;
                }
                if ( iMinY >= data[ 0 ].length ) {
                    iMinY = data[ 0 ].length - 1;
                }
                var minMax = [ ];
                hfShape.getRectMinMax( iMinX, iMinY, iMaxX, iMaxY, minMax );
                var min = minMax[ 0 ];
                var max = minMax[ 1 ]; // Bail out if we're cant touch the bounding height box
                if ( localConvexPos.z - radius > max || localConvexPos.z + radius < min ) {
                    return;
                }
                for ( var _i341 = iMinX; _i341 < iMaxX; _i341++ ) {
                    for ( var j = iMinY; j < iMaxY; j++ ) {
                        var intersecting = false; // Lower triangle
                        hfShape.getConvexTrianglePillar( _i341, j, false );
                        Transform.pointToWorldFrame( hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset );
                        if ( convexPos.distanceTo( worldPillarOffset ) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius ) {
                            intersecting = this.convexConvex( convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null );
                        }
                        if ( justTest && intersecting ) {
                            return true;
                        } // Upper triangle
                        hfShape.getConvexTrianglePillar( _i341, j, true );
                        Transform.pointToWorldFrame( hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset );
                        if ( convexPos.distanceTo( worldPillarOffset ) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius ) {
                            intersecting = this.convexConvex( convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null );
                        }
                        if ( justTest && intersecting ) {
                            return true;
                        }
                    }
                }
            }
        }, {
            key: "sphereParticle",
            value: function sphereParticle( sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest ) { // The normal is the unit vector from sphere center to particle center
                var normal = particleSphere_normal;
                normal.set( 0, 0, 1 );
                xi.vsub( xj, normal );
                var lengthSquared = normal.lengthSquared( );
                if ( lengthSquared <= sj.radius * sj.radius ) {
                    if ( justTest ) {
                        return true;
                    }
                    var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                    normal.normalize( );
                    r.rj.copy( normal );
                    r.rj.scale( sj.radius, r.rj );
                    r.ni.copy( normal ); // Contact normal
                    r.ni.negate( r.ni );
                    r.ri.set( 0, 0, 0 ); // Center of particle
                    this.result.push( r );
                    this.createFrictionEquationsFromContact( r, this.frictionResult );
                }
            }
        }, {
            key: "planeParticle",
            value: function planeParticle( sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest ) {
                var normal = particlePlane_normal;
                normal.set( 0, 0, 1 );
                bj.quaternion.vmult( normal, normal ); // Turn normal according to plane orientation
                var relpos = particlePlane_relpos;
                xi.vsub( bj.position, relpos );
                var dot = normal.dot( relpos );
                if ( dot <= 0.0 ) {
                    if ( justTest ) {
                        return true;
                    }
                    var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                    r.ni.copy( normal ); // Contact normal is the plane normal
                    r.ni.negate( r.ni );
                    r.ri.set( 0, 0, 0 ); // Center of particle
                    // Get particle position projected on plane
                    var projected = particlePlane_projected;
                    normal.scale( normal.dot( xi ), projected );
                    xi.vsub( projected, projected ); //projected.vadd(bj.position,projected);
                    // rj is now the projected world position minus plane position
                    r.rj.copy( projected );
                    this.result.push( r );
                    this.createFrictionEquationsFromContact( r, this.frictionResult );
                }
            }
        }, {
            key: "boxParticle",
            value: function boxParticle( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                return this.convexParticle( si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest );
            }
        }, {
            key: "convexParticle",
            value: function convexParticle( sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest ) {
                var penetratedFaceIndex = -1;
                var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
                var worldPenetrationVec = convexParticle_worldPenetrationVec;
                var minPenetration = null;
                var local = convexParticle_local;
                local.copy( xi );
                local.vsub( xj, local ); // Convert position to relative the convex origin
                qj.conjugate( cqj );
                cqj.vmult( local, local );
                if ( sj.pointIsInside( local ) ) {
                    if ( sj.worldVerticesNeedsUpdate ) {
                        sj.computeWorldVertices( xj, qj );
                    }
                    if ( sj.worldFaceNormalsNeedsUpdate ) {
                        sj.computeWorldFaceNormals( qj );
                    } // For each world polygon in the polyhedra
                    for ( var _i342 = 0, nfaces = sj.faces.length; _i342 !== nfaces; _i342++ ) { // Construct world face vertices
                        var verts = [ sj.worldVertices[ sj.faces[ _i342 ][ 0 ] ] ];
                        var normal = sj.worldFaceNormals[ _i342 ]; // Check how much the particle penetrates the polygon plane.
                        xi.vsub( verts[ 0 ], convexParticle_vertexToParticle );
                        var penetration = -normal.dot( convexParticle_vertexToParticle );
                        if ( minPenetration === null || Math.abs( penetration ) < Math.abs( minPenetration ) ) {
                            if ( justTest ) {
                                return true;
                            }
                            minPenetration = penetration;
                            penetratedFaceIndex = _i342;
                            penetratedFaceNormal.copy( normal );
                        }
                    }
                    if ( penetratedFaceIndex !== -1 ) { // Setup contact
                        var r = this.createContactEquation( bi, bj, si, sj, rsi, rsj );
                        penetratedFaceNormal.scale( minPenetration, worldPenetrationVec ); // rj is the particle position projected to the face
                        worldPenetrationVec.vadd( xi, worldPenetrationVec );
                        worldPenetrationVec.vsub( xj, worldPenetrationVec );
                        r.rj.copy( worldPenetrationVec ); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
                        //projectedToFace.copy(r.rj);
                        //qj.vmult(r.rj,r.rj);
                        penetratedFaceNormal.negate( r.ni ); // Contact normal
                        r.ri.set( 0, 0, 0 ); // Center of particle
                        var ri = r.ri;
                        var rj = r.rj; // Make relative to bodies
                        ri.vadd( xi, ri );
                        ri.vsub( bi.position, ri );
                        rj.vadd( xj, rj );
                        rj.vsub( bj.position, rj );
                        this.result.push( r );
                        this.createFrictionEquationsFromContact( r, this.frictionResult );
                    } else {
                        console.warn( 'Point found inside convex, but did not find penetrating face!' );
                    }
                }
            }
        }, {
            key: "heightfieldCylinder",
            value: function heightfieldCylinder( hfShape, convexShape, hfPos, convexPos, hfQuat, convexQuat, hfBody, convexBody, rsi, rsj, justTest ) {
                return this.convexHeightfield( convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest );
            }
        }, {
            key: "particleCylinder",
            value: function particleCylinder( si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest ) {
                return this.convexParticle( sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest );
            }
        }, {
            key: "sphereTrimesh",
            value: function sphereTrimesh( sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest ) {
                var edgeVertexA = sphereTrimesh_edgeVertexA;
                var edgeVertexB = sphereTrimesh_edgeVertexB;
                var edgeVector = sphereTrimesh_edgeVector;
                var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
                var localSpherePos = sphereTrimesh_localSpherePos;
                var tmp = sphereTrimesh_tmp;
                var localSphereAABB = sphereTrimesh_localSphereAABB;
                var v2 = sphereTrimesh_v2;
                var relpos = sphereTrimesh_relpos;
                var triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh
                Transform.pointToLocalFrame( trimeshPos, trimeshQuat, spherePos, localSpherePos ); // Get the aabb of the sphere locally in the trimesh
                var sphereRadius = sphereShape.radius;
                localSphereAABB.lowerBound.set( localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius );
                localSphereAABB.upperBound.set( localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius );
                trimeshShape.getTrianglesInAABB( localSphereAABB, triangles ); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
                // Vertices
                var v = sphereTrimesh_v;
                var radiusSquared = sphereShape.radius * sphereShape.radius;
                for ( var _i343 = 0; _i343 < triangles.length; _i343++ ) {
                    for ( var j = 0; j < 3; j++ ) {
                        trimeshShape.getVertex( trimeshShape.indices[ triangles[ _i343 ] * 3 + j ], v ); // Check vertex overlap in sphere
                        v.vsub( localSpherePos, relpos );
                        if ( relpos.lengthSquared( ) <= radiusSquared ) { // Safe up
                            v2.copy( v );
                            Transform.pointToWorldFrame( trimeshPos, trimeshQuat, v2, v );
                            v.vsub( spherePos, relpos );
                            if ( justTest ) {
                                return true;
                            }
                            var r = this.createContactEquation( sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj );
                            r.ni.copy( relpos );
                            r.ni.normalize( ); // ri is the vector from sphere center to the sphere surface
                            r.ri.copy( r.ni );
                            r.ri.scale( sphereShape.radius, r.ri );
                            r.ri.vadd( spherePos, r.ri );
                            r.ri.vsub( sphereBody.position, r.ri );
                            r.rj.copy( v );
                            r.rj.vsub( trimeshBody.position, r.rj ); // Store result
                            this.result.push( r );
                            this.createFrictionEquationsFromContact( r, this.frictionResult );
                        }
                    }
                } // Check all edges
                for ( var _i344 = 0; _i344 < triangles.length; _i344++ ) {
                    for ( var _j15 = 0; _j15 < 3; _j15++ ) {
                        trimeshShape.getVertex( trimeshShape.indices[ triangles[ _i344 ] * 3 + _j15 ], edgeVertexA );
                        trimeshShape.getVertex( trimeshShape.indices[ triangles[ _i344 ] * 3 + ( _j15 + 1 ) % 3 ], edgeVertexB );
                        edgeVertexB.vsub( edgeVertexA, edgeVector ); // Project sphere position to the edge
                        localSpherePos.vsub( edgeVertexB, tmp );
                        var positionAlongEdgeB = tmp.dot( edgeVector );
                        localSpherePos.vsub( edgeVertexA, tmp );
                        var positionAlongEdgeA = tmp.dot( edgeVector );
                        if ( positionAlongEdgeA > 0 && positionAlongEdgeB < 0 ) { // Now check the orthogonal distance from edge to sphere center
                            localSpherePos.vsub( edgeVertexA, tmp );
                            edgeVectorUnit.copy( edgeVector );
                            edgeVectorUnit.normalize( );
                            positionAlongEdgeA = tmp.dot( edgeVectorUnit );
                            edgeVectorUnit.scale( positionAlongEdgeA, tmp );
                            tmp.vadd( edgeVertexA, tmp ); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                            var dist = tmp.distanceTo( localSpherePos );
                            if ( dist < sphereShape.radius ) {
                                if ( justTest ) {
                                    return true;
                                }
                                var _r5 = this.createContactEquation( sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj );
                                tmp.vsub( localSpherePos, _r5.ni );
                                _r5.ni.normalize( );
                                _r5.ni.scale( sphereShape.radius, _r5.ri );
                                _r5.ri.vadd( spherePos, _r5.ri );
                                _r5.ri.vsub( sphereBody.position, _r5.ri );
                                Transform.pointToWorldFrame( trimeshPos, trimeshQuat, tmp, tmp );
                                tmp.vsub( trimeshBody.position, _r5.rj );
                                Transform.vectorToWorldFrame( trimeshQuat, _r5.ni, _r5.ni );
                                Transform.vectorToWorldFrame( trimeshQuat, _r5.ri, _r5.ri );
                                this.result.push( _r5 );
                                this.createFrictionEquationsFromContact( _r5, this.frictionResult );
                            }
                        }
                    }
                } // Triangle faces
                var va = sphereTrimesh_va;
                var vb = sphereTrimesh_vb;
                var vc = sphereTrimesh_vc;
                var normal = sphereTrimesh_normal;
                for ( var _i345 = 0, N = triangles.length; _i345 !== N; _i345++ ) {
                    trimeshShape.getTriangleVertices( triangles[ _i345 ], va, vb, vc );
                    trimeshShape.getNormal( triangles[ _i345 ], normal );
                    localSpherePos.vsub( va, tmp );
                    var _dist2 = tmp.dot( normal );
                    normal.scale( _dist2, tmp );
                    localSpherePos.vsub( tmp, tmp ); // tmp is now the sphere position projected to the triangle plane
                    _dist2 = tmp.distanceTo( localSpherePos );
                    if ( Ray.pointInTriangle( tmp, va, vb, vc ) && _dist2 < sphereShape.radius ) {
                        if ( justTest ) {
                            return true;
                        }
                        var _r6 = this.createContactEquation( sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj );
                        tmp.vsub( localSpherePos, _r6.ni );
                        _r6.ni.normalize( );
                        _r6.ni.scale( sphereShape.radius, _r6.ri );
                        _r6.ri.vadd( spherePos, _r6.ri );
                        _r6.ri.vsub( sphereBody.position, _r6.ri );
                        Transform.pointToWorldFrame( trimeshPos, trimeshQuat, tmp, tmp );
                        tmp.vsub( trimeshBody.position, _r6.rj );
                        Transform.vectorToWorldFrame( trimeshQuat, _r6.ni, _r6.ni );
                        Transform.vectorToWorldFrame( trimeshQuat, _r6.ri, _r6.ri );
                        this.result.push( _r6 );
                        this.createFrictionEquationsFromContact( _r6, this.frictionResult );
                    }
                }
                triangles.length = 0;
            }
        }, {
            key: "planeTrimesh",
            value: function planeTrimesh( planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest ) { // Make contacts!
                var v = new Vec3( );
                var normal = planeTrimesh_normal;
                normal.set( 0, 0, 1 );
                planeQuat.vmult( normal, normal ); // Turn normal according to plane
                for ( var _i346 = 0; _i346 < trimeshShape.vertices.length / 3; _i346++ ) { // Get world vertex from trimesh
                    trimeshShape.getVertex( _i346, v ); // Safe up
                    var _v7 = new Vec3( );
                    _v7.copy( v );
                    Transform.pointToWorldFrame( trimeshPos, trimeshQuat, _v7, v ); // Check plane side
                    var relpos = planeTrimesh_relpos;
                    v.vsub( planePos, relpos );
                    var dot = normal.dot( relpos );
                    if ( dot <= 0.0 ) {
                        if ( justTest ) {
                            return true;
                        }
                        var r = this.createContactEquation( planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj );
                        r.ni.copy( normal ); // Contact normal is the plane normal
                        // Get vertex position projected on plane
                        var projected = planeTrimesh_projected;
                        normal.scale( relpos.dot( normal ), projected );
                        v.vsub( projected, projected ); // ri is the projected world position minus plane position
                        r.ri.copy( projected );
                        r.ri.vsub( planeBody.position, r.ri );
                        r.rj.copy( v );
                        r.rj.vsub( trimeshBody.position, r.rj ); // Store result
                        this.result.push( r );
                        this.createFrictionEquationsFromContact( r, this.frictionResult );
                    }
                }
            } // convexTrimesh(
            //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
            //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
            //   faceListA?: number[] | null, faceListB?: number[] | null,
            // ) {
            //   const sepAxis = convexConvex_sepAxis;
            //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
            //       return;
            //   }
            //   // Construct a temp hull for each triangle
            //   const hullB = new ConvexPolyhedron();
            //   hullB.faces = [[0,1,2]];
            //   const va = new Vec3();
            //   const vb = new Vec3();
            //   const vc = new Vec3();
            //   hullB.vertices = [
            //       va,
            //       vb,
            //       vc
            //   ];
            //   for (let i = 0; i < sj.indices.length / 3; i++) {
            //       const triangleNormal = new Vec3();
            //       sj.getNormal(i, triangleNormal);
            //       hullB.faceNormals = [triangleNormal];
            //       sj.getTriangleVertices(i, va, vb, vc);
            //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
            //       if(!d){
            //           triangleNormal.scale(-1, triangleNormal);
            //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
            //           if(!d){
            //               continue;
            //           }
            //       }
            //       const res: ConvexPolyhedronContactPoint[] = [];
            //       const q = convexConvex_q;
            //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
            //       for(let j = 0; j !== res.length; j++){
            //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
            //               ri = r.ri,
            //               rj = r.rj;
            //           r.ni.copy(triangleNormal);
            //           r.ni.negate(r.ni);
            //           res[j].normal.negate(q);
            //           q.mult(res[j].depth, q);
            //           res[j].point.vadd(q, ri);
            //           rj.copy(res[j].point);
            //           // Contact points are in world coordinates. Transform back to relative
            //           ri.vsub(xi,ri);
            //           rj.vsub(xj,rj);
            //           // Make relative to bodies
            //           ri.vadd(xi, ri);
            //           ri.vsub(bi.position, ri);
            //           rj.vadd(xj, rj);
            //           rj.vsub(bj.position, rj);
            //           result.push(r);
            //       }
            //   }
            // }
        } ] );
        return Narrowphase;
    }( COLLISION_TYPES.sphereSphere, COLLISION_TYPES.spherePlane, COLLISION_TYPES.boxBox, COLLISION_TYPES.sphereBox, COLLISION_TYPES.planeBox, COLLISION_TYPES.convexConvex, COLLISION_TYPES.sphereConvex, COLLISION_TYPES.planeConvex, COLLISION_TYPES.boxConvex, COLLISION_TYPES.sphereHeightfield, COLLISION_TYPES.boxHeightfield, COLLISION_TYPES.convexHeightfield, COLLISION_TYPES.sphereParticle, COLLISION_TYPES.planeParticle, COLLISION_TYPES.boxParticle, COLLISION_TYPES.convexParticle, COLLISION_TYPES.cylinderCylinder, COLLISION_TYPES.sphereCylinder, COLLISION_TYPES.planeCylinder, COLLISION_TYPES.boxCylinder, COLLISION_TYPES.convexCylinder, COLLISION_TYPES.heightfieldCylinder, COLLISION_TYPES.particleCylinder, COLLISION_TYPES.sphereTrimesh, COLLISION_TYPES.planeTrimesh );
    var averageNormal = new Vec3( );
    var averageContactPointA = new Vec3( );
    var averageContactPointB = new Vec3( );
    var tmpVec1 = new Vec3( );
    var tmpVec2 = new Vec3( );
    var tmpQuat1 = new Quaternion( );
    var tmpQuat2 = new Quaternion( );
    var planeTrimesh_normal = new Vec3( );
    var planeTrimesh_relpos = new Vec3( );
    var planeTrimesh_projected = new Vec3( );
    var sphereTrimesh_normal = new Vec3( );
    var sphereTrimesh_relpos = new Vec3( );
    new Vec3( );
    var sphereTrimesh_v = new Vec3( );
    var sphereTrimesh_v2 = new Vec3( );
    var sphereTrimesh_edgeVertexA = new Vec3( );
    var sphereTrimesh_edgeVertexB = new Vec3( );
    var sphereTrimesh_edgeVector = new Vec3( );
    var sphereTrimesh_edgeVectorUnit = new Vec3( );
    var sphereTrimesh_localSpherePos = new Vec3( );
    var sphereTrimesh_tmp = new Vec3( );
    var sphereTrimesh_va = new Vec3( );
    var sphereTrimesh_vb = new Vec3( );
    var sphereTrimesh_vc = new Vec3( );
    var sphereTrimesh_localSphereAABB = new AABB( );
    var sphereTrimesh_triangles = [ ];
    var point_on_plane_to_sphere = new Vec3( );
    var plane_to_sphere_ortho = new Vec3( ); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
    var pointInPolygon_edge = new Vec3( );
    var pointInPolygon_edge_x_normal = new Vec3( );
    var pointInPolygon_vtp = new Vec3( );

    function pointInPolygon( verts, normal, p ) {
        var positiveResult = null;
        var N = verts.length;
        for ( var _i347 = 0; _i347 !== N; _i347++ ) {
            var v = verts[ _i347 ]; // Get edge to the next vertex
            var edge = pointInPolygon_edge;
            verts[ ( _i347 + 1 ) % N ].vsub( v, edge ); // Get cross product between polygon normal and the edge
            var edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();
            edge.cross( normal, edge_x_normal ); // Get vector between point and current vertex
            var vertex_to_p = pointInPolygon_vtp;
            p.vsub( v, vertex_to_p ); // This dot product determines which side of the edge the point is
            var r = edge_x_normal.dot( vertex_to_p ); // If all such dot products have same sign, we are inside the polygon.
            if ( positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false ) {
                if ( positiveResult === null ) {
                    positiveResult = r > 0;
                }
                continue;
            } else {
                return false; // Encountered some other sign. Exit.
            }
        } // If we got here, all dot products were of the same sign.
        return true;
    }
    var box_to_sphere = new Vec3( );
    var sphereBox_ns = new Vec3( );
    var sphereBox_ns1 = new Vec3( );
    var sphereBox_ns2 = new Vec3( );
    var sphereBox_sides = [ new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ), new Vec3( ) ];
    var sphereBox_sphere_to_corner = new Vec3( );
    var sphereBox_side_ns = new Vec3( );
    var sphereBox_side_ns1 = new Vec3( );
    var sphereBox_side_ns2 = new Vec3( );
    var convex_to_sphere = new Vec3( );
    var sphereConvex_edge = new Vec3( );
    var sphereConvex_edgeUnit = new Vec3( );
    var sphereConvex_sphereToCorner = new Vec3( );
    var sphereConvex_worldCorner = new Vec3( );
    var sphereConvex_worldNormal = new Vec3( );
    var sphereConvex_worldPoint = new Vec3( );
    var sphereConvex_worldSpherePointClosestToPlane = new Vec3( );
    var sphereConvex_penetrationVec = new Vec3( );
    var sphereConvex_sphereToWorldPoint = new Vec3( );
    new Vec3( );
    new Vec3( );
    var planeConvex_v = new Vec3( );
    var planeConvex_normal = new Vec3( );
    var planeConvex_relpos = new Vec3( );
    var planeConvex_projected = new Vec3( );
    var convexConvex_sepAxis = new Vec3( );
    var convexConvex_q = new Vec3( );
    var particlePlane_normal = new Vec3( );
    var particlePlane_relpos = new Vec3( );
    var particlePlane_projected = new Vec3( );
    var particleSphere_normal = new Vec3( ); // WIP
    var cqj = new Quaternion( );
    var convexParticle_local = new Vec3( );
    new Vec3( );
    var convexParticle_penetratedFaceNormal = new Vec3( );
    var convexParticle_vertexToParticle = new Vec3( );
    var convexParticle_worldPenetrationVec = new Vec3( );
    var convexHeightfield_tmp1 = new Vec3( );
    var convexHeightfield_tmp2 = new Vec3( );
    var convexHeightfield_faceList = [ 0 ];
    var sphereHeightfield_tmp1 = new Vec3( );
    var sphereHeightfield_tmp2 = new Vec3( );
    var OverlapKeeper = /*#__PURE__*/ function( ) {
        /**
         * @todo Remove useless constructor
         */
        function OverlapKeeper( ) {
            _classCallCheck( this, OverlapKeeper );
            this.current = [ ];
            this.previous = [ ];
        }
        /**
         * getKey
         */
        _createClass( OverlapKeeper, [ {
            key: "getKey",
            value: function getKey( i, j ) {
                if ( j < i ) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                return i << 16 | j;
            }
            /**
             * set
             */
        }, {
            key: "set",
            value: function set( i, j ) { // Insertion sort. This way the diff will have linear complexity.
                var key = this.getKey( i, j );
                var current = this.current;
                var index = 0;
                while ( key > current[ index ] ) {
                    index++;
                }
                if ( key === current[ index ] ) {
                    return; // Pair was already added
                }
                for ( var _j16 = current.length - 1; _j16 >= index; _j16-- ) {
                    current[ _j16 + 1 ] = current[ _j16 ];
                }
                current[ index ] = key;
            }
            /**
             * tick
             */
        }, {
            key: "tick",
            value: function tick( ) {
                var tmp = this.current;
                this.current = this.previous;
                this.previous = tmp;
                this.current.length = 0;
            }
            /**
             * getDiff
             */
        }, {
            key: "getDiff",
            value: function getDiff( additions, removals ) {
                var a = this.current;
                var b = this.previous;
                var al = a.length;
                var bl = b.length;
                var j = 0;
                for ( var _i348 = 0; _i348 < al; _i348++ ) {
                    var found = false;
                    var keyA = a[ _i348 ];
                    while ( keyA > b[ j ] ) {
                        j++;
                    }
                    found = keyA === b[ j ];
                    if ( !found ) {
                        unpackAndPush( additions, keyA );
                    }
                }
                j = 0;
                for ( var _i349 = 0; _i349 < bl; _i349++ ) {
                    var _found = false;
                    var keyB = b[ _i349 ];
                    while ( keyB > a[ j ] ) {
                        j++;
                    }
                    _found = a[ j ] === keyB;
                    if ( !_found ) {
                        unpackAndPush( removals, keyB );
                    }
                }
            }
        } ] );
        return OverlapKeeper;
    }( );

    function unpackAndPush( array, key ) {
        array.push( ( key & 0xffff0000 ) >> 16, key & 0x0000ffff );
    }
    var getKey = function getKey( i, j ) {
        return i < j ? "".concat( i, "-" ).concat( j ) : "".concat( j, "-" ).concat( i );
    };
    /**
     * TupleDictionary
     */
    var TupleDictionary = /*#__PURE__*/ function( ) {
        function TupleDictionary( ) {
            _classCallCheck( this, TupleDictionary );
            this.data = {
                keys: [ ]
            };
        } /** get */
        _createClass( TupleDictionary, [ {
            key: "get",
            value: function get( i, j ) {
                var key = getKey( i, j );
                return this.data[ key ];
            } /** set */
        }, {
            key: "set",
            value: function set( i, j, value ) {
                var key = getKey( i, j ); // Check if key already exists
                if ( !this.get( i, j ) ) {
                    this.data.keys.push( key );
                }
                this.data[ key ] = value;
            } /** delete */
        }, {
            key: "delete",
            value: function _delete( i, j ) {
                var key = getKey( i, j );
                var index = this.data.keys.indexOf( key );
                if ( index !== -1 ) {
                    this.data.keys.splice( index, 1 );
                }
                delete this.data[ key ];
            } /** reset */
        }, {
            key: "reset",
            value: function reset( ) {
                var data = this.data;
                var keys = data.keys;
                while ( keys.length > 0 ) {
                    var key = keys.pop( );
                    delete data[ key ];
                }
            }
        } ] );
        return TupleDictionary;
    }( );
    /**
     * The physics world
     */
    var World = /*#__PURE__*/ function( _EventTarget2 ) {
        _inherits( World, _EventTarget2 );
        var _super79 = _createSuper( World );
        /**
         * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
         */
        /**
         * Makes bodies go to sleep when they've been inactive.
         * @default false
         */
        /**
         * All the current contacts (instances of ContactEquation) in the world.
         */
        /**
         * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
         * @default 0
         */
        /**
         * Set to true to use fast quaternion normalization. It is often enough accurate to use.
         * If bodies tend to explode, set to false.
         * @default false
         */
        /**
         * The wall-clock time since simulation start.
         */
        /**
         * Number of timesteps taken since start.
         */
        /**
         * Default and last timestep sizes.
         */
        /**
         * The gravity of the world.
         */
        /**
         * The broadphase algorithm to use.
         * @default NaiveBroadphase
         */
        /**
         * All bodies in this world
         */
        /**
         * True if any bodies are not sleeping, false if every body is sleeping.
         */
        /**
         * The solver algorithm to use.
         * @default GSSolver
         */
        /**
         * collisionMatrix
         */
        /**
         * CollisionMatrix from the previous step.
         */
        /**
         * All added contactmaterials.
         */
        /**
         * Used to look up a ContactMaterial given two instances of Material.
         */
        /**
         * The default material of the bodies.
         */
        /**
         * This contact material is used if no suitable contactmaterial is found for a contact.
         */
        /**
         * Time accumulator for interpolation.
         * @see https://gafferongames.com/game-physics/fix-your-timestep/
         */
        /**
         * Dispatched after a body has been added to the world.
         */
        /**
         * Dispatched after a body has been removed from the world.
         */
        function World( options ) {
            var _this64;
            _classCallCheck( this, World );
            if ( options === void 0 ) {
                options = {};
            }
            _this64 = _super79.call( this );
            _this64.dt = -1;
            _this64.allowSleep = !!options.allowSleep;
            _this64.contacts = [ ];
            _this64.frictionEquations = [ ];
            _this64.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
            _this64.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
            _this64.time = 0.0;
            _this64.stepnumber = 0;
            _this64.default_dt = 1 / 60;
            _this64.nextId = 0;
            _this64.gravity = new Vec3( );
            if ( options.gravity ) {
                _this64.gravity.copy( options.gravity );
            }
            _this64.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase( );
            _this64.bodies = [ ];
            _this64.hasActiveBodies = false;
            _this64.solver = options.solver !== undefined ? options.solver : new GSSolver( );
            _this64.constraints = [ ];
            _this64.narrowphase = new Narrowphase( _assertThisInitialized( _this64 ) );
            _this64.collisionMatrix = new ArrayCollisionMatrix( );
            _this64.collisionMatrixPrevious = new ArrayCollisionMatrix( );
            _this64.bodyOverlapKeeper = new OverlapKeeper( );
            _this64.shapeOverlapKeeper = new OverlapKeeper( );
            _this64.contactmaterials = [ ];
            _this64.contactMaterialTable = new TupleDictionary( );
            _this64.defaultMaterial = new Material( 'default' );
            _this64.defaultContactMaterial = new ContactMaterial( _this64.defaultMaterial, _this64.defaultMaterial, {
                friction: 0.3,
                restitution: 0.0
            } );
            _this64.doProfiling = false;
            _this64.profile = {
                solve: 0,
                makeContactConstraints: 0,
                broadphase: 0,
                integrate: 0,
                narrowphase: 0
            };
            _this64.accumulator = 0;
            _this64.subsystems = [ ];
            _this64.addBodyEvent = {
                type: 'addBody',
                body: null
            };
            _this64.removeBodyEvent = {
                type: 'removeBody',
                body: null
            };
            _this64.idToBodyMap = {};
            _this64.broadphase.setWorld( _assertThisInitialized( _this64 ) );
            return _this64;
        }
        /**
         * Get the contact material between materials m1 and m2
         * @return The contact material if it was found.
         */
        _createClass( World, [ {
            key: "getContactMaterial",
            value: function getContactMaterial( m1, m2 ) {
                return this.contactMaterialTable.get( m1.id, m2.id );
            }
            /**
             * Store old collision state info
             */
        }, {
            key: "collisionMatrixTick",
            value: function collisionMatrixTick( ) {
                var temp = this.collisionMatrixPrevious;
                this.collisionMatrixPrevious = this.collisionMatrix;
                this.collisionMatrix = temp;
                this.collisionMatrix.reset( );
                this.bodyOverlapKeeper.tick( );
                this.shapeOverlapKeeper.tick( );
            }
            /**
             * Add a constraint to the simulation.
             */
        }, {
            key: "addConstraint",
            value: function addConstraint( c ) {
                this.constraints.push( c );
            }
            /**
             * Removes a constraint
             */
        }, {
            key: "removeConstraint",
            value: function removeConstraint( c ) {
                var idx = this.constraints.indexOf( c );
                if ( idx !== -1 ) {
                    this.constraints.splice( idx, 1 );
                }
            }
            /**
             * Raycast test
             * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
             */
        }, {
            key: "rayTest",
            value: function rayTest( from, to, result ) {
                if ( result instanceof RaycastResult ) { // Do raycastClosest
                    this.raycastClosest( from, to, {
                        skipBackfaces: true
                    }, result );
                } else { // Do raycastAll
                    this.raycastAll( from, to, {
                        skipBackfaces: true
                    }, result );
                }
            }
            /**
             * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
             * @return True if any body was hit.
             */
        }, {
            key: "raycastAll",
            value: function raycastAll( from, to, options, callback ) {
                if ( options === void 0 ) {
                    options = {};
                }
                options.mode = Ray.ALL;
                options.from = from;
                options.to = to;
                options.callback = callback;
                return tmpRay.intersectWorld( this, options );
            }
            /**
             * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
             * @return True if any body was hit.
             */
        }, {
            key: "raycastAny",
            value: function raycastAny( from, to, options, result ) {
                if ( options === void 0 ) {
                    options = {};
                }
                options.mode = Ray.ANY;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld( this, options );
            }
            /**
             * Ray cast, and return information of the closest hit.
             * @return True if any body was hit.
             */
        }, {
            key: "raycastClosest",
            value: function raycastClosest( from, to, options, result ) {
                if ( options === void 0 ) {
                    options = {};
                }
                options.mode = Ray.CLOSEST;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld( this, options );
            }
            /**
             * Add a rigid body to the simulation.
             * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
             * @todo Adding an array of bodies should be possible. This would save some loops too
             */
        }, {
            key: "addBody",
            value: function addBody( body ) {
                if ( this.bodies.includes( body ) ) {
                    return;
                }
                body.index = this.bodies.length;
                this.bodies.push( body );
                body.world = this;
                body.initPosition.copy( body.position );
                body.initVelocity.copy( body.velocity );
                body.timeLastSleepy = this.time;
                if ( body instanceof Body ) {
                    body.initAngularVelocity.copy( body.angularVelocity );
                    body.initQuaternion.copy( body.quaternion );
                }
                this.collisionMatrix.setNumObjects( this.bodies.length );
                this.addBodyEvent.body = body;
                this.idToBodyMap[ body.id ] = body;
                this.dispatchEvent( this.addBodyEvent );
            }
            /**
             * Remove a rigid body from the simulation.
             */
        }, {
            key: "removeBody",
            value: function removeBody( body ) {
                body.world = null;
                var n = this.bodies.length - 1;
                var bodies = this.bodies;
                var idx = bodies.indexOf( body );
                if ( idx !== -1 ) {
                    bodies.splice( idx, 1 ); // Todo: should use a garbage free method
                    // Recompute index
                    for ( var _i350 = 0; _i350 !== bodies.length; _i350++ ) {
                        bodies[ _i350 ].index = _i350;
                    }
                    this.collisionMatrix.setNumObjects( n );
                    this.removeBodyEvent.body = body;
                    delete this.idToBodyMap[ body.id ];
                    this.dispatchEvent( this.removeBodyEvent );
                }
            }
        }, {
            key: "getBodyById",
            value: function getBodyById( id ) {
                return this.idToBodyMap[ id ];
            }
            /**
             * @todo Make a faster map
             */
        }, {
            key: "getShapeById",
            value: function getShapeById( id ) {
                var bodies = this.bodies;
                for ( var _i351 = 0; _i351 < bodies.length; _i351++ ) {
                    var shapes = bodies[ _i351 ].shapes;
                    for ( var j = 0; j < shapes.length; j++ ) {
                        var shape = shapes[ j ];
                        if ( shape.id === id ) {
                            return shape;
                        }
                    }
                }
                return null;
            }
            /**
             * Adds a contact material to the World
             */
        }, {
            key: "addContactMaterial",
            value: function addContactMaterial( cmat ) { // Add contact material
                this.contactmaterials.push( cmat ); // Add current contact material to the material table
                this.contactMaterialTable.set( cmat.materials[ 0 ].id, cmat.materials[ 1 ].id, cmat );
            }
            /**
             * Removes a contact material from the World.
             */
        }, {
            key: "removeContactMaterial",
            value: function removeContactMaterial( cmat ) {
                var idx = this.contactmaterials.indexOf( cmat );
                if ( idx === -1 ) {
                    return;
                }
                this.contactmaterials.splice( idx, 1 );
                this.contactMaterialTable[ "delete" ]( cmat.materials[ 0 ].id, cmat.materials[ 1 ].id );
            }
            /**
             * Step the simulation forward keeping track of last called time
             * to be able to step the world at a fixed rate, independently of framerate.
             *
             * @param dt The fixed time step size to use (default: 1 / 60).
             * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
             * @see https://gafferongames.com/post/fix_your_timestep/
             * @example
             *     // Run the simulation independently of framerate every 1 / 60 ms
             *     world.fixedStep()
             */
        }, {
            key: "fixedStep",
            value: function fixedStep( dt, maxSubSteps ) {
                if ( dt === void 0 ) {
                    dt = 1 / 60;
                }
                if ( maxSubSteps === void 0 ) {
                    maxSubSteps = 10;
                }
                var time = performance$1.now( ) / 1000; // seconds
                if ( !this.lastCallTime ) {
                    this.step( dt, undefined, maxSubSteps );
                } else {
                    var timeSinceLastCalled = time - this.lastCallTime;
                    this.step( dt, timeSinceLastCalled, maxSubSteps );
                }
                this.lastCallTime = time;
            }
            /**
             * Step the physics world forward in time.
             *
             * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
             *
             * @param dt The fixed time step size to use.
             * @param timeSinceLastCalled The time elapsed since the function was last called.
             * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
             * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
             * @example
             *     // fixed timestepping without interpolation
             *     world.step(1 / 60)
             */
        }, {
            key: "step",
            value: function step( dt, timeSinceLastCalled, maxSubSteps ) {
                if ( maxSubSteps === void 0 ) {
                    maxSubSteps = 10;
                }
                if ( timeSinceLastCalled === undefined ) { // Fixed, simple stepping
                    this.internalStep( dt ); // Increment time
                    this.time += dt;
                } else {
                    this.accumulator += timeSinceLastCalled;
                    var t0 = performance$1.now( );
                    var substeps = 0;
                    while ( this.accumulator >= dt && substeps < maxSubSteps ) { // Do fixed steps to catch up
                        this.internalStep( dt );
                        this.accumulator -= dt;
                        substeps++;
                        if ( performance$1.now( ) - t0 > dt * 1000 ) { // The framerate is not interactive anymore.
                            // We are below the target framerate.
                            // Better bail out.
                            break;
                        }
                    } // Remove the excess accumulator, since we may not
                    // have had enough substeps available to catch up
                    this.accumulator = this.accumulator % dt;
                    var t = this.accumulator / dt;
                    for ( var j = 0; j !== this.bodies.length; j++ ) {
                        var _b16 = this.bodies[ j ];
                        _b16.previousPosition.lerp( _b16.position, t, _b16.interpolatedPosition );
                        _b16.previousQuaternion.slerp( _b16.quaternion, t, _b16.interpolatedQuaternion );
                        _b16.previousQuaternion.normalize( );
                    }
                    this.time += timeSinceLastCalled;
                }
            }
        }, {
            key: "internalStep",
            value: function internalStep( dt ) {
                this.dt = dt;
                var contacts = this.contacts;
                var p1 = World_step_p1;
                var p2 = World_step_p2;
                var N = this.bodies.length;
                var bodies = this.bodies;
                var solver = this.solver;
                var gravity = this.gravity;
                var doProfiling = this.doProfiling;
                var profile = this.profile;
                var DYNAMIC = Body.DYNAMIC;
                var profilingStart = -Infinity;
                var constraints = this.constraints;
                var frictionEquationPool = World_step_frictionEquationPool;
                gravity.length( );
                var gx = gravity.x;
                var gy = gravity.y;
                var gz = gravity.z;
                var i = 0;
                if ( doProfiling ) {
                    profilingStart = performance$1.now( );
                } // Add gravity to all objects
                for ( i = 0; i !== N; i++ ) {
                    var bi = bodies[ i ];
                    if ( bi.type === DYNAMIC ) { // Only for dynamic bodies
                        var f = bi.force;
                        var m = bi.mass;
                        f.x += m * gx;
                        f.y += m * gy;
                        f.z += m * gz;
                    }
                } // Update subsystems
                for ( var _i352 = 0, Nsubsystems = this.subsystems.length; _i352 !== Nsubsystems; _i352++ ) {
                    this.subsystems[ _i352 ].update( );
                } // Collision detection
                if ( doProfiling ) {
                    profilingStart = performance$1.now( );
                }
                p1.length = 0; // Clean up pair arrays from last step
                p2.length = 0;
                this.broadphase.collisionPairs( this, p1, p2 );
                if ( doProfiling ) {
                    profile.broadphase = performance$1.now( ) - profilingStart;
                } // Remove constrained pairs with collideConnected == false
                var Nconstraints = constraints.length;
                for ( i = 0; i !== Nconstraints; i++ ) {
                    var _c15 = constraints[ i ];
                    if ( !_c15.collideConnected ) {
                        for ( var j = p1.length - 1; j >= 0; j -= 1 ) {
                            if ( _c15.bodyA === p1[ j ] && _c15.bodyB === p2[ j ] || _c15.bodyB === p1[ j ] && _c15.bodyA === p2[ j ] ) {
                                p1.splice( j, 1 );
                                p2.splice( j, 1 );
                            }
                        }
                    }
                }
                this.collisionMatrixTick( ); // Generate contacts
                if ( doProfiling ) {
                    profilingStart = performance$1.now( );
                }
                var oldcontacts = World_step_oldContacts;
                var NoldContacts = contacts.length;
                for ( i = 0; i !== NoldContacts; i++ ) {
                    oldcontacts.push( contacts[ i ] );
                }
                contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse
                var NoldFrictionEquations = this.frictionEquations.length;
                for ( i = 0; i !== NoldFrictionEquations; i++ ) {
                    frictionEquationPool.push( this.frictionEquations[ i ] );
                }
                this.frictionEquations.length = 0;
                this.narrowphase.getContacts( p1, p2, this, contacts, oldcontacts, // To be reused
                    this.frictionEquations, frictionEquationPool );
                if ( doProfiling ) {
                    profile.narrowphase = performance$1.now( ) - profilingStart;
                } // Loop over all collisions
                if ( doProfiling ) {
                    profilingStart = performance$1.now( );
                } // Add all friction eqs
                for ( i = 0; i < this.frictionEquations.length; i++ ) {
                    solver.addEquation( this.frictionEquations[ i ] );
                }
                var ncontacts = contacts.length;
                for ( var k = 0; k !== ncontacts; k++ ) { // Current contact
                    var _c16 = contacts[ k ]; // Get current collision indeces
                    var _bi = _c16.bi;
                    var bj = _c16.bj;
                    var si = _c16.si;
                    var sj = _c16.sj; // Get collision properties
                    var cm = void 0;
                    if ( _bi.material && bj.material ) {
                        cm = this.getContactMaterial( _bi.material, bj.material ) || this.defaultContactMaterial;
                    } else {
                        cm = this.defaultContactMaterial;
                    } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                    cm.friction; // c.restitution = cm.restitution;
                    // If friction or restitution were specified in the material, use them
                    if ( _bi.material && bj.material ) {
                        if ( _bi.material.friction >= 0 && bj.material.friction >= 0 ) {
                            _bi.material.friction * bj.material.friction;
                        }
                        if ( _bi.material.restitution >= 0 && bj.material.restitution >= 0 ) {
                            _c16.restitution = _bi.material.restitution * bj.material.restitution;
                        }
                    } // c.setSpookParams(
                    //           cm.contactEquationStiffness,
                    //           cm.contactEquationRelaxation,
                    //           dt
                    //       );
                    solver.addEquation( _c16 ); // // Add friction constraint equation
                    // if(mu > 0){
                    // 	// Create 2 tangent equations
                    // 	const mug = mu * gnorm;
                    // 	const reducedMass = (bi.invMass + bj.invMass);
                    // 	if(reducedMass > 0){
                    // 		reducedMass = 1/reducedMass;
                    // 	}
                    // 	const pool = frictionEquationPool;
                    // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                    // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                    // 	this.frictionEquations.push(c1, c2);
                    // 	c1.bi = c2.bi = bi;
                    // 	c1.bj = c2.bj = bj;
                    // 	c1.minForce = c2.minForce = -mug*reducedMass;
                    // 	c1.maxForce = c2.maxForce = mug*reducedMass;
                    // 	// Copy over the relative vectors
                    // 	c1.ri.copy(c.ri);
                    // 	c1.rj.copy(c.rj);
                    // 	c2.ri.copy(c.ri);
                    // 	c2.rj.copy(c.rj);
                    // 	// Construct tangents
                    // 	c.ni.tangents(c1.t, c2.t);
                    //           // Set spook params
                    //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                    //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                    //           c1.enabled = c2.enabled = c.enabled;
                    // 	// Add equations to solver
                    // 	solver.addEquation(c1);
                    // 	solver.addEquation(c2);
                    // }
                    if ( _bi.allowSleep && _bi.type === Body.DYNAMIC && _bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC ) {
                        var speedSquaredB = bj.velocity.lengthSquared( ) + bj.angularVelocity.lengthSquared( );
                        var speedLimitSquaredB = Math.pow( bj.sleepSpeedLimit, 2 );
                        if ( speedSquaredB >= speedLimitSquaredB * 2 ) {
                            _bi.wakeUpAfterNarrowphase = true;
                        }
                    }
                    if ( bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && _bi.sleepState === Body.AWAKE && _bi.type !== Body.STATIC ) {
                        var speedSquaredA = _bi.velocity.lengthSquared( ) + _bi.angularVelocity.lengthSquared( );
                        var speedLimitSquaredA = Math.pow( _bi.sleepSpeedLimit, 2 );
                        if ( speedSquaredA >= speedLimitSquaredA * 2 ) {
                            bj.wakeUpAfterNarrowphase = true;
                        }
                    } // Now we know that i and j are in contact. Set collision matrix state
                    this.collisionMatrix.set( _bi, bj, true );
                    if ( !this.collisionMatrixPrevious.get( _bi, bj ) ) { // First contact!
                        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
                        World_step_collideEvent.body = bj;
                        World_step_collideEvent.contact = _c16;
                        _bi.dispatchEvent( World_step_collideEvent );
                        World_step_collideEvent.body = _bi;
                        bj.dispatchEvent( World_step_collideEvent );
                    }
                    this.bodyOverlapKeeper.set( _bi.id, bj.id );
                    this.shapeOverlapKeeper.set( si.id, sj.id );
                }
                this.emitContactEvents( );
                if ( doProfiling ) {
                    profile.makeContactConstraints = performance$1.now( ) - profilingStart;
                    profilingStart = performance$1.now( );
                } // Wake up bodies
                for ( i = 0; i !== N; i++ ) {
                    var _bi2 = bodies[ i ];
                    if ( _bi2.wakeUpAfterNarrowphase ) {
                        _bi2.wakeUp( );
                        _bi2.wakeUpAfterNarrowphase = false;
                    }
                } // Add user-added constraints
                Nconstraints = constraints.length;
                for ( i = 0; i !== Nconstraints; i++ ) {
                    var _c17 = constraints[ i ];
                    _c17.update( );
                    for ( var _j17 = 0, Neq = _c17.equations.length; _j17 !== Neq; _j17++ ) {
                        var eq = _c17.equations[ _j17 ];
                        solver.addEquation( eq );
                    }
                } // Solve the constrained system
                solver.solve( dt, this );
                if ( doProfiling ) {
                    profile.solve = performance$1.now( ) - profilingStart;
                } // Remove all contacts from solver
                solver.removeAllEquations( ); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
                var pow = Math.pow;
                for ( i = 0; i !== N; i++ ) {
                    var _bi3 = bodies[ i ];
                    if ( _bi3.type & DYNAMIC ) { // Only for dynamic bodies
                        var ld = pow( 1.0 - _bi3.linearDamping, dt );
                        var v = _bi3.velocity;
                        v.scale( ld, v );
                        var av = _bi3.angularVelocity;
                        if ( av ) {
                            var ad = pow( 1.0 - _bi3.angularDamping, dt );
                            av.scale( ad, av );
                        }
                    }
                }
                this.dispatchEvent( World_step_preStepEvent ); // Leap frog
                // vnew = v + h*f/m
                // xnew = x + h*vnew
                if ( doProfiling ) {
                    profilingStart = performance$1.now( );
                }
                var stepnumber = this.stepnumber;
                var quatNormalize = stepnumber % ( this.quatNormalizeSkip + 1 ) === 0;
                var quatNormalizeFast = this.quatNormalizeFast;
                for ( i = 0; i !== N; i++ ) {
                    bodies[ i ].integrate( dt, quatNormalize, quatNormalizeFast );
                }
                this.clearForces( );
                this.broadphase.dirty = true;
                if ( doProfiling ) {
                    profile.integrate = performance$1.now( ) - profilingStart;
                } // Update step number
                this.stepnumber += 1;
                this.dispatchEvent( World_step_postStepEvent ); // Sleeping update
                var hasActiveBodies = true;
                if ( this.allowSleep ) {
                    hasActiveBodies = false;
                    for ( i = 0; i !== N; i++ ) {
                        var _bi4 = bodies[ i ];
                        _bi4.sleepTick( this.time );
                        if ( _bi4.sleepState !== Body.SLEEPING ) {
                            hasActiveBodies = true;
                        }
                    }
                }
                this.hasActiveBodies = hasActiveBodies;
            }
        }, {
            key: "emitContactEvents",
            value: function emitContactEvents( ) {
                var hasBeginContact = this.hasAnyEventListener( 'beginContact' );
                var hasEndContact = this.hasAnyEventListener( 'endContact' );
                if ( hasBeginContact || hasEndContact ) {
                    this.bodyOverlapKeeper.getDiff( additions, removals );
                }
                if ( hasBeginContact ) {
                    for ( var _i353 = 0, l = additions.length; _i353 < l; _i353 += 2 ) {
                        beginContactEvent.bodyA = this.getBodyById( additions[ _i353 ] );
                        beginContactEvent.bodyB = this.getBodyById( additions[ _i353 + 1 ] );
                        this.dispatchEvent( beginContactEvent );
                    }
                    beginContactEvent.bodyA = beginContactEvent.bodyB = null;
                }
                if ( hasEndContact ) {
                    for ( var _i354 = 0, _l9 = removals.length; _i354 < _l9; _i354 += 2 ) {
                        endContactEvent.bodyA = this.getBodyById( removals[ _i354 ] );
                        endContactEvent.bodyB = this.getBodyById( removals[ _i354 + 1 ] );
                        this.dispatchEvent( endContactEvent );
                    }
                    endContactEvent.bodyA = endContactEvent.bodyB = null;
                }
                additions.length = removals.length = 0;
                var hasBeginShapeContact = this.hasAnyEventListener( 'beginShapeContact' );
                var hasEndShapeContact = this.hasAnyEventListener( 'endShapeContact' );
                if ( hasBeginShapeContact || hasEndShapeContact ) {
                    this.shapeOverlapKeeper.getDiff( additions, removals );
                }
                if ( hasBeginShapeContact ) {
                    for ( var _i355 = 0, _l10 = additions.length; _i355 < _l10; _i355 += 2 ) {
                        var shapeA = this.getShapeById( additions[ _i355 ] );
                        var shapeB = this.getShapeById( additions[ _i355 + 1 ] );
                        beginShapeContactEvent.shapeA = shapeA;
                        beginShapeContactEvent.shapeB = shapeB;
                        if ( shapeA ) beginShapeContactEvent.bodyA = shapeA.body;
                        if ( shapeB ) beginShapeContactEvent.bodyB = shapeB.body;
                        this.dispatchEvent( beginShapeContactEvent );
                    }
                    beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
                }
                if ( hasEndShapeContact ) {
                    for ( var _i356 = 0, _l11 = removals.length; _i356 < _l11; _i356 += 2 ) {
                        var _shapeA = this.getShapeById( removals[ _i356 ] );
                        var _shapeB = this.getShapeById( removals[ _i356 + 1 ] );
                        endShapeContactEvent.shapeA = _shapeA;
                        endShapeContactEvent.shapeB = _shapeB;
                        if ( _shapeA ) endShapeContactEvent.bodyA = _shapeA.body;
                        if ( _shapeB ) endShapeContactEvent.bodyB = _shapeB.body;
                        this.dispatchEvent( endShapeContactEvent );
                    }
                    endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
                }
            }
            /**
             * Sets all body forces in the world to zero.
             */
        }, {
            key: "clearForces",
            value: function clearForces( ) {
                var bodies = this.bodies;
                var N = bodies.length;
                for ( var _i357 = 0; _i357 !== N; _i357++ ) {
                    var _b17 = bodies[ _i357 ];
                    _b17.force;
                    _b17.torque;
                    _b17.force.set( 0, 0, 0 );
                    _b17.torque.set( 0, 0, 0 );
                }
            }
        } ] );
        return World;
    }( EventTarget ); // Temp stuff
    new AABB( );
    var tmpRay = new Ray( ); // performance.now() fallback on Date.now()
    var performance$1 = globalThis.performance || {};
    if ( !performance$1.now ) {
        var nowOffset = Date.now( );
        if ( performance$1.timing && performance$1.timing.navigationStart ) {
            nowOffset = performance$1.timing.navigationStart;
        }
        performance$1.now = function( ) {
            return Date.now( ) - nowOffset;
        };
    }
    new Vec3( ); // Dispatched after the world has stepped forward in time.
    // Reusable event objects to save memory.
    var World_step_postStepEvent = {
        type: 'postStep'
    }; // Dispatched before the world steps forward in time.
    var World_step_preStepEvent = {
        type: 'preStep'
    };
    var World_step_collideEvent = {
        type: Body.COLLIDE_EVENT_NAME,
        body: null,
        contact: null
    }; // Pools for unused objects
    var World_step_oldContacts = [ ];
    var World_step_frictionEquationPool = [ ]; // Reusable arrays for collision pairs
    var World_step_p1 = [ ];
    var World_step_p2 = [ ]; // Stuff for emitContactEvents
    var additions = [ ];
    var removals = [ ];
    var beginContactEvent = {
        type: 'beginContact',
        bodyA: null,
        bodyB: null
    };
    var endContactEvent = {
        type: 'endContact',
        bodyA: null,
        bodyB: null
    };
    var beginShapeContactEvent = {
        type: 'beginShapeContact',
        bodyA: null,
        bodyB: null,
        shapeA: null,
        shapeB: null
    };
    var endShapeContactEvent = {
        type: 'endShapeContact',
        bodyA: null,
        bodyB: null,
        shapeA: null,
        shapeB: null
    };
    var Dice = /*#__PURE__*/ function( ) {
        function Dice( mesh, body ) {
            _classCallCheck( this, Dice );
            this.mesh = mesh;
            this.body = body;
        }
        _createClass( Dice, [ {
            key: "getMesh",
            value: function getMesh( ) {
                return this.mesh;
            }
        }, {
            key: "getFace",
            value: function getFace( ) {
                var up = Dice.upV,
                    quat = Dice.quatH;
                up.set( 0, 1, 0 );
                quat.copy( this.mesh.quaternion );
                quat.invert( );
                up.applyQuaternion( quat );
                up.normalize( );
                var ax = Math.abs( up.x ),
                    ay = Math.abs( up.y ),
                    az = Math.abs( up.z );
                var m = Math.max( ax, ay, az );
                if ( m == ax ) {
                    return Number( up.x < 0 ) * 3 + 2;
                } else if ( m == ay ) {
                    return Number( up.y > 0 ) * 5 + 1;
                } else {
                    return Number( up.z < 0 ) + 3;
                }
            }
        }, {
            key: "update",
            value: function update( ) {
                var mesh = this.mesh,
                    body = this.body;
                mesh.position.copy( body.position );
                mesh.quaternion.copy( body.quaternion );
            }
        }, {
            key: "roll",
            value: function roll( ) {
                var mesh = this.mesh,
                    body = this.body;
                body.position.set( 0, 50, 0 );
                var linMult = 50,
                    angMult = 75;
                body.velocity.set( ( Math.random( ) - 0.5 ) * linMult, Math.random( ) * linMult, ( Math.random( ) - 0.5 ) * linMult );
                body.angularVelocity.set( ( Math.random( ) - 0.5 ) * angMult, ( Math.random( ) - 0.5 ) * angMult, ( Math.random( ) - 0.5 ) * angMult );
                mesh.position.set( 0, 50, 0 );
            }
        } ], [ {
            key: "init",
            value: function init( ) {
                var world = new World( {
                    allowSleep: true
                } );
                world.gravity.set( 0, -100, 0 );
                world.defaultContactMaterial.friction = 10;
                world.defaultContactMaterial.restitution = 0.75;
                var size = 100;
                var size5 = size - 0.5;
                var body = new Body( {
                    mass: 0,
                    position: new Vec3( 0, size + 5, 0 )
                } );
                body.addShape( new Box( new Vec3( size, 0.5, size ) ), new Vec3( 0, -size5, 0 ) );
                body.addShape( new Box( new Vec3( size, 0.5, size ) ), new Vec3( 0, size5, 0 ) );
                body.addShape( new Box( new Vec3( 0.5, size, size ) ), new Vec3( -size5, 0, 0 ) );
                body.addShape( new Box( new Vec3( 0.5, size, size ) ), new Vec3( size5, 0, 0 ) );
                body.addShape( new Box( new Vec3( size, size, 0.5 ) ), new Vec3( 0, 0, -size5 ) );
                body.addShape( new Box( new Vec3( size, size, 0.5 ) ), new Vec3( 0, 0, size5 ) );
                world.addBody( body );
                this.world = world;
            }
        }, {
            key: "createDie",
            value: function createDie( dieMesh ) {
                if ( !this.world ) return;
                if ( !this.dieMesh && !dieMesh ) {
                    throw "Must have input a die mesh for the first die creation";
                } else if ( !this.dieMesh ) {
                    this.dieMesh = dieMesh;
                }
                var mesh = new Mesh( this.dieMesh.geometry, this.dieMesh.material );
                var body = new Body( {
                    mass: 10,
                    shape: new Box( new Vec3( 20, 20, 20 ) )
                } );
                this.world.addBody( body );
                var die = new Dice( mesh, body );
                this.dice.push( die );
                return die;
            }
        }, {
            key: "roll",
            value: function roll( ) {
                var _iterator9 = _createForOfIteratorHelper( this.dice ),
                    _step9;
                try {
                    for ( _iterator9.s( ); !( _step9 = _iterator9.n( ) ).done; ) {
                        var die = _step9.value;
                        die.roll( );
                    }
                } catch ( err ) {
                    _iterator9.e( err );
                } finally {
                    _iterator9.f( );
                }
            }
        }, {
            key: "update",
            value: function update( ) {
                if ( !this.world ) return;
                this.world.step( 1 / 60, this.clock.getDelta( ), 4 );
                var _iterator10 = _createForOfIteratorHelper( this.dice ),
                    _step10;
                try {
                    for ( _iterator10.s( ); !( _step10 = _iterator10.n( ) ).done; ) {
                        var die = _step10.value;
                        if ( die.body.sleepState == BODY_SLEEP_STATES.SLEEPING ) die.body.wakeUp( );
                        die.update( );
                    }
                } catch ( err ) {
                    _iterator10.e( err );
                } finally {
                    _iterator10.f( );
                }
            }
        }, {
            key: "readDice",
            value: function readDice( ) {
                var t = 0,
                    n = 0;
                var scope = this;
                var p = new Promise( function( resolve, reject ) {
                    var _iterator11 = _createForOfIteratorHelper( scope.dice ),
                        _step11;
                    try {
                        var _loop3 = function _loop3( ) {
                            var die = _step11.value;

                            function onSleep( ) {
                                t += die.getFace( );
                                n++;
                                die.body.removeEventListener( "sleep", onSleep );
                                if ( n == scope.dice.length ) resolve( t );
                            }
                            die.body.addEventListener( "sleep", onSleep );
                        };
                        for ( _iterator11.s( ); !( _step11 = _iterator11.n( ) ).done; ) {
                            _loop3( );
                        }
                    } catch ( err ) {
                        _iterator11.e( err );
                    } finally {
                        _iterator11.f( );
                    }
                } );
                return p;
            }
        }, {
            key: "rollDice",
            value: function rollDice( ) {
                var scope = this;
                var camera = Globals.camera,
                    v0 = Globals.v0,
                    v1 = Globals.v1,
                    q0 = Globals.q0,
                    q1 = Globals.q1,
                    fromIObj = Globals.fromIObj,
                    toIObj = Globals.toIObj;
                fromIObj.a = 0;
                toIObj.a = 1;
                v0.copy( camera.position );
                v1.setScalar( 150 );
                q0.copy( camera.quaternion );
                q1.set( -0.27984814233312133, 0.3647051996310009, 0.11591689595929514, 0.8804762392171493 );
                var p = new Promise( function( resolve, reject ) {
                    new Tween( fromIObj ).to( toIObj, 3000 ).onUpdate( function( _ref11 ) {
                        var a = _ref11.a;
                        camera.position.lerpVectors( v0, v1, a );
                        camera.quaternion.slerpQuaternions( q0, q1, a );
                    } ).onComplete( function( ) {
                        scope.roll( );
                        scope.readDice( ).then( resolve );
                    } ).start( );
                } );
                return p;
            }
        } ] );
        return Dice;
    }( );
    Dice.dice = [ ];
    Dice.upV = new Vector3( );
    Dice.quatH = new Quaternion$1( );
    Dice.clock = new Clock( );
    var _window = window,
        width = _window.innerWidth,
        height = _window.innerHeight;
    var animations = {
        show: function show( ) {
            return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee45( ) {
                return _regeneratorRuntime( ).wrap( function _callee45$( _context52 ) {
                    while ( 1 ) {
                        switch ( _context52.prev = _context52.next ) {
                            case 0:
                            case "end":
                                return _context52.stop( );
                        }
                    }
                }, _callee45 );
            } ) )( );
        },
        hide: function hide( ) {
            return _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee46( ) {
                return _regeneratorRuntime( ).wrap( function _callee46$( _context53 ) {
                    while ( 1 ) {
                        switch ( _context53.prev = _context53.next ) {
                            case 0:
                            case "end":
                                return _context53.stop( );
                        }
                    }
                }, _callee46 );
            } ) )( );
        }
    }; {
        var cover = document.getElementsByClassName( "cover" )[ 0 ];
        document.body.appendChild( cover );
        var showEffect = new KeyframeEffect( cover, [ {
            width: "100%",
            height: "100%"
        }, {
            width: "0px",
            height: "0px"
        } ], {
            duration: 1000,
            easing: "ease-out",
            fill: "forwards"
        } );
        var hideEffect = new KeyframeEffect( cover, [ {
            width: "0px",
            height: "0px"
        }, {
            width: "100%",
            height: "100%"
        } ], {
            duration: 1000,
            easing: "ease-in",
            fill: "forwards"
        } );
        animations.show = function( ) {
            var showAnimation = new Animation( showEffect, document.timeline );
            return new Promise( function( resolve ) {
                function onEnd( ) {
                    showAnimation.removeEventListener( "finish", onEnd );
                    resolve( );
                }
                showAnimation.addEventListener( "finish", onEnd );
                showAnimation.play( );
            } );
        };
        animations.hide = function( ) {
            var hideAnimation = new Animation( hideEffect, document.timeline );
            return new Promise( function( resolve ) {
                function onEnd( ) {
                    hideAnimation.removeEventListener( "finish", onEnd );
                    resolve( );
                }
                hideAnimation.addEventListener( "finish", onEnd );
                hideAnimation.play( );
            } );
        };
    }
    var renderer = new WebGLRenderer( );
    renderer.setSize( width, height );
    renderer.setClearColor( 0xBFD1E5 );
    document.getElementById( "game" ).appendChild( renderer.domElement );
    var scene = new Scene( );
    var camera = new PerspectiveCamera( 75, width / height, 100, 3000 );
    camera.position.y = 1000;
    camera.position.x = 2000;
    Globals.camera = camera;
    var dLight = new DirectionalLight( );
    scene.add( dLight );
    var pmrem = new PMREMGenerator( renderer );
    var loaded = {
        die: false,
        board: false,
        environment: false,
        ran: false
    };
    var loader = new GLTFLoader( );
    var assets = {
        tokens: {
            hat: null,
            iron: null,
            barrow: null,
            thimble: null
        },
        board: null
    };
    loader.load( "../resources/models/die.glb", function( gltf ) {
        Dice.init( );
        var dieMesh = gltf.scene.getObjectByName( "Box001_Material_#25_0" );
        dieMesh.geometry.center( );
        scene.add( Dice.createDie( dieMesh ).getMesh( ) );
        scene.add( Dice.createDie( ).getMesh( ) );
        loaded.die = true;
    } );
    loader.load( "../resources/models/board.glb", function( gltf ) {
        var names = [ "Top_Hat_09_-_Default_0", "Iron_09_-_Default_0", "Wheel_Barrow_09_-_Default_0", "Thimble_09_-_Default_0" ];
        var tokens = [ ];
        for ( var _i358 = 0, _names = names; _i358 < _names.length; _i358++ ) {
            var name = _names[ _i358 ];
            var o = gltf.scene.getObjectByName( name );
            o.geometry.rotateX( -Math.PI / 2 );
            o.geometry.rotateY( Math.PI / 2 );
            scene.add( o );
            tokens.push( o );
        }
        assets.tokens.hat = tokens[ 0 ];
        assets.tokens.iron = tokens[ 1 ];
        assets.tokens.barrow = tokens[ 2 ];
        assets.tokens.thimble = tokens[ 3 ];
        assets.tokens.barrow.visible = assets.tokens.thimble.visible = false;
        camera.position.set( 0, 975, 0 );
        camera.quaternion.set( -Math.SQRT1_2, 0, 0, Math.SQRT1_2 );
        assets.board = gltf.scene.getObjectByName( "Board_01_-_Default_0" );
        assets.board.geometry.rotateX( -Math.PI / 2 );
        assets.board.position.y = -5;
        scene.add( assets.board );
        var house = gltf.scene.getObjectByName( "House_07_-_Default_0" );
        house.geometry.rotateX( -Math.PI / 2 );
        house.geometry.scale( 1 / 3, 1 / 3, 1 / 3 );
        Globals.houseMesh = new InstancedMesh( house.geometry, house.material, 112 );
        Globals.houseMesh.instanceMatrix.setUsage( DynamicDrawUsage );
        scene.add( Globals.houseMesh );
        loaded.board = true;
    } );

    function gameLoop( ) {
        return _gameLoop.apply( this, arguments );
    }

    function _gameLoop( ) {
        _gameLoop = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee48( ) {
            var _iterator12, _step12, _loop4;
            return _regeneratorRuntime( ).wrap( function _callee48$( _context55 ) {
                while ( 1 ) {
                    switch ( _context55.prev = _context55.next ) {
                        case 0:
                            if ( !( Globals.players.length == 1 ) ) {
                                _context55.next = 2;
                                break;
                            }
                            return _context55.abrupt( "return" );
                        case 2:
                            _iterator12 = _createForOfIteratorHelper( Globals.players );
                            try {
                                _loop4 = function _loop4( ) {
                                    var player = _step12.value; //eslint-disable-next-line no-inner-declarations
                                    function onPress( _x21 ) {
                                        return _onPress.apply( this, arguments );
                                    }

                                    function _onPress( ) {
                                        _onPress = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee47( button ) {
                                            return _regeneratorRuntime( ).wrap( function _callee47$( _context54 ) {
                                                while ( 1 ) {
                                                    switch ( _context54.prev = _context54.next ) {
                                                        case 0:
                                                            if ( !( button == O_BUTTON ) ) {
                                                                _context54.next = 9;
                                                                break;
                                                            }
                                                            _context54.t0 = player;
                                                            _context54.next = 4;
                                                            return Dice.rollDice( );
                                                        case 4:
                                                            _context54.t1 = _context54.sent;
                                                            _context54.next = 7;
                                                            return _context54.t0.moveForward.call( _context54.t0, _context54.t1 );
                                                        case 7:
                                                            _context54.next = 12;
                                                            break;
                                                        case 9:
                                                            _context54.next = 11;
                                                            return player.showStats( );
                                                        case 11:
                                                            player.awaitButtonPress( [ O_BUTTON, SQUARE_BUTTON ] ).then( onPress );
                                                        case 12:
                                                        case "end":
                                                            return _context54.stop( );
                                                    }
                                                }
                                            }, _callee47 );
                                        } ) );
                                        return _onPress.apply( this, arguments );
                                    }
                                    player.awaitButtonPress( [ O_BUTTON, SQUARE_BUTTON ] ).then( onPress );
                                };
                                for ( _iterator12.s( ); !( _step12 = _iterator12.n( ) ).done; ) {
                                    _loop4( );
                                }
                            } catch ( err ) {
                                _iterator12.e( err );
                            } finally {
                                _iterator12.f( );
                            }
                            gameLoop( );
                        case 5:
                        case "end":
                            return _context55.stop( );
                    }
                }
            }, _callee48 );
        } ) );
        return _gameLoop.apply( this, arguments );
    }

    function onLoad( ) {
        return _onLoad.apply( this, arguments );
    }

    function _onLoad( ) {
        _onLoad = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime( ).mark( function _callee49( ) {
            var screens, numPlayers, names, unused, buttonCheck, buttons, buttonKeys, _i360, player, button;
            return _regeneratorRuntime( ).wrap( function _callee49$( _context56 ) {
                while ( 1 ) {
                    switch ( _context56.prev = _context56.next ) {
                        case 0:
                            screens = document.getElementById( "screens" ).children;
                            screens[ 0 ].style.display = "block";
                            _context56.next = 4;
                            return wait( 1000 );
                        case 4:
                            _context56.next = 6;
                            return animations.show( );
                        case 6:
                            _context56.next = 8;
                            return new Promise( function( resolve ) {
                                var buttons = document.getElementsByClassName( "numButton" );

                                function onClick( event ) {
                                    var _iterator13 = _createForOfIteratorHelper( buttons ),
                                        _step13;
                                    try {
                                        for ( _iterator13.s( ); !( _step13 = _iterator13.n( ) ).done; ) {
                                            var button = _step13.value;
                                            button.removeEventListener( "click", onClick );
                                        }
                                    } catch ( err ) {
                                        _iterator13.e( err );
                                    } finally {
                                        _iterator13.f( );
                                    }
                                    resolve( parseInt( event.target.innerHTML ) );
                                }
                                var _iterator14 = _createForOfIteratorHelper( buttons ),
                                    _step14;
                                try {
                                    for ( _iterator14.s( ); !( _step14 = _iterator14.n( ) ).done; ) {
                                        var button = _step14.value;
                                        button.addEventListener( "click", onClick );
                                    }
                                } catch ( err ) {
                                    _iterator14.e( err );
                                } finally {
                                    _iterator14.f( );
                                }
                            } );
                        case 8:
                            numPlayers = _context56.sent;
                            _context56.next = 11;
                            return animations.hide( );
                        case 11:
                            screens[ 0 ].style.display = "none";
                            screens[ 1 ].style.display = "block";
                            _context56.next = 15;
                            return wait( 250 );
                        case 15:
                            _context56.next = 17;
                            return animations.show( );
                        case 17:
                            _context56.next = 19;
                            return new Promise( function( resolve ) {
                                var input = document.getElementById( "nameInput" );
                                var button = document.getElementById( "submitName" );
                                var names = [ ];

                                function onClick( ) {
                                    names.push( input.value );
                                    input.value = "";
                                    if ( names.length == numPlayers ) {
                                        button.removeEventListener( "click", onClick );
                                        resolve( names );
                                    }
                                }
                                button.addEventListener( "click", onClick );
                            } );
                        case 19:
                            names = _context56.sent;
                            _context56.next = 22;
                            return animations.hide( );
                        case 22:
                            screens[ 1 ].style.display = "none";
                            screens[ 2 ].style.display = "block";
                            _context56.next = 26;
                            return wait( 250 );
                        case 26:
                            _context56.next = 28;
                            return animations.show( );
                        case 28:
                            _context56.next = 30;
                            return wait( 500 );
                        case 30:
                            _context56.next = 32;
                            return new Promise( function( resolve ) {
                                var controllers = 0;
                                var messages = [ "Could ".concat( names[ 0 ], " please connect their controller" ), "Could ".concat( names[ 1 ], " please connect their controller" ), "Could ".concat( names[ 2 ], " please connect their controller" ), "Could ".concat( names[ 3 ], " please connect their controller" ) ];
                                var body = document.getElementById( "connectTag" );

                                function onConnect( ) {
                                    controllers++;
                                    if ( controllers == numPlayers ) {
                                        window.removeEventListener( "gamepadconnected", onConnect );
                                        resolve( );
                                    } else {
                                        body.innerHTML = messages[ controllers ];
                                    }
                                }
                                body.innerHTML = messages[ 0 ];
                                window.addEventListener( "gamepadconnected", onConnect );
                            } );
                        case 32:
                            unused = [ "hat", "iron", "thimble", "barrow" ];
                            _context56.next = 35;
                            return animations.hide( );
                        case 35:
                            screens[ 2 ].style.display = "none";
                            screens[ 3 ].style.display = "block";
                            _context56.next = 39;
                            return wait( 250 );
                        case 39:
                            _context56.next = 41;
                            return animations.show( );
                        case 41:
                            _context56.next = 43;
                            return new Promise( function( resolve ) {
                                var players = [ ];
                                var images = Array.from( document.getElementsByClassName( "tokenImage" ) );
                                var ind = 0;

                                function onClick( event ) {
                                    var t = event.target;
                                    t.removeEventListener( "click", onClick );
                                    images.splice( images.indexOf( t ), 1 );
                                    var alt = t.alt;
                                    unused.splice( unused.indexOf( alt ), 1 );
                                    players.push( new Player( ind, names[ ind ], assets.tokens[ alt ] ) );
                                    ind++;
                                    if ( ind == numPlayers ) {
                                        var _iterator15 = _createForOfIteratorHelper( images ),
                                            _step15;
                                        try {
                                            for ( _iterator15.s( ); !( _step15 = _iterator15.n( ) ).done; ) {
                                                var image = _step15.value;
                                                image.removeEventListener( "click", onClick );
                                            }
                                        } catch ( err ) {
                                            _iterator15.e( err );
                                        } finally {
                                            _iterator15.f( );
                                        }
                                        var _iterator16 = _createForOfIteratorHelper( unused ),
                                            _step16;
                                        try {
                                            for ( _iterator16.s( ); !( _step16 = _iterator16.n( ) ).done; ) {
                                                var token = _step16.value;
                                                assets.tokens[ token ].visible = false;
                                            }
                                        } catch ( err ) {
                                            _iterator16.e( err );
                                        } finally {
                                            _iterator16.f( );
                                        }
                                        resolve( players );
                                    }
                                }
                                for ( var _i359 = 0, _images = images; _i359 < _images.length; _i359++ ) {
                                    var image = _images[ _i359 ];
                                    image.addEventListener( "click", onClick );
                                }
                            } );
                        case 43:
                            Globals.players = _context56.sent;
                            _context56.next = 46;
                            return animations.hide( );
                        case 46:
                            screens[ 3 ].style.display = "none";
                            screens[ 4 ].style.display = "block";
                            _context56.next = 50;
                            return wait( 250 );
                        case 50:
                            _context56.next = 52;
                            return animations.show( );
                        case 52:
                            buttonCheck = document.getElementById( "buttonTag" );
                            buttons = {
                                "Circle": O_BUTTON,
                                "Triangle": TRIANGLE_BUTTON,
                                "Square": SQUARE_BUTTON,
                                "X": X_BUTTON
                            };
                            buttonKeys = Object.keys( buttons );
                            _context56.t0 = _regeneratorRuntime( ).keys( Globals.players );
                        case 56:
                            if ( ( _context56.t1 = _context56.t0( ) ).done ) {
                                _context56.next = 65;
                                break;
                            }
                            _i360 = _context56.t1.value;
                            player = Globals.players[ _i360 ];
                            button = buttonKeys[ Math.random( ) * 4 | 0 ];
                            buttonCheck.innerHTML = "Could ".concat( names[ _i360 ], " please hit the " ).concat( button, " button" );
                            _context56.next = 63;
                            return player.awaitButtonPress( buttons[ button ] );
                        case 63:
                            _context56.next = 56;
                            break;
                        case 65:
                            _context56.next = 67;
                            return animations.hide( );
                        case 67:
                            screens[ 4 ].style.display = "none";
                            screens[ 5 ].style.display = "block";
                            _context56.next = 71;
                            return wait( 250 );
                        case 71:
                            _context56.next = 73;
                            return animations.show( );
                        case 73:
                            _context56.next = 75;
                            return gameLoop( );
                        case 75:
                        case "end":
                            return _context56.stop( );
                    }
                }
            }, _callee49 );
        } ) );
        return _onLoad.apply( this, arguments );
    }
    var hdrLoader = new EXRLoader( );
    hdrLoader.load( "../resources/exr/noon_grass_4k.exr", function( texture ) {
        scene.environment = pmrem.fromEquirectangular( texture ).texture;
        loaded.environment = true;
    } );

    function animate( ) {
        update( );
        Dice.update( );
        renderer.render( scene, camera );
        if ( loaded.die && loaded.board && loaded.environment && !loaded.ran ) {
            loaded.ran = true;
            onLoad( );
        }
        requestAnimationFrame( animate );
    }
    animate( );

    function wait( ms ) {
        return new Promise( function( resolve ) {
            setTimeout( resolve, ms );
        } );
    }
} )( );